function PxLoaderImage(e, t, n, r) {
    var i = this,
    s = null;
    this.img = new Image,
    r !== undefined && (this.img.crossOrigin = r),
    this.tags = t,
    this.priority = n;
    var o = function() {
        i.img.readyState === "complete" && (f(), s.onLoad(i))
    },
    u = function() {
        f(),
        s.onLoad(i)
    },
    a = function() {
        f(),
        s.onError(i)
    },
    f = function() {
        i.unbind("load", u),
        i.unbind("readystatechange", o),
        i.unbind("error", a)
    };
    this.start = function(t) {
        s = t,
        i.bind("load", u),
        i.bind("readystatechange", o),
        i.bind("error", a),
        i.img.src = e
    },
    this.checkStatus = function() {
        i.img.complete && (f(), s.onLoad(i))
    },
    this.onTimeout = function() {
        f(),
        i.img.complete ? s.onLoad(i) : s.onTimeout(i)
    },
    this.getName = function() {
        return e
    },
    this.bind = function(e, t) {
        i.img.addEventListener ? i.img.addEventListener(e, t, !1) : i.img.attachEvent && i.img.attachEvent("on" + e, t)
    },
    this.unbind = function(e, t) {
        i.img.removeEventListener ? i.img.removeEventListener(e, t, !1) : i.img.detachEvent && i.img.detachEvent("on" + e, t)
    }
}
function PxLoaderAudio(e, t, n) {
    var r = this,
    i = null;
    this.readyEventName = "canplaythrough";
    try {
        this.audio = new Audio
    } catch(s) {
        this.audio = document.createElement("audio")
    }
    this.tags = t,
    this.priority = n;
    var o = function() {
        if (r.audio.readyState !== 4) return;
        f(),
        i.onLoad(r)
    },
    u = function() {
        f(),
        i.onLoad(r)
    },
    a = function() {
        f(),
        i.onError(r)
    },
    f = function() {
        r.unbind("load", u),
        r.unbind(r.readyEventName, o),
        r.unbind("error", a)
    };
    this.start = function(t) {
        i = t,
        r.bind("load", u),
        r.bind(r.readyEventName, o),
        r.bind("error", a),
        r.bind("suspend", u),
        r.audio.src = e,
        r.audio.load()
    },
    this.checkStatus = function() {
        if (r.audio.readyState !== 4) return;
        f(),
        i.onLoad(r)
    },
    this.onTimeout = function() {
        f(),
        r.audio.readyState !== 4 ? i.onLoad(r) : i.onTimeout(r)
    },
    this.getName = function() {
        return e
    },
    this.bind = function(e, t) {
        r.audio.addEventListener ? r.audio.addEventListener(e, t, !1) : r.audio.attachEvent && r.audio.attachEvent("on" + e, t)
    },
    this.unbind = function(e, t) {
        r.audio.removeEventListener ? r.audio.removeEventListener(e, t, !1) : r.audio.detachEvent && r.audio.detachEvent("on" + e, t)
    }
}
function PxLoaderVideo(e, t, n, r) {
    var i = this,
    s = null;
    this.readyEventName = "canplaythrough";
    try {
        this.vid = new Video
    } catch(o) {
        this.vid = document.createElement("video")
    }
    r !== undefined && (this.vid.crossOrigin = r),
    this.tags = t,
    this.priority = n;
    var u = function() {
        if (i.vid.readyState !== 4) return;
        l(),
        s.onLoad(i)
    },
    a = function() {
        l(),
        s.onLoad(i)
    },
    f = function() {
        l(),
        s.onError(i)
    },
    l = function() {
        i.unbind("load", a),
        i.unbind(i.readyEventName, u),
        i.unbind("error", f)
    };
    this.start = function(t) {
        s = t,
        i.bind("load", a),
        i.bind(i.readyEventName, u),
        i.bind("error", f),
        i.bind("suspend", a),
        i.vid.src = e,
        i.vid.load()
    },
    this.checkStatus = function() {
        if (i.vid.readyState !== 4) return;
        l(),
        s.onLoad(i)
    },
    this.onTimeout = function() {
        l(),
        i.vid.readyState !== 4 ? s.onLoad(i) : s.onTimeout(i)
    },
    this.getName = function() {
        return e
    },
    this.bind = function(e, t) {
        i.vid.addEventListener ? i.vid.addEventListener(e, t, !1) : i.vid.attachEvent && i.vid.attachEvent("on" + e, t)
    },
    this.unbind = function(e, t) {
        i.vid.removeEventListener ? i.vid.removeEventListener(e, t, !1) : i.vid.detachEvent && i.vid.detachEvent("on" + e, t)
    }
} !
function(e, t) {
    "object" == typeof module && "object" == typeof module.exports ? module.exports = e.document ? t(e, !0) : function(e) {
        if (!e.document) throw new Error("jQuery requires a window with a document");
        return t(e)
    }: t(e)
} ("undefined" != typeof window ? window: this,
function(a, b) {
    function s(e) {
        var t = "length" in e && e.length,
        r = n.type(e);
        return "function" === r || n.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === r || 0 === t || "number" == typeof t && t > 0 && t - 1 in e
    }
    function x(e, t, r) {
        if (n.isFunction(t)) return n.grep(e,
        function(e, n) {
            return !! t.call(e, n, e) !== r
        });
        if (t.nodeType) return n.grep(e,
        function(e) {
            return e === t !== r
        });
        if ("string" == typeof t) {
            if (w.test(t)) return n.filter(t, e, r);
            t = n.filter(t, e)
        }
        return n.grep(e,
        function(e) {
            return g.call(t, e) >= 0 !== r
        })
    }
    function D(e, t) {
        while ((e = e[t]) && 1 !== e.nodeType);
        return e
    }
    function G(e) {
        var t = F[e] = {};
        return n.each(e.match(E) || [],
        function(e, n) {
            t[n] = !0
        }),
        t
    }
    function I() {
        l.removeEventListener("DOMContentLoaded", I, !1),
        a.removeEventListener("load", I, !1),
        n.ready()
    }
    function K() {
        Object.defineProperty(this.cache = {},
        0, {
            get: function() {
                return {}
            }
        }),
        this.expando = n.expando + K.uid++
    }
    function P(e, t, r) {
        var i;
        if (void 0 === r && 1 === e.nodeType) if (i = "data-" + t.replace(O, "-$1").toLowerCase(), r = e.getAttribute(i), "string" == typeof r) {
            try {
                r = "true" === r ? !0 : "false" === r ? !1 : "null" === r ? null: +r + "" === r ? +r: N.test(r) ? n.parseJSON(r) : r
            } catch(s) {}
            M.set(e, t, r)
        } else r = void 0;
        return r
    }
    function Z() {
        return ! 0
    }
    function $() {
        return ! 1
    }
    function _() {
        try {
            return l.activeElement
        } catch(e) {}
    }
    function ja(e, t) {
        return n.nodeName(e, "table") && n.nodeName(11 !== t.nodeType ? t: t.firstChild, "tr") ? e.getElementsByTagName("tbody")[0] || e.appendChild(e.ownerDocument.createElement("tbody")) : e
    }
    function ka(e) {
        return e.type = (null !== e.getAttribute("type")) + "/" + e.type,
        e
    }
    function la(e) {
        var t = ga.exec(e.type);
        return t ? e.type = t[1] : e.removeAttribute("type"),
        e
    }
    function ma(e, t) {
        for (var n = 0,
        r = e.length; r > n; n++) L.set(e[n], "globalEval", !t || L.get(t[n], "globalEval"))
    }
    function na(e, t) {
        var r, i, s, o, u, a, f, l;
        if (1 === t.nodeType) {
            if (L.hasData(e) && (o = L.access(e), u = L.set(t, o), l = o.events)) {
                delete u.handle,
                u.events = {};
                for (s in l) for (r = 0, i = l[s].length; i > r; r++) n.event.add(t, s, l[s][r])
            }
            M.hasData(e) && (a = M.access(e), f = n.extend({},
            a), M.set(t, f))
        }
    }
    function oa(e, t) {
        var r = e.getElementsByTagName ? e.getElementsByTagName(t || "*") : e.querySelectorAll ? e.querySelectorAll(t || "*") : [];
        return void 0 === t || t && n.nodeName(e, t) ? n.merge([e], r) : r
    }
    function pa(e, t) {
        var n = t.nodeName.toLowerCase();
        "input" === n && T.test(e.type) ? t.checked = e.checked: ("input" === n || "textarea" === n) && (t.defaultValue = e.defaultValue)
    }
    function sa(e, t) {
        var r, i = n(t.createElement(e)).appendTo(t.body),
        s = a.getDefaultComputedStyle && (r = a.getDefaultComputedStyle(i[0])) ? r.display: n.css(i[0], "display");
        return i.detach(),
        s
    }
    function ta(e) {
        var t = l,
        r = ra[e];
        return r || (r = sa(e, t), "none" !== r && r || (qa = (qa || n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(t.documentElement), t = qa[0].contentDocument, t.write(), t.close(), r = sa(e, t), qa.detach()), ra[e] = r),
        r
    }
    function xa(e, t, r) {
        var i, s, o, u, a = e.style;
        return r = r || wa(e),
        r && (u = r.getPropertyValue(t) || r[t]),
        r && ("" !== u || n.contains(e.ownerDocument, e) || (u = n.style(e, t)), va.test(u) && ua.test(t) && (i = a.width, s = a.minWidth, o = a.maxWidth, a.minWidth = a.maxWidth = a.width = u, u = r.width, a.width = i, a.minWidth = s, a.maxWidth = o)),
        void 0 !== u ? u + "": u
    }
    function ya(e, t) {
        return {
            get: function() {
                return e() ? void delete this.get: (this.get = t).apply(this, arguments)
            }
        }
    }
    function Fa(e, t) {
        if (t in e) return t;
        var n = t[0].toUpperCase() + t.slice(1),
        r = t,
        i = Ea.length;
        while (i--) if (t = Ea[i] + n, t in e) return t;
        return r
    }
    function Ga(e, t, n) {
        var r = Aa.exec(t);
        return r ? Math.max(0, r[1] - (n || 0)) + (r[2] || "px") : t
    }
    function Ha(e, t, r, i, s) {
        for (var o = r === (i ? "border": "content") ? 4 : "width" === t ? 1 : 0, u = 0; 4 > o; o += 2)"margin" === r && (u += n.css(e, r + R[o], !0, s)),
        i ? ("content" === r && (u -= n.css(e, "padding" + R[o], !0, s)), "margin" !== r && (u -= n.css(e, "border" + R[o] + "Width", !0, s))) : (u += n.css(e, "padding" + R[o], !0, s), "padding" !== r && (u += n.css(e, "border" + R[o] + "Width", !0, s)));
        return u
    }
    function Ia(e, t, r) {
        var i = !0,
        s = "width" === t ? e.offsetWidth: e.offsetHeight,
        o = wa(e),
        u = "border-box" === n.css(e, "boxSizing", !1, o);
        if (0 >= s || null == s) {
            if (s = xa(e, t, o), (0 > s || null == s) && (s = e.style[t]), va.test(s)) return s;
            i = u && (k.boxSizingReliable() || s === e.style[t]),
            s = parseFloat(s) || 0
        }
        return s + Ha(e, t, r || (u ? "border": "content"), i, o) + "px"
    }
    function Ja(e, t) {
        for (var r, i, s, o = [], u = 0, a = e.length; a > u; u++) i = e[u],
        i.style && (o[u] = L.get(i, "olddisplay"), r = i.style.display, t ? (o[u] || "none" !== r || (i.style.display = ""), "" === i.style.display && S(i) && (o[u] = L.access(i, "olddisplay", ta(i.nodeName)))) : (s = S(i), "none" === r && s || L.set(i, "olddisplay", s ? r: n.css(i, "display"))));
        for (u = 0; a > u; u++) i = e[u],
        i.style && (t && "none" !== i.style.display && "" !== i.style.display || (i.style.display = t ? o[u] || "": "none"));
        return e
    }
    function Ka(e, t, n, r, i) {
        return new Ka.prototype.init(e, t, n, r, i)
    }
    function Sa() {
        return setTimeout(function() {
            La = void 0
        }),
        La = n.now()
    }
    function Ta(e, t) {
        var n, r = 0,
        i = {
            height: e
        };
        for (t = t ? 1 : 0; 4 > r; r += 2 - t) n = R[r],
        i["margin" + n] = i["padding" + n] = e;
        return t && (i.opacity = i.width = e),
        i
    }
    function Ua(e, t, n) {
        for (var r, i = (Ra[t] || []).concat(Ra["*"]), s = 0, o = i.length; o > s; s++) if (r = i[s].call(n, t, e)) return r
    }
    function Va(e, t, r) {
        var i, s, o, u, a, f, l, c, h = this,
        p = {},
        d = e.style,
        v = e.nodeType && S(e),
        m = L.get(e, "fxshow");
        r.queue || (a = n._queueHooks(e, "fx"), null == a.unqueued && (a.unqueued = 0, f = a.empty.fire, a.empty.fire = function() {
            a.unqueued || f()
        }), a.unqueued++, h.always(function() {
            h.always(function() {
                a.unqueued--,
                n.queue(e, "fx").length || a.empty.fire()
            })
        })),
        1 === e.nodeType && ("height" in t || "width" in t) && (r.overflow = [d.overflow, d.overflowX, d.overflowY], l = n.css(e, "display"), c = "none" === l ? L.get(e, "olddisplay") || ta(e.nodeName) : l, "inline" === c && "none" === n.css(e, "float") && (d.display = "inline-block")),
        r.overflow && (d.overflow = "hidden", h.always(function() {
            d.overflow = r.overflow[0],
            d.overflowX = r.overflow[1],
            d.overflowY = r.overflow[2]
        }));
        for (i in t) if (s = t[i], Na.exec(s)) {
            if (delete t[i], o = o || "toggle" === s, s === (v ? "hide": "show")) {
                if ("show" !== s || !m || void 0 === m[i]) continue;
                v = !0
            }
            p[i] = m && m[i] || n.style(e, i)
        } else l = void 0;
        if (n.isEmptyObject(p))"inline" === ("none" === l ? ta(e.nodeName) : l) && (d.display = l);
        else {
            m ? "hidden" in m && (v = m.hidden) : m = L.access(e, "fxshow", {}),
            o && (m.hidden = !v),
            v ? n(e).show() : h.done(function() {
                n(e).hide()
            }),
            h.done(function() {
                var t;
                L.remove(e, "fxshow");
                for (t in p) n.style(e, t, p[t])
            });
            for (i in p) u = Ua(v ? m[i] : 0, i, h),
            i in m || (m[i] = u.start, v && (u.end = u.start, u.start = "width" === i || "height" === i ? 1 : 0))
        }
    }
    function Wa(e, t) {
        var r, i, s, o, u;
        for (r in e) if (i = n.camelCase(r), s = t[i], o = e[r], n.isArray(o) && (s = o[1], o = e[r] = o[0]), r !== i && (e[i] = o, delete e[r]), u = n.cssHooks[i], u && "expand" in u) {
            o = u.expand(o),
            delete e[i];
            for (r in o) r in e || (e[r] = o[r], t[r] = s)
        } else t[i] = s
    }
    function Xa(e, t, r) {
        var i, s, o = 0,
        u = Qa.length,
        a = n.Deferred().always(function() {
            delete f.elem
        }),
        f = function() {
            if (s) return ! 1;
            for (var t = La || Sa(), n = Math.max(0, l.startTime + l.duration - t), r = n / l.duration || 0, i = 1 - r, o = 0, u = l.tweens.length; u > o; o++) l.tweens[o].run(i);
            return a.notifyWith(e, [l, i, n]),
            1 > i && u ? n: (a.resolveWith(e, [l]), !1)
        },
        l = a.promise({
            elem: e,
            props: n.extend({},
            t),
            opts: n.extend(!0, {
                specialEasing: {}
            },
            r),
            originalProperties: t,
            originalOptions: r,
            startTime: La || Sa(),
            duration: r.duration,
            tweens: [],
            createTween: function(t, r) {
                var i = n.Tween(e, l.opts, t, r, l.opts.specialEasing[t] || l.opts.easing);
                return l.tweens.push(i),
                i
            },
            stop: function(t) {
                var n = 0,
                r = t ? l.tweens.length: 0;
                if (s) return this;
                for (s = !0; r > n; n++) l.tweens[n].run(1);
                return t ? a.resolveWith(e, [l, t]) : a.rejectWith(e, [l, t]),
                this
            }
        }),
        c = l.props;
        for (Wa(c, l.opts.specialEasing); u > o; o++) if (i = Qa[o].call(l, e, c, l.opts)) return i;
        return n.map(c, Ua, l),
        n.isFunction(l.opts.start) && l.opts.start.call(e, l),
        n.fx.timer(n.extend(f, {
            elem: e,
            anim: l,
            queue: l.opts.queue
        })),
        l.progress(l.opts.progress).done(l.opts.done, l.opts.complete).fail(l.opts.fail).always(l.opts.always)
    }
    function qb(e) {
        return function(t, r) {
            "string" != typeof t && (r = t, t = "*");
            var i, s = 0,
            o = t.toLowerCase().match(E) || [];
            if (n.isFunction(r)) while (i = o[s++])"+" === i[0] ? (i = i.slice(1) || "*", (e[i] = e[i] || []).unshift(r)) : (e[i] = e[i] || []).push(r)
        }
    }
    function rb(e, t, r, i) {
        function u(l) {
            var h;
            return s[l] = !0,
            n.each(e[l] || [],
            function(e, n) {
                var a = n(t, r, i);
                return "string" != typeof a || o || s[a] ? o ? !(h = a) : void 0 : (t.dataTypes.unshift(a), u(a), !1)
            }),
            h
        }
        var s = {},
        o = e === mb;
        return u(t.dataTypes[0]) || !s["*"] && u("*")
    }
    function sb(e, t) {
        var r, i, s = n.ajaxSettings.flatOptions || {};
        for (r in t) void 0 !== t[r] && ((s[r] ? e: i || (i = {}))[r] = t[r]);
        return i && n.extend(!0, e, i),
        e
    }
    function tb(e, t, n) {
        var r, i, s, o, u = e.contents,
        a = e.dataTypes;
        while ("*" === a[0]) a.shift(),
        void 0 === r && (r = e.mimeType || t.getResponseHeader("Content-Type"));
        if (r) for (i in u) if (u[i] && u[i].test(r)) {
            a.unshift(i);
            break
        }
        if (a[0] in n) s = a[0];
        else {
            for (i in n) {
                if (!a[0] || e.converters[i + " " + a[0]]) {
                    s = i;
                    break
                }
                o || (o = i)
            }
            s = s || o
        }
        return s ? (s !== a[0] && a.unshift(s), n[s]) : void 0
    }
    function ub(e, t, n, r) {
        var i, s, o, u, a, f = {},
        l = e.dataTypes.slice();
        if (l[1]) for (o in e.converters) f[o.toLowerCase()] = e.converters[o];
        s = l.shift();
        while (s) if (e.responseFields[s] && (n[e.responseFields[s]] = t), !a && r && e.dataFilter && (t = e.dataFilter(t, e.dataType)), a = s, s = l.shift()) if ("*" === s) s = a;
        else if ("*" !== a && a !== s) {
            if (o = f[a + " " + s] || f["* " + s], !o) for (i in f) if (u = i.split(" "), u[1] === s && (o = f[a + " " + u[0]] || f["* " + u[0]])) {
                o === !0 ? o = f[i] : f[i] !== !0 && (s = u[0], l.unshift(u[1]));
                break
            }
            if (o !== !0) if (o && e["throws"]) t = o(t);
            else try {
                t = o(t)
            } catch(c) {
                return {
                    state: "parsererror",
                    error: o ? c: "No conversion from " + a + " to " + s
                }
            }
        }
        return {
            state: "success",
            data: t
        }
    }
    function Ab(e, t, r, i) {
        var s;
        if (n.isArray(t)) n.each(t,
        function(t, n) {
            r || wb.test(e) ? i(e, n) : Ab(e + "[" + ("object" == typeof n ? t: "") + "]", n, r, i)
        });
        else if (r || "object" !== n.type(t)) i(e, t);
        else for (s in t) Ab(e + "[" + s + "]", t[s], r, i)
    }
    function Jb(e) {
        return n.isWindow(e) ? e: 9 === e.nodeType && e.defaultView
    }
    var c = [],
    d = c.slice,
    e = c.concat,
    f = c.push,
    g = c.indexOf,
    h = {},
    i = h.toString,
    j = h.hasOwnProperty,
    k = {},
    l = a.document,
    m = "2.1.4",
    n = function(e, t) {
        return new n.fn.init(e, t)
    },
    o = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    p = /^-ms-/,
    q = /-([\da-z])/gi,
    r = function(e, t) {
        return t.toUpperCase()
    };
    n.fn = n.prototype = {
        jquery: m,
        constructor: n,
        selector: "",
        length: 0,
        toArray: function() {
            return d.call(this)
        },
        get: function(e) {
            return null != e ? 0 > e ? this[e + this.length] : this[e] : d.call(this)
        },
        pushStack: function(e) {
            var t = n.merge(this.constructor(), e);
            return t.prevObject = this,
            t.context = this.context,
            t
        },
        each: function(e, t) {
            return n.each(this, e, t)
        },
        map: function(e) {
            return this.pushStack(n.map(this,
            function(t, n) {
                return e.call(t, n, t)
            }))
        },
        slice: function() {
            return this.pushStack(d.apply(this, arguments))
        },
        first: function() {
            return this.eq(0)
        },
        last: function() {
            return this.eq( - 1)
        },
        eq: function(e) {
            var t = this.length,
            n = +e + (0 > e ? t: 0);
            return this.pushStack(n >= 0 && t > n ? [this[n]] : [])
        },
        end: function() {
            return this.prevObject || this.constructor(null)
        },
        push: f,
        sort: c.sort,
        splice: c.splice
    },
    n.extend = n.fn.extend = function() {
        var e, t, r, i, s, o, u = arguments[0] || {},
        a = 1,
        f = arguments.length,
        l = !1;
        for ("boolean" == typeof u && (l = u, u = arguments[a] || {},
        a++), "object" == typeof u || n.isFunction(u) || (u = {}), a === f && (u = this, a--); f > a; a++) if (null != (e = arguments[a])) for (t in e) r = u[t],
        i = e[t],
        u !== i && (l && i && (n.isPlainObject(i) || (s = n.isArray(i))) ? (s ? (s = !1, o = r && n.isArray(r) ? r: []) : o = r && n.isPlainObject(r) ? r: {},
        u[t] = n.extend(l, o, i)) : void 0 !== i && (u[t] = i));
        return u
    },
    n.extend({
        expando: "jQuery" + (m + Math.random()).replace(/\D/g, ""),
        isReady: !0,
        error: function(e) {
            throw new Error(e)
        },
        noop: function() {},
        isFunction: function(e) {
            return "function" === n.type(e)
        },
        isArray: Array.isArray,
        isWindow: function(e) {
            return null != e && e === e.window
        },
        isNumeric: function(e) {
            return ! n.isArray(e) && e - parseFloat(e) + 1 >= 0
        },
        isPlainObject: function(e) {
            return "object" !== n.type(e) || e.nodeType || n.isWindow(e) ? !1 : e.constructor && !j.call(e.constructor.prototype, "isPrototypeOf") ? !1 : !0
        },
        isEmptyObject: function(e) {
            var t;
            for (t in e) return ! 1;
            return ! 0
        },
        type: function(e) {
            return null == e ? e + "": "object" == typeof e || "function" == typeof e ? h[i.call(e)] || "object": typeof e
        },
        globalEval: function(a) {
            var b, c = eval;
            a = n.trim(a),
            a && (1 === a.indexOf("use strict") ? (b = l.createElement("script"), b.text = a, l.head.appendChild(b).parentNode.removeChild(b)) : c(a))
        },
        camelCase: function(e) {
            return e.replace(p, "ms-").replace(q, r)
        },
        nodeName: function(e, t) {
            return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase()
        },
        each: function(e, t, n) {
            var r, i = 0,
            o = e.length,
            u = s(e);
            if (n) {
                if (u) {
                    for (; o > i; i++) if (r = t.apply(e[i], n), r === !1) break
                } else for (i in e) if (r = t.apply(e[i], n), r === !1) break
            } else if (u) {
                for (; o > i; i++) if (r = t.call(e[i], i, e[i]), r === !1) break
            } else for (i in e) if (r = t.call(e[i], i, e[i]), r === !1) break;
            return e
        },
        trim: function(e) {
            return null == e ? "": (e + "").replace(o, "")
        },
        makeArray: function(e, t) {
            var r = t || [];
            return null != e && (s(Object(e)) ? n.merge(r, "string" == typeof e ? [e] : e) : f.call(r, e)),
            r
        },
        inArray: function(e, t, n) {
            return null == t ? -1 : g.call(t, e, n)
        },
        merge: function(e, t) {
            for (var n = +t.length,
            r = 0,
            i = e.length; n > r; r++) e[i++] = t[r];
            return e.length = i,
            e
        },
        grep: function(e, t, n) {
            for (var r, i = [], s = 0, o = e.length, u = !n; o > s; s++) r = !t(e[s], s),
            r !== u && i.push(e[s]);
            return i
        },
        map: function(t, n, r) {
            var i, o = 0,
            u = t.length,
            a = s(t),
            f = [];
            if (a) for (; u > o; o++) i = n(t[o], o, r),
            null != i && f.push(i);
            else for (o in t) i = n(t[o], o, r),
            null != i && f.push(i);
            return e.apply([], f)
        },
        guid: 1,
        proxy: function(e, t) {
            var r, i, s;
            return "string" == typeof t && (r = e[t], t = e, e = r),
            n.isFunction(e) ? (i = d.call(arguments, 2), s = function() {
                return e.apply(t || this, i.concat(d.call(arguments)))
            },
            s.guid = e.guid = e.guid || n.guid++, s) : void 0
        },
        now: Date.now,
        support: k
    }),
    n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),
    function(e, t) {
        h["[object " + t + "]"] = t.toLowerCase()
    });
    var t = function(e) {
        function ot(e, t, r, i) {
            var s, u, f, l, c, d, g, y, S, x;
            if ((t ? t.ownerDocument || t: E) !== p && h(t), t = t || p, r = r || [], l = t.nodeType, "string" != typeof e || !e || 1 !== l && 9 !== l && 11 !== l) return r;
            if (!i && v) {
                if (11 !== l && (s = Z.exec(e))) if (f = s[1]) {
                    if (9 === l) {
                        if (u = t.getElementById(f), !u || !u.parentNode) return r;
                        if (u.id === f) return r.push(u),
                        r
                    } else if (t.ownerDocument && (u = t.ownerDocument.getElementById(f)) && b(t, u) && u.id === f) return r.push(u),
                    r
                } else {
                    if (s[2]) return D.apply(r, t.getElementsByTagName(e)),
                    r;
                    if ((f = s[3]) && n.getElementsByClassName) return D.apply(r, t.getElementsByClassName(f)),
                    r
                }
                if (n.qsa && (!m || !m.test(e))) {
                    if (y = g = w, S = t, x = 1 !== l && e, 1 === l && "object" !== t.nodeName.toLowerCase()) {
                        d = o(e),
                        (g = t.getAttribute("id")) ? y = g.replace(tt, "\\$&") : t.setAttribute("id", y),
                        y = "[id='" + y + "'] ",
                        c = d.length;
                        while (c--) d[c] = y + gt(d[c]);
                        S = et.test(e) && vt(t.parentNode) || t,
                        x = d.join(",")
                    }
                    if (x) try {
                        return D.apply(r, S.querySelectorAll(x)),
                        r
                    } catch(T) {} finally {
                        g || t.removeAttribute("id")
                    }
                }
            }
            return a(e.replace(z, "$1"), t, r, i)
        }
        function ut() {
            function t(n, i) {
                return e.push(n + " ") > r.cacheLength && delete t[e.shift()],
                t[n + " "] = i
            }
            var e = [];
            return t
        }
        function at(e) {
            return e[w] = !0,
            e
        }
        function ft(e) {
            var t = p.createElement("div");
            try {
                return !! e(t)
            } catch(n) {
                return ! 1
            } finally {
                t.parentNode && t.parentNode.removeChild(t),
                t = null
            }
        }
        function lt(e, t) {
            var n = e.split("|"),
            i = e.length;
            while (i--) r.attrHandle[n[i]] = t
        }
        function ct(e, t) {
            var n = t && e,
            r = n && 1 === e.nodeType && 1 === t.nodeType && (~t.sourceIndex || L) - (~e.sourceIndex || L);
            if (r) return r;
            if (n) while (n = n.nextSibling) if (n === t) return - 1;
            return e ? 1 : -1
        }
        function ht(e) {
            return function(t) {
                var n = t.nodeName.toLowerCase();
                return "input" === n && t.type === e
            }
        }
        function pt(e) {
            return function(t) {
                var n = t.nodeName.toLowerCase();
                return ("input" === n || "button" === n) && t.type === e
            }
        }
        function dt(e) {
            return at(function(t) {
                return t = +t,
                at(function(n, r) {
                    var i, s = e([], n.length, t),
                    o = s.length;
                    while (o--) n[i = s[o]] && (n[i] = !(r[i] = n[i]))
                })
            })
        }
        function vt(e) {
            return e && "undefined" != typeof e.getElementsByTagName && e
        }
        function mt() {}
        function gt(e) {
            for (var t = 0,
            n = e.length,
            r = ""; n > t; t++) r += e[t].value;
            return r
        }
        function yt(e, t, n) {
            var r = t.dir,
            i = n && "parentNode" === r,
            s = x++;
            return t.first ?
            function(t, n, s) {
                while (t = t[r]) if (1 === t.nodeType || i) return e(t, n, s)
            }: function(t, n, o) {
                var u, a, f = [S, s];
                if (o) {
                    while (t = t[r]) if ((1 === t.nodeType || i) && e(t, n, o)) return ! 0
                } else while (t = t[r]) if (1 === t.nodeType || i) {
                    if (a = t[w] || (t[w] = {}), (u = a[r]) && u[0] === S && u[1] === s) return f[2] = u[2];
                    if (a[r] = f, f[2] = e(t, n, o)) return ! 0
                }
            }
        }
        function bt(e) {
            return e.length > 1 ?
            function(t, n, r) {
                var i = e.length;
                while (i--) if (!e[i](t, n, r)) return ! 1;
                return ! 0
            }: e[0]
        }
        function wt(e, t, n) {
            for (var r = 0,
            i = t.length; i > r; r++) ot(e, t[r], n);
            return n
        }
        function Et(e, t, n, r, i) {
            for (var s, o = [], u = 0, a = e.length, f = null != t; a > u; u++)(s = e[u]) && (!n || n(s, r, i)) && (o.push(s), f && t.push(u));
            return o
        }
        function St(e, t, n, r, i, s) {
            return r && !r[w] && (r = St(r)),
            i && !i[w] && (i = St(i, s)),
            at(function(s, o, u, a) {
                var f, l, c, h = [],
                p = [],
                d = o.length,
                v = s || wt(t || "*", u.nodeType ? [u] : u, []),
                m = !e || !s && t ? v: Et(v, h, e, u, a),
                g = n ? i || (s ? e: d || r) ? [] : o: m;
                if (n && n(m, g, u, a), r) {
                    f = Et(g, p),
                    r(f, [], u, a),
                    l = f.length;
                    while (l--)(c = f[l]) && (g[p[l]] = !(m[p[l]] = c))
                }
                if (s) {
                    if (i || e) {
                        if (i) {
                            f = [],
                            l = g.length;
                            while (l--)(c = g[l]) && f.push(m[l] = c);
                            i(null, g = [], f, a)
                        }
                        l = g.length;
                        while (l--)(c = g[l]) && (f = i ? H(s, c) : h[l]) > -1 && (s[f] = !(o[f] = c))
                    }
                } else g = Et(g === o ? g.splice(d, g.length) : g),
                i ? i(null, o, g, a) : D.apply(o, g)
            })
        }
        function xt(e) {
            for (var t, n, i, s = e.length,
            o = r.relative[e[0].type], u = o || r.relative[" "], a = o ? 1 : 0, l = yt(function(e) {
                return e === t
            },
            u, !0), c = yt(function(e) {
                return H(t, e) > -1
            },
            u, !0), h = [function(e, n, r) {
                var i = !o && (r || n !== f) || ((t = n).nodeType ? l(e, n, r) : c(e, n, r));
                return t = null,
                i
            }]; s > a; a++) if (n = r.relative[e[a].type]) h = [yt(bt(h), n)];
            else {
                if (n = r.filter[e[a].type].apply(null, e[a].matches), n[w]) {
                    for (i = ++a; s > i; i++) if (r.relative[e[i].type]) break;
                    return St(a > 1 && bt(h), a > 1 && gt(e.slice(0, a - 1).concat({
                        value: " " === e[a - 2].type ? "*": ""
                    })).replace(z, "$1"), n, i > a && xt(e.slice(a, i)), s > i && xt(e = e.slice(i)), s > i && gt(e))
                }
                h.push(n)
            }
            return bt(h)
        }
        function Tt(e, t) {
            var n = t.length > 0,
            i = e.length > 0,
            s = function(s, o, u, a, l) {
                var c, h, d, v = 0,
                m = "0",
                g = s && [],
                y = [],
                b = f,
                w = s || i && r.find.TAG("*", l),
                E = S += null == b ? 1 : Math.random() || .1,
                x = w.length;
                for (l && (f = o !== p && o); m !== x && null != (c = w[m]); m++) {
                    if (i && c) {
                        h = 0;
                        while (d = e[h++]) if (d(c, o, u)) {
                            a.push(c);
                            break
                        }
                        l && (S = E)
                    }
                    n && ((c = !d && c) && v--, s && g.push(c))
                }
                if (v += m, n && m !== v) {
                    h = 0;
                    while (d = t[h++]) d(g, y, o, u);
                    if (s) {
                        if (v > 0) while (m--) g[m] || y[m] || (y[m] = M.call(a));
                        y = Et(y)
                    }
                    D.apply(a, y),
                    l && !s && y.length > 0 && v + t.length > 1 && ot.uniqueSort(a)
                }
                return l && (S = E, f = b),
                g
            };
            return n ? at(s) : s
        }
        var t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g, y, b, w = "sizzle" + 1 * new Date,
        E = e.document,
        S = 0,
        x = 0,
        T = ut(),
        N = ut(),
        C = ut(),
        k = function(e, t) {
            return e === t && (c = !0),
            0
        },
        L = 1 << 31,
        A = {}.hasOwnProperty,
        O = [],
        M = O.pop,
        _ = O.push,
        D = O.push,
        P = O.slice,
        H = function(e, t) {
            for (var n = 0,
            r = e.length; r > n; n++) if (e[n] === t) return n;
            return - 1
        },
        B = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        j = "[\\x20\\t\\r\\n\\f]",
        F = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        I = F.replace("w", "w#"),
        q = "\\[" + j + "*(" + F + ")(?:" + j + "*([*^$|!~]?=)" + j + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + I + "))|)" + j + "*\\]",
        R = ":(" + F + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + q + ")*)|.*)\\)|)",
        U = new RegExp(j + "+", "g"),
        z = new RegExp("^" + j + "+|((?:^|[^\\\\])(?:\\\\.)*)" + j + "+$", "g"),
        W = new RegExp("^" + j + "*," + j + "*"),
        X = new RegExp("^" + j + "*([>+~]|" + j + ")" + j + "*"),
        V = new RegExp("=" + j + "*([^\\]'\"]*?)" + j + "*\\]", "g"),
        $ = new RegExp(R),
        J = new RegExp("^" + I + "$"),
        K = {
            ID: new RegExp("^#(" + F + ")"),
            CLASS: new RegExp("^\\.(" + F + ")"),
            TAG: new RegExp("^(" + F.replace("w", "w*") + ")"),
            ATTR: new RegExp("^" + q),
            PSEUDO: new RegExp("^" + R),
            CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + j + "*(even|odd|(([+-]|)(\\d*)n|)" + j + "*(?:([+-]|)" + j + "*(\\d+)|))" + j + "*\\)|)", "i"),
            bool: new RegExp("^(?:" + B + ")$", "i"),
            needsContext: new RegExp("^" + j + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + j + "*((?:-\\d)?\\d*)" + j + "*\\)|)(?=[^-]|$)", "i")
        },
        Q = /^(?:input|select|textarea|button)$/i,
        G = /^h\d$/i,
        Y = /^[^{]+\{\s*\[native \w/,
        Z = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        et = /[+~]/,
        tt = /'|\\/g,
        nt = new RegExp("\\\\([\\da-f]{1,6}" + j + "?|(" + j + ")|.)", "ig"),
        rt = function(e, t, n) {
            var r = "0x" + t - 65536;
            return r !== r || n ? t: 0 > r ? String.fromCharCode(r + 65536) : String.fromCharCode(r >> 10 | 55296, 1023 & r | 56320)
        },
        it = function() {
            h()
        };
        try {
            D.apply(O = P.call(E.childNodes), E.childNodes),
            O[E.childNodes.length].nodeType
        } catch(st) {
            D = {
                apply: O.length ?
                function(e, t) {
                    _.apply(e, P.call(t))
                }: function(e, t) {
                    var n = e.length,
                    r = 0;
                    while (e[n++] = t[r++]);
                    e.length = n - 1
                }
            }
        }
        n = ot.support = {},
        s = ot.isXML = function(e) {
            var t = e && (e.ownerDocument || e).documentElement;
            return t ? "HTML" !== t.nodeName: !1
        },
        h = ot.setDocument = function(e) {
            var t, i, o = e ? e.ownerDocument || e: E;
            return o !== p && 9 === o.nodeType && o.documentElement ? (p = o, d = o.documentElement, i = o.defaultView, i && i !== i.top && (i.addEventListener ? i.addEventListener("unload", it, !1) : i.attachEvent && i.attachEvent("onunload", it)), v = !s(o), n.attributes = ft(function(e) {
                return e.className = "i",
                !e.getAttribute("className")
            }), n.getElementsByTagName = ft(function(e) {
                return e.appendChild(o.createComment("")),
                !e.getElementsByTagName("*").length
            }), n.getElementsByClassName = Y.test(o.getElementsByClassName), n.getById = ft(function(e) {
                return d.appendChild(e).id = w,
                !o.getElementsByName || !o.getElementsByName(w).length
            }), n.getById ? (r.find.ID = function(e, t) {
                if ("undefined" != typeof t.getElementById && v) {
                    var n = t.getElementById(e);
                    return n && n.parentNode ? [n] : []
                }
            },
            r.filter.ID = function(e) {
                var t = e.replace(nt, rt);
                return function(e) {
                    return e.getAttribute("id") === t
                }
            }) : (delete r.find.ID, r.filter.ID = function(e) {
                var t = e.replace(nt, rt);
                return function(e) {
                    var n = "undefined" != typeof e.getAttributeNode && e.getAttributeNode("id");
                    return n && n.value === t
                }
            }), r.find.TAG = n.getElementsByTagName ?
            function(e, t) {
                return "undefined" != typeof t.getElementsByTagName ? t.getElementsByTagName(e) : n.qsa ? t.querySelectorAll(e) : void 0
            }: function(e, t) {
                var n, r = [],
                i = 0,
                s = t.getElementsByTagName(e);
                if ("*" === e) {
                    while (n = s[i++]) 1 === n.nodeType && r.push(n);
                    return r
                }
                return s
            },
            r.find.CLASS = n.getElementsByClassName &&
            function(e, t) {
                return v ? t.getElementsByClassName(e) : void 0
            },
            g = [], m = [], (n.qsa = Y.test(o.querySelectorAll)) && (ft(function(e) {
                d.appendChild(e).innerHTML = "<a id='" + w + "'></a><select id='" + w + "-\f]' msallowcapture=''><option selected=''></option></select>",
                e.querySelectorAll("[msallowcapture^='']").length && m.push("[*^$]=" + j + "*(?:''|\"\")"),
                e.querySelectorAll("[selected]").length || m.push("\\[" + j + "*(?:value|" + B + ")"),
                e.querySelectorAll("[id~=" + w + "-]").length || m.push("~="),
                e.querySelectorAll(":checked").length || m.push(":checked"),
                e.querySelectorAll("a#" + w + "+*").length || m.push(".#.+[+~]")
            }), ft(function(e) {
                var t = o.createElement("input");
                t.setAttribute("type", "hidden"),
                e.appendChild(t).setAttribute("name", "D"),
                e.querySelectorAll("[name=d]").length && m.push("name" + j + "*[*^$|!~]?="),
                e.querySelectorAll(":enabled").length || m.push(":enabled", ":disabled"),
                e.querySelectorAll("*,:x"),
                m.push(",.*:")
            })), (n.matchesSelector = Y.test(y = d.matches || d.webkitMatchesSelector || d.mozMatchesSelector || d.oMatchesSelector || d.msMatchesSelector)) && ft(function(e) {
                n.disconnectedMatch = y.call(e, "div"),
                y.call(e, "[s!='']:x"),
                g.push("!=", R)
            }), m = m.length && new RegExp(m.join("|")), g = g.length && new RegExp(g.join("|")), t = Y.test(d.compareDocumentPosition), b = t || Y.test(d.contains) ?
            function(e, t) {
                var n = 9 === e.nodeType ? e.documentElement: e,
                r = t && t.parentNode;
                return e === r || !!r && 1 === r.nodeType && !!(n.contains ? n.contains(r) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(r))
            }: function(e, t) {
                if (t) while (t = t.parentNode) if (t === e) return ! 0;
                return ! 1
            },
            k = t ?
            function(e, t) {
                if (e === t) return c = !0,
                0;
                var r = !e.compareDocumentPosition - !t.compareDocumentPosition;
                return r ? r: (r = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : 1, 1 & r || !n.sortDetached && t.compareDocumentPosition(e) === r ? e === o || e.ownerDocument === E && b(E, e) ? -1 : t === o || t.ownerDocument === E && b(E, t) ? 1 : l ? H(l, e) - H(l, t) : 0 : 4 & r ? -1 : 1)
            }: function(e, t) {
                if (e === t) return c = !0,
                0;
                var n, r = 0,
                i = e.parentNode,
                s = t.parentNode,
                u = [e],
                a = [t];
                if (!i || !s) return e === o ? -1 : t === o ? 1 : i ? -1 : s ? 1 : l ? H(l, e) - H(l, t) : 0;
                if (i === s) return ct(e, t);
                n = e;
                while (n = n.parentNode) u.unshift(n);
                n = t;
                while (n = n.parentNode) a.unshift(n);
                while (u[r] === a[r]) r++;
                return r ? ct(u[r], a[r]) : u[r] === E ? -1 : a[r] === E ? 1 : 0
            },
            o) : p
        },
        ot.matches = function(e, t) {
            return ot(e, null, null, t)
        },
        ot.matchesSelector = function(e, t) {
            if ((e.ownerDocument || e) !== p && h(e), t = t.replace(V, "='$1']"), !(!n.matchesSelector || !v || g && g.test(t) || m && m.test(t))) try {
                var r = y.call(e, t);
                if (r || n.disconnectedMatch || e.document && 11 !== e.document.nodeType) return r
            } catch(i) {}
            return ot(t, p, null, [e]).length > 0
        },
        ot.contains = function(e, t) {
            return (e.ownerDocument || e) !== p && h(e),
            b(e, t)
        },
        ot.attr = function(e, t) { (e.ownerDocument || e) !== p && h(e);
            var i = r.attrHandle[t.toLowerCase()],
            s = i && A.call(r.attrHandle, t.toLowerCase()) ? i(e, t, !v) : void 0;
            return void 0 !== s ? s: n.attributes || !v ? e.getAttribute(t) : (s = e.getAttributeNode(t)) && s.specified ? s.value: null
        },
        ot.error = function(e) {
            throw new Error("Syntax error, unrecognized expression: " + e)
        },
        ot.uniqueSort = function(e) {
            var t, r = [],
            i = 0,
            s = 0;
            if (c = !n.detectDuplicates, l = !n.sortStable && e.slice(0), e.sort(k), c) {
                while (t = e[s++]) t === e[s] && (i = r.push(s));
                while (i--) e.splice(r[i], 1)
            }
            return l = null,
            e
        },
        i = ot.getText = function(e) {
            var t, n = "",
            r = 0,
            s = e.nodeType;
            if (s) {
                if (1 === s || 9 === s || 11 === s) {
                    if ("string" == typeof e.textContent) return e.textContent;
                    for (e = e.firstChild; e; e = e.nextSibling) n += i(e)
                } else if (3 === s || 4 === s) return e.nodeValue
            } else while (t = e[r++]) n += i(t);
            return n
        },
        r = ot.selectors = {
            cacheLength: 50,
            createPseudo: at,
            match: K,
            attrHandle: {},
            find: {},
            relative: {
                ">": {
                    dir: "parentNode",
                    first: !0
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: !0
                },
                "~": {
                    dir: "previousSibling"
                }
            },
            preFilter: {
                ATTR: function(e) {
                    return e[1] = e[1].replace(nt, rt),
                    e[3] = (e[3] || e[4] || e[5] || "").replace(nt, rt),
                    "~=" === e[2] && (e[3] = " " + e[3] + " "),
                    e.slice(0, 4)
                },
                CHILD: function(e) {
                    return e[1] = e[1].toLowerCase(),
                    "nth" === e[1].slice(0, 3) ? (e[3] || ot.error(e[0]), e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3])), e[5] = +(e[7] + e[8] || "odd" === e[3])) : e[3] && ot.error(e[0]),
                    e
                },
                PSEUDO: function(e) {
                    var t, n = !e[6] && e[2];
                    return K.CHILD.test(e[0]) ? null: (e[3] ? e[2] = e[4] || e[5] || "": n && $.test(n) && (t = o(n, !0)) && (t = n.indexOf(")", n.length - t) - n.length) && (e[0] = e[0].slice(0, t), e[2] = n.slice(0, t)), e.slice(0, 3))
                }
            },
            filter: {
                TAG: function(e) {
                    var t = e.replace(nt, rt).toLowerCase();
                    return "*" === e ?
                    function() {
                        return ! 0
                    }: function(e) {
                        return e.nodeName && e.nodeName.toLowerCase() === t
                    }
                },
                CLASS: function(e) {
                    var t = T[e + " "];
                    return t || (t = new RegExp("(^|" + j + ")" + e + "(" + j + "|$)")) && T(e,
                    function(e) {
                        return t.test("string" == typeof e.className && e.className || "undefined" != typeof e.getAttribute && e.getAttribute("class") || "")
                    })
                },
                ATTR: function(e, t, n) {
                    return function(r) {
                        var i = ot.attr(r, e);
                        return null == i ? "!=" === t: t ? (i += "", "=" === t ? i === n: "!=" === t ? i !== n: "^=" === t ? n && 0 === i.indexOf(n) : "*=" === t ? n && i.indexOf(n) > -1 : "$=" === t ? n && i.slice( - n.length) === n: "~=" === t ? (" " + i.replace(U, " ") + " ").indexOf(n) > -1 : "|=" === t ? i === n || i.slice(0, n.length + 1) === n + "-": !1) : !0
                    }
                },
                CHILD: function(e, t, n, r, i) {
                    var s = "nth" !== e.slice(0, 3),
                    o = "last" !== e.slice( - 4),
                    u = "of-type" === t;
                    return 1 === r && 0 === i ?
                    function(e) {
                        return !! e.parentNode
                    }: function(t, n, a) {
                        var f, l, c, h, p, d, v = s !== o ? "nextSibling": "previousSibling",
                        m = t.parentNode,
                        g = u && t.nodeName.toLowerCase(),
                        y = !a && !u;
                        if (m) {
                            if (s) {
                                while (v) {
                                    c = t;
                                    while (c = c[v]) if (u ? c.nodeName.toLowerCase() === g: 1 === c.nodeType) return ! 1;
                                    d = v = "only" === e && !d && "nextSibling"
                                }
                                return ! 0
                            }
                            if (d = [o ? m.firstChild: m.lastChild], o && y) {
                                l = m[w] || (m[w] = {}),
                                f = l[e] || [],
                                p = f[0] === S && f[1],
                                h = f[0] === S && f[2],
                                c = p && m.childNodes[p];
                                while (c = ++p && c && c[v] || (h = p = 0) || d.pop()) if (1 === c.nodeType && ++h && c === t) {
                                    l[e] = [S, p, h];
                                    break
                                }
                            } else if (y && (f = (t[w] || (t[w] = {}))[e]) && f[0] === S) h = f[1];
                            else while (c = ++p && c && c[v] || (h = p = 0) || d.pop()) if ((u ? c.nodeName.toLowerCase() === g: 1 === c.nodeType) && ++h && (y && ((c[w] || (c[w] = {}))[e] = [S, h]), c === t)) break;
                            return h -= i,
                            h === r || h % r === 0 && h / r >= 0
                        }
                    }
                },
                PSEUDO: function(e, t) {
                    var n, i = r.pseudos[e] || r.setFilters[e.toLowerCase()] || ot.error("unsupported pseudo: " + e);
                    return i[w] ? i(t) : i.length > 1 ? (n = [e, e, "", t], r.setFilters.hasOwnProperty(e.toLowerCase()) ? at(function(e, n) {
                        var r, s = i(e, t),
                        o = s.length;
                        while (o--) r = H(e, s[o]),
                        e[r] = !(n[r] = s[o])
                    }) : function(e) {
                        return i(e, 0, n)
                    }) : i
                }
            },
            pseudos: {
                not: at(function(e) {
                    var t = [],
                    n = [],
                    r = u(e.replace(z, "$1"));
                    return r[w] ? at(function(e, t, n, i) {
                        var s, o = r(e, null, i, []),
                        u = e.length;
                        while (u--)(s = o[u]) && (e[u] = !(t[u] = s))
                    }) : function(e, i, s) {
                        return t[0] = e,
                        r(t, null, s, n),
                        t[0] = null,
                        !n.pop()
                    }
                }),
                has: at(function(e) {
                    return function(t) {
                        return ot(e, t).length > 0
                    }
                }),
                contains: at(function(e) {
                    return e = e.replace(nt, rt),
                    function(t) {
                        return (t.textContent || t.innerText || i(t)).indexOf(e) > -1
                    }
                }),
                lang: at(function(e) {
                    return J.test(e || "") || ot.error("unsupported lang: " + e),
                    e = e.replace(nt, rt).toLowerCase(),
                    function(t) {
                        var n;
                        do
                        if (n = v ? t.lang: t.getAttribute("xml:lang") || t.getAttribute("lang")) return n = n.toLowerCase(),
                        n === e || 0 === n.indexOf(e + "-");
                        while ((t = t.parentNode) && 1 === t.nodeType);
                        return ! 1
                    }
                }),
                target: function(t) {
                    var n = e.location && e.location.hash;
                    return n && n.slice(1) === t.id
                },
                root: function(e) {
                    return e === d
                },
                focus: function(e) {
                    return e === p.activeElement && (!p.hasFocus || p.hasFocus()) && !!(e.type || e.href || ~e.tabIndex)
                },
                enabled: function(e) {
                    return e.disabled === !1
                },
                disabled: function(e) {
                    return e.disabled === !0
                },
                checked: function(e) {
                    var t = e.nodeName.toLowerCase();
                    return "input" === t && !!e.checked || "option" === t && !!e.selected
                },
                selected: function(e) {
                    return e.parentNode && e.parentNode.selectedIndex,
                    e.selected === !0
                },
                empty: function(e) {
                    for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return ! 1;
                    return ! 0
                },
                parent: function(e) {
                    return ! r.pseudos.empty(e)
                },
                header: function(e) {
                    return G.test(e.nodeName)
                },
                input: function(e) {
                    return Q.test(e.nodeName)
                },
                button: function(e) {
                    var t = e.nodeName.toLowerCase();
                    return "input" === t && "button" === e.type || "button" === t
                },
                text: function(e) {
                    var t;
                    return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase())
                },
                first: dt(function() {
                    return [0]
                }),
                last: dt(function(e, t) {
                    return [t - 1]
                }),
                eq: dt(function(e, t, n) {
                    return [0 > n ? n + t: n]
                }),
                even: dt(function(e, t) {
                    for (var n = 0; t > n; n += 2) e.push(n);
                    return e
                }),
                odd: dt(function(e, t) {
                    for (var n = 1; t > n; n += 2) e.push(n);
                    return e
                }),
                lt: dt(function(e, t, n) {
                    for (var r = 0 > n ? n + t: n; --r >= 0;) e.push(r);
                    return e
                }),
                gt: dt(function(e, t, n) {
                    for (var r = 0 > n ? n + t: n; ++r < t;) e.push(r);
                    return e
                })
            }
        },
        r.pseudos.nth = r.pseudos.eq;
        for (t in {
            radio: !0,
            checkbox: !0,
            file: !0,
            password: !0,
            image: !0
        }) r.pseudos[t] = ht(t);
        for (t in {
            submit: !0,
            reset: !0
        }) r.pseudos[t] = pt(t);
        return mt.prototype = r.filters = r.pseudos,
        r.setFilters = new mt,
        o = ot.tokenize = function(e, t) {
            var n, i, s, o, u, a, f, l = N[e + " "];
            if (l) return t ? 0 : l.slice(0);
            u = e,
            a = [],
            f = r.preFilter;
            while (u) { (!n || (i = W.exec(u))) && (i && (u = u.slice(i[0].length) || u), a.push(s = [])),
                n = !1,
                (i = X.exec(u)) && (n = i.shift(), s.push({
                    value: n,
                    type: i[0].replace(z, " ")
                }), u = u.slice(n.length));
                for (o in r.filter) ! (i = K[o].exec(u)) || f[o] && !(i = f[o](i)) || (n = i.shift(), s.push({
                    value: n,
                    type: o,
                    matches: i
                }), u = u.slice(n.length));
                if (!n) break
            }
            return t ? u.length: u ? ot.error(e) : N(e, a).slice(0)
        },
        u = ot.compile = function(e, t) {
            var n, r = [],
            i = [],
            s = C[e + " "];
            if (!s) {
                t || (t = o(e)),
                n = t.length;
                while (n--) s = xt(t[n]),
                s[w] ? r.push(s) : i.push(s);
                s = C(e, Tt(i, r)),
                s.selector = e
            }
            return s
        },
        a = ot.select = function(e, t, i, s) {
            var a, f, l, c, h, p = "function" == typeof e && e,
            d = !s && o(e = p.selector || e);
            if (i = i || [], 1 === d.length) {
                if (f = d[0] = d[0].slice(0), f.length > 2 && "ID" === (l = f[0]).type && n.getById && 9 === t.nodeType && v && r.relative[f[1].type]) {
                    if (t = (r.find.ID(l.matches[0].replace(nt, rt), t) || [])[0], !t) return i;
                    p && (t = t.parentNode),
                    e = e.slice(f.shift().value.length)
                }
                a = K.needsContext.test(e) ? 0 : f.length;
                while (a--) {
                    if (l = f[a], r.relative[c = l.type]) break;
                    if ((h = r.find[c]) && (s = h(l.matches[0].replace(nt, rt), et.test(f[0].type) && vt(t.parentNode) || t))) {
                        if (f.splice(a, 1), e = s.length && gt(f), !e) return D.apply(i, s),
                        i;
                        break
                    }
                }
            }
            return (p || u(e, d))(s, t, !v, i, et.test(e) && vt(t.parentNode) || t),
            i
        },
        n.sortStable = w.split("").sort(k).join("") === w,
        n.detectDuplicates = !!c,
        h(),
        n.sortDetached = ft(function(e) {
            return 1 & e.compareDocumentPosition(p.createElement("div"))
        }),
        ft(function(e) {
            return e.innerHTML = "<a href='#'></a>",
            "#" === e.firstChild.getAttribute("href")
        }) || lt("type|href|height|width",
        function(e, t, n) {
            return n ? void 0 : e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2)
        }),
        n.attributes && ft(function(e) {
            return e.innerHTML = "<input/>",
            e.firstChild.setAttribute("value", ""),
            "" === e.firstChild.getAttribute("value")
        }) || lt("value",
        function(e, t, n) {
            return n || "input" !== e.nodeName.toLowerCase() ? void 0 : e.defaultValue
        }),
        ft(function(e) {
            return null == e.getAttribute("disabled")
        }) || lt(B,
        function(e, t, n) {
            var r;
            return n ? void 0 : e[t] === !0 ? t.toLowerCase() : (r = e.getAttributeNode(t)) && r.specified ? r.value: null
        }),
        ot
    } (a);
    n.find = t,
    n.expr = t.selectors,
    n.expr[":"] = n.expr.pseudos,
    n.unique = t.uniqueSort,
    n.text = t.getText,
    n.isXMLDoc = t.isXML,
    n.contains = t.contains;
    var u = n.expr.match.needsContext,
    v = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
    w = /^.[^:#\[\.,]*$/;
    n.filter = function(e, t, r) {
        var i = t[0];
        return r && (e = ":not(" + e + ")"),
        1 === t.length && 1 === i.nodeType ? n.find.matchesSelector(i, e) ? [i] : [] : n.find.matches(e, n.grep(t,
        function(e) {
            return 1 === e.nodeType
        }))
    },
    n.fn.extend({
        find: function(e) {
            var t, r = this.length,
            i = [],
            s = this;
            if ("string" != typeof e) return this.pushStack(n(e).filter(function() {
                for (t = 0; r > t; t++) if (n.contains(s[t], this)) return ! 0
            }));
            for (t = 0; r > t; t++) n.find(e, s[t], i);
            return i = this.pushStack(r > 1 ? n.unique(i) : i),
            i.selector = this.selector ? this.selector + " " + e: e,
            i
        },
        filter: function(e) {
            return this.pushStack(x(this, e || [], !1))
        },
        not: function(e) {
            return this.pushStack(x(this, e || [], !0))
        },
        is: function(e) {
            return !! x(this, "string" == typeof e && u.test(e) ? n(e) : e || [], !1).length
        }
    });
    var y, z = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    A = n.fn.init = function(e, t) {
        var r, i;
        if (!e) return this;
        if ("string" == typeof e) {
            if (r = "<" === e[0] && ">" === e[e.length - 1] && e.length >= 3 ? [null, e, null] : z.exec(e), !r || !r[1] && t) return ! t || t.jquery ? (t || y).find(e) : this.constructor(t).find(e);
            if (r[1]) {
                if (t = t instanceof n ? t[0] : t, n.merge(this, n.parseHTML(r[1], t && t.nodeType ? t.ownerDocument || t: l, !0)), v.test(r[1]) && n.isPlainObject(t)) for (r in t) n.isFunction(this[r]) ? this[r](t[r]) : this.attr(r, t[r]);
                return this
            }
            return i = l.getElementById(r[2]),
            i && i.parentNode && (this.length = 1, this[0] = i),
            this.context = l,
            this.selector = e,
            this
        }
        return e.nodeType ? (this.context = this[0] = e, this.length = 1, this) : n.isFunction(e) ? "undefined" != typeof y.ready ? y.ready(e) : e(n) : (void 0 !== e.selector && (this.selector = e.selector, this.context = e.context), n.makeArray(e, this))
    };
    A.prototype = n.fn,
    y = n(l);
    var B = /^(?:parents|prev(?:Until|All))/,
    C = {
        children: !0,
        contents: !0,
        next: !0,
        prev: !0
    };
    n.extend({
        dir: function(e, t, r) {
            var i = [],
            s = void 0 !== r;
            while ((e = e[t]) && 9 !== e.nodeType) if (1 === e.nodeType) {
                if (s && n(e).is(r)) break;
                i.push(e)
            }
            return i
        },
        sibling: function(e, t) {
            for (var n = []; e; e = e.nextSibling) 1 === e.nodeType && e !== t && n.push(e);
            return n
        }
    }),
    n.fn.extend({
        has: function(e) {
            var t = n(e, this),
            r = t.length;
            return this.filter(function() {
                for (var e = 0; r > e; e++) if (n.contains(this, t[e])) return ! 0
            })
        },
        closest: function(e, t) {
            for (var r, i = 0,
            s = this.length,
            o = [], a = u.test(e) || "string" != typeof e ? n(e, t || this.context) : 0; s > i; i++) for (r = this[i]; r && r !== t; r = r.parentNode) if (r.nodeType < 11 && (a ? a.index(r) > -1 : 1 === r.nodeType && n.find.matchesSelector(r, e))) {
                o.push(r);
                break
            }
            return this.pushStack(o.length > 1 ? n.unique(o) : o)
        },
        index: function(e) {
            return e ? "string" == typeof e ? g.call(n(e), this[0]) : g.call(this, e.jquery ? e[0] : e) : this[0] && this[0].parentNode ? this.first().prevAll().length: -1
        },
        add: function(e, t) {
            return this.pushStack(n.unique(n.merge(this.get(), n(e, t))))
        },
        addBack: function(e) {
            return this.add(null == e ? this.prevObject: this.prevObject.filter(e))
        }
    }),
    n.each({
        parent: function(e) {
            var t = e.parentNode;
            return t && 11 !== t.nodeType ? t: null
        },
        parents: function(e) {
            return n.dir(e, "parentNode")
        },
        parentsUntil: function(e, t, r) {
            return n.dir(e, "parentNode", r)
        },
        next: function(e) {
            return D(e, "nextSibling")
        },
        prev: function(e) {
            return D(e, "previousSibling")
        },
        nextAll: function(e) {
            return n.dir(e, "nextSibling")
        },
        prevAll: function(e) {
            return n.dir(e, "previousSibling")
        },
        nextUntil: function(e, t, r) {
            return n.dir(e, "nextSibling", r)
        },
        prevUntil: function(e, t, r) {
            return n.dir(e, "previousSibling", r)
        },
        siblings: function(e) {
            return n.sibling((e.parentNode || {}).firstChild, e)
        },
        children: function(e) {
            return n.sibling(e.firstChild)
        },
        contents: function(e) {
            return e.contentDocument || n.merge([], e.childNodes)
        }
    },
    function(e, t) {
        n.fn[e] = function(r, i) {
            var s = n.map(this, t, r);
            return "Until" !== e.slice( - 5) && (i = r),
            i && "string" == typeof i && (s = n.filter(i, s)),
            this.length > 1 && (C[e] || n.unique(s), B.test(e) && s.reverse()),
            this.pushStack(s)
        }
    });
    var E = /\S+/g,
    F = {};
    n.Callbacks = function(e) {
        e = "string" == typeof e ? F[e] || G(e) : n.extend({},
        e);
        var t, r, i, s, o, u, a = [],
        f = !e.once && [],
        l = function(n) {
            for (t = e.memory && n, r = !0, u = s || 0, s = 0, o = a.length, i = !0; a && o > u; u++) if (a[u].apply(n[0], n[1]) === !1 && e.stopOnFalse) {
                t = !1;
                break
            }
            i = !1,
            a && (f ? f.length && l(f.shift()) : t ? a = [] : c.disable())
        },
        c = {
            add: function() {
                if (a) {
                    var r = a.length; !
                    function u(t) {
                        n.each(t,
                        function(t, r) {
                            var i = n.type(r);
                            "function" === i ? e.unique && c.has(r) || a.push(r) : r && r.length && "string" !== i && u(r)
                        })
                    } (arguments),
                    i ? o = a.length: t && (s = r, l(t))
                }
                return this
            },
            remove: function() {
                return a && n.each(arguments,
                function(e, t) {
                    var r;
                    while ((r = n.inArray(t, a, r)) > -1) a.splice(r, 1),
                    i && (o >= r && o--, u >= r && u--)
                }),
                this
            },
            has: function(e) {
                return e ? n.inArray(e, a) > -1 : !!a && !!a.length
            },
            empty: function() {
                return a = [],
                o = 0,
                this
            },
            disable: function() {
                return a = f = t = void 0,
                this
            },
            disabled: function() {
                return ! a
            },
            lock: function() {
                return f = void 0,
                t || c.disable(),
                this
            },
            locked: function() {
                return ! f
            },
            fireWith: function(e, t) {
                return ! a || r && !f || (t = t || [], t = [e, t.slice ? t.slice() : t], i ? f.push(t) : l(t)),
                this
            },
            fire: function() {
                return c.fireWith(this, arguments),
                this
            },
            fired: function() {
                return !! r
            }
        };
        return c
    },
    n.extend({
        Deferred: function(e) {
            var t = [["resolve", "done", n.Callbacks("once memory"), "resolved"], ["reject", "fail", n.Callbacks("once memory"), "rejected"], ["notify", "progress", n.Callbacks("memory")]],
            r = "pending",
            i = {
                state: function() {
                    return r
                },
                always: function() {
                    return s.done(arguments).fail(arguments),
                    this
                },
                then: function() {
                    var e = arguments;
                    return n.Deferred(function(r) {
                        n.each(t,
                        function(t, o) {
                            var u = n.isFunction(e[t]) && e[t];
                            s[o[1]](function() {
                                var e = u && u.apply(this, arguments);
                                e && n.isFunction(e.promise) ? e.promise().done(r.resolve).fail(r.reject).progress(r.notify) : r[o[0] + "With"](this === i ? r.promise() : this, u ? [e] : arguments)
                            })
                        }),
                        e = null
                    }).promise()
                },
                promise: function(e) {
                    return null != e ? n.extend(e, i) : i
                }
            },
            s = {};
            return i.pipe = i.then,
            n.each(t,
            function(e, n) {
                var o = n[2],
                u = n[3];
                i[n[1]] = o.add,
                u && o.add(function() {
                    r = u
                },
                t[1 ^ e][2].disable, t[2][2].lock),
                s[n[0]] = function() {
                    return s[n[0] + "With"](this === s ? i: this, arguments),
                    this
                },
                s[n[0] + "With"] = o.fireWith
            }),
            i.promise(s),
            e && e.call(s, s),
            s
        },
        when: function(e) {
            var t = 0,
            r = d.call(arguments),
            i = r.length,
            s = 1 !== i || e && n.isFunction(e.promise) ? i: 0,
            o = 1 === s ? e: n.Deferred(),
            u = function(e, t, n) {
                return function(r) {
                    t[e] = this,
                    n[e] = arguments.length > 1 ? d.call(arguments) : r,
                    n === a ? o.notifyWith(t, n) : --s || o.resolveWith(t, n)
                }
            },
            a,
            f,
            l;
            if (i > 1) for (a = new Array(i), f = new Array(i), l = new Array(i); i > t; t++) r[t] && n.isFunction(r[t].promise) ? r[t].promise().done(u(t, l, r)).fail(o.reject).progress(u(t, f, a)) : --s;
            return s || o.resolveWith(l, r),
            o.promise()
        }
    });
    var H;
    n.fn.ready = function(e) {
        return n.ready.promise().done(e),
        this
    },
    n.extend({
        isReady: !1,
        readyWait: 1,
        holdReady: function(e) {
            e ? n.readyWait++:n.ready(!0)
        },
        ready: function(e) { (e === !0 ? --n.readyWait: n.isReady) || (n.isReady = !0, e !== !0 && --n.readyWait > 0 || (H.resolveWith(l, [n]), n.fn.triggerHandler && (n(l).triggerHandler("ready"), n(l).off("ready"))))
        }
    }),
    n.ready.promise = function(e) {
        return H || (H = n.Deferred(), "complete" === l.readyState ? setTimeout(n.ready) : (l.addEventListener("DOMContentLoaded", I, !1), a.addEventListener("load", I, !1))),
        H.promise(e)
    },
    n.ready.promise();
    var J = n.access = function(e, t, r, i, s, o, u) {
        var a = 0,
        f = e.length,
        l = null == r;
        if ("object" === n.type(r)) {
            s = !0;
            for (a in r) n.access(e, t, a, r[a], !0, o, u)
        } else if (void 0 !== i && (s = !0, n.isFunction(i) || (u = !0), l && (u ? (t.call(e, i), t = null) : (l = t, t = function(e, t, r) {
            return l.call(n(e), r)
        })), t)) for (; f > a; a++) t(e[a], r, u ? i: i.call(e[a], a, t(e[a], r)));
        return s ? e: l ? t.call(e) : f ? t(e[0], r) : o
    };
    n.acceptData = function(e) {
        return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType
    },
    K.uid = 1,
    K.accepts = n.acceptData,
    K.prototype = {
        key: function(e) {
            if (!K.accepts(e)) return 0;
            var t = {},
            r = e[this.expando];
            if (!r) {
                r = K.uid++;
                try {
                    t[this.expando] = {
                        value: r
                    },
                    Object.defineProperties(e, t)
                } catch(i) {
                    t[this.expando] = r,
                    n.extend(e, t)
                }
            }
            return this.cache[r] || (this.cache[r] = {}),
            r
        },
        set: function(e, t, r) {
            var i, s = this.key(e),
            o = this.cache[s];
            if ("string" == typeof t) o[t] = r;
            else if (n.isEmptyObject(o)) n.extend(this.cache[s], t);
            else for (i in t) o[i] = t[i];
            return o
        },
        get: function(e, t) {
            var n = this.cache[this.key(e)];
            return void 0 === t ? n: n[t]
        },
        access: function(e, t, r) {
            var i;
            return void 0 === t || t && "string" == typeof t && void 0 === r ? (i = this.get(e, t), void 0 !== i ? i: this.get(e, n.camelCase(t))) : (this.set(e, t, r), void 0 !== r ? r: t)
        },
        remove: function(e, t) {
            var r, i, s, o = this.key(e),
            u = this.cache[o];
            if (void 0 === t) this.cache[o] = {};
            else {
                n.isArray(t) ? i = t.concat(t.map(n.camelCase)) : (s = n.camelCase(t), t in u ? i = [t, s] : (i = s, i = i in u ? [i] : i.match(E) || [])),
                r = i.length;
                while (r--) delete u[i[r]]
            }
        },
        hasData: function(e) {
            return ! n.isEmptyObject(this.cache[e[this.expando]] || {})
        },
        discard: function(e) {
            e[this.expando] && delete this.cache[e[this.expando]]
        }
    };
    var L = new K,
    M = new K,
    N = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
    O = /([A-Z])/g;
    n.extend({
        hasData: function(e) {
            return M.hasData(e) || L.hasData(e)
        },
        data: function(e, t, n) {
            return M.access(e, t, n)
        },
        removeData: function(e, t) {
            M.remove(e, t)
        },
        _data: function(e, t, n) {
            return L.access(e, t, n)
        },
        _removeData: function(e, t) {
            L.remove(e, t)
        }
    }),
    n.fn.extend({
        data: function(e, t) {
            var r, i, s, o = this[0],
            u = o && o.attributes;
            if (void 0 === e) {
                if (this.length && (s = M.get(o), 1 === o.nodeType && !L.get(o, "hasDataAttrs"))) {
                    r = u.length;
                    while (r--) u[r] && (i = u[r].name, 0 === i.indexOf("data-") && (i = n.camelCase(i.slice(5)), P(o, i, s[i])));
                    L.set(o, "hasDataAttrs", !0)
                }
                return s
            }
            return "object" == typeof e ? this.each(function() {
                M.set(this, e)
            }) : J(this,
            function(t) {
                var r, i = n.camelCase(e);
                if (o && void 0 === t) {
                    if (r = M.get(o, e), void 0 !== r) return r;
                    if (r = M.get(o, i), void 0 !== r) return r;
                    if (r = P(o, i, void 0), void 0 !== r) return r
                } else this.each(function() {
                    var n = M.get(this, i);
                    M.set(this, i, t),
                    -1 !== e.indexOf("-") && void 0 !== n && M.set(this, e, t)
                })
            },
            null, t, arguments.length > 1, null, !0)
        },
        removeData: function(e) {
            return this.each(function() {
                M.remove(this, e)
            })
        }
    }),
    n.extend({
        queue: function(e, t, r) {
            var i;
            return e ? (t = (t || "fx") + "queue", i = L.get(e, t), r && (!i || n.isArray(r) ? i = L.access(e, t, n.makeArray(r)) : i.push(r)), i || []) : void 0
        },
        dequeue: function(e, t) {
            t = t || "fx";
            var r = n.queue(e, t),
            i = r.length,
            s = r.shift(),
            o = n._queueHooks(e, t),
            u = function() {
                n.dequeue(e, t)
            };
            "inprogress" === s && (s = r.shift(), i--),
            s && ("fx" === t && r.unshift("inprogress"), delete o.stop, s.call(e, u, o)),
            !i && o && o.empty.fire()
        },
        _queueHooks: function(e, t) {
            var r = t + "queueHooks";
            return L.get(e, r) || L.access(e, r, {
                empty: n.Callbacks("once memory").add(function() {
                    L.remove(e, [t + "queue", r])
                })
            })
        }
    }),
    n.fn.extend({
        queue: function(e, t) {
            var r = 2;
            return "string" != typeof e && (t = e, e = "fx", r--),
            arguments.length < r ? n.queue(this[0], e) : void 0 === t ? this: this.each(function() {
                var r = n.queue(this, e, t);
                n._queueHooks(this, e),
                "fx" === e && "inprogress" !== r[0] && n.dequeue(this, e)
            })
        },
        dequeue: function(e) {
            return this.each(function() {
                n.dequeue(this, e)
            })
        },
        clearQueue: function(e) {
            return this.queue(e || "fx", [])
        },
        promise: function(e, t) {
            var r, i = 1,
            s = n.Deferred(),
            o = this,
            u = this.length,
            a = function() {--i || s.resolveWith(o, [o])
            };
            "string" != typeof e && (t = e, e = void 0),
            e = e || "fx";
            while (u--) r = L.get(o[u], e + "queueHooks"),
            r && r.empty && (i++, r.empty.add(a));
            return a(),
            s.promise(t)
        }
    });
    var Q = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
    R = ["Top", "Right", "Bottom", "Left"],
    S = function(e, t) {
        return e = t || e,
        "none" === n.css(e, "display") || !n.contains(e.ownerDocument, e)
    },
    T = /^(?:checkbox|radio)$/i; !
    function() {
        var e = l.createDocumentFragment(),
        t = e.appendChild(l.createElement("div")),
        n = l.createElement("input");
        n.setAttribute("type", "radio"),
        n.setAttribute("checked", "checked"),
        n.setAttribute("name", "t"),
        t.appendChild(n),
        k.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked,
        t.innerHTML = "<textarea>x</textarea>",
        k.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue
    } ();
    var U = "undefined";
    k.focusinBubbles = "onfocusin" in a;
    var V = /^key/,
    W = /^(?:mouse|pointer|contextmenu)|click/,
    X = /^(?:focusinfocus|focusoutblur)$/,
    Y = /^([^.]*)(?:\.(.+)|)$/;
    n.event = {
        global: {},
        add: function(e, t, r, i, s) {
            var o, u, a, f, l, c, h, p, d, v, m, g = L.get(e);
            if (g) {
                r.handler && (o = r, r = o.handler, s = o.selector),
                r.guid || (r.guid = n.guid++),
                (f = g.events) || (f = g.events = {}),
                (u = g.handle) || (u = g.handle = function(t) {
                    return typeof n !== U && n.event.triggered !== t.type ? n.event.dispatch.apply(e, arguments) : void 0
                }),
                t = (t || "").match(E) || [""],
                l = t.length;
                while (l--) a = Y.exec(t[l]) || [],
                d = m = a[1],
                v = (a[2] || "").split(".").sort(),
                d && (h = n.event.special[d] || {},
                d = (s ? h.delegateType: h.bindType) || d, h = n.event.special[d] || {},
                c = n.extend({
                    type: d,
                    origType: m,
                    data: i,
                    handler: r,
                    guid: r.guid,
                    selector: s,
                    needsContext: s && n.expr.match.needsContext.test(s),
                    namespace: v.join(".")
                },
                o), (p = f[d]) || (p = f[d] = [], p.delegateCount = 0, h.setup && h.setup.call(e, i, v, u) !== !1 || e.addEventListener && e.addEventListener(d, u, !1)), h.add && (h.add.call(e, c), c.handler.guid || (c.handler.guid = r.guid)), s ? p.splice(p.delegateCount++, 0, c) : p.push(c), n.event.global[d] = !0)
            }
        },
        remove: function(e, t, r, i, s) {
            var o, u, a, f, l, c, h, p, d, v, m, g = L.hasData(e) && L.get(e);
            if (g && (f = g.events)) {
                t = (t || "").match(E) || [""],
                l = t.length;
                while (l--) if (a = Y.exec(t[l]) || [], d = m = a[1], v = (a[2] || "").split(".").sort(), d) {
                    h = n.event.special[d] || {},
                    d = (i ? h.delegateType: h.bindType) || d,
                    p = f[d] || [],
                    a = a[2] && new RegExp("(^|\\.)" + v.join("\\.(?:.*\\.|)") + "(\\.|$)"),
                    u = o = p.length;
                    while (o--) c = p[o],
                    !s && m !== c.origType || r && r.guid !== c.guid || a && !a.test(c.namespace) || i && i !== c.selector && ("**" !== i || !c.selector) || (p.splice(o, 1), c.selector && p.delegateCount--, h.remove && h.remove.call(e, c));
                    u && !p.length && (h.teardown && h.teardown.call(e, v, g.handle) !== !1 || n.removeEvent(e, d, g.handle), delete f[d])
                } else for (d in f) n.event.remove(e, d + t[l], r, i, !0);
                n.isEmptyObject(f) && (delete g.handle, L.remove(e, "events"))
            }
        },
        trigger: function(e, t, r, i) {
            var s, o, u, f, c, h, p, d = [r || l],
            v = j.call(e, "type") ? e.type: e,
            m = j.call(e, "namespace") ? e.namespace.split(".") : [];
            if (o = u = r = r || l, 3 !== r.nodeType && 8 !== r.nodeType && !X.test(v + n.event.triggered) && (v.indexOf(".") >= 0 && (m = v.split("."), v = m.shift(), m.sort()), c = v.indexOf(":") < 0 && "on" + v, e = e[n.expando] ? e: new n.Event(v, "object" == typeof e && e), e.isTrigger = i ? 2 : 3, e.namespace = m.join("."), e.namespace_re = e.namespace ? new RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = r), t = null == t ? [e] : n.makeArray(t, [e]), p = n.event.special[v] || {},
            i || !p.trigger || p.trigger.apply(r, t) !== !1)) {
                if (!i && !p.noBubble && !n.isWindow(r)) {
                    for (f = p.delegateType || v, X.test(f + v) || (o = o.parentNode); o; o = o.parentNode) d.push(o),
                    u = o;
                    u === (r.ownerDocument || l) && d.push(u.defaultView || u.parentWindow || a)
                }
                s = 0;
                while ((o = d[s++]) && !e.isPropagationStopped()) e.type = s > 1 ? f: p.bindType || v,
                h = (L.get(o, "events") || {})[e.type] && L.get(o, "handle"),
                h && h.apply(o, t),
                h = c && o[c],
                h && h.apply && n.acceptData(o) && (e.result = h.apply(o, t), e.result === !1 && e.preventDefault());
                return e.type = v,
                i || e.isDefaultPrevented() || p._default && p._default.apply(d.pop(), t) !== !1 || !n.acceptData(r) || c && n.isFunction(r[v]) && !n.isWindow(r) && (u = r[c], u && (r[c] = null), n.event.triggered = v, r[v](), n.event.triggered = void 0, u && (r[c] = u)),
                e.result
            }
        },
        dispatch: function(e) {
            e = n.event.fix(e);
            var t, r, i, s, o, u = [],
            a = d.call(arguments),
            f = (L.get(this, "events") || {})[e.type] || [],
            l = n.event.special[e.type] || {};
            if (a[0] = e, e.delegateTarget = this, !l.preDispatch || l.preDispatch.call(this, e) !== !1) {
                u = n.event.handlers.call(this, e, f),
                t = 0;
                while ((s = u[t++]) && !e.isPropagationStopped()) {
                    e.currentTarget = s.elem,
                    r = 0;
                    while ((o = s.handlers[r++]) && !e.isImmediatePropagationStopped())(!e.namespace_re || e.namespace_re.test(o.namespace)) && (e.handleObj = o, e.data = o.data, i = ((n.event.special[o.origType] || {}).handle || o.handler).apply(s.elem, a), void 0 !== i && (e.result = i) === !1 && (e.preventDefault(), e.stopPropagation()))
                }
                return l.postDispatch && l.postDispatch.call(this, e),
                e.result
            }
        },
        handlers: function(e, t) {
            var r, i, s, o, u = [],
            a = t.delegateCount,
            f = e.target;
            if (a && f.nodeType && (!e.button || "click" !== e.type)) for (; f !== this; f = f.parentNode || this) if (f.disabled !== !0 || "click" !== e.type) {
                for (i = [], r = 0; a > r; r++) o = t[r],
                s = o.selector + " ",
                void 0 === i[s] && (i[s] = o.needsContext ? n(s, this).index(f) >= 0 : n.find(s, this, null, [f]).length),
                i[s] && i.push(o);
                i.length && u.push({
                    elem: f,
                    handlers: i
                })
            }
            return a < t.length && u.push({
                elem: this,
                handlers: t.slice(a)
            }),
            u
        },
        props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),
        fixHooks: {},
        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(e, t) {
                return null == e.which && (e.which = null != t.charCode ? t.charCode: t.keyCode),
                e
            }
        },
        mouseHooks: {
            props: "button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
            filter: function(e, t) {
                var n, r, i, s = t.button;
                return null == e.pageX && null != t.clientX && (n = e.target.ownerDocument || l, r = n.documentElement, i = n.body, e.pageX = t.clientX + (r && r.scrollLeft || i && i.scrollLeft || 0) - (r && r.clientLeft || i && i.clientLeft || 0), e.pageY = t.clientY + (r && r.scrollTop || i && i.scrollTop || 0) - (r && r.clientTop || i && i.clientTop || 0)),
                e.which || void 0 === s || (e.which = 1 & s ? 1 : 2 & s ? 3 : 4 & s ? 2 : 0),
                e
            }
        },
        fix: function(e) {
            if (e[n.expando]) return e;
            var t, r, i, s = e.type,
            o = e,
            u = this.fixHooks[s];
            u || (this.fixHooks[s] = u = W.test(s) ? this.mouseHooks: V.test(s) ? this.keyHooks: {}),
            i = u.props ? this.props.concat(u.props) : this.props,
            e = new n.Event(o),
            t = i.length;
            while (t--) r = i[t],
            e[r] = o[r];
            return e.target || (e.target = l),
            3 === e.target.nodeType && (e.target = e.target.parentNode),
            u.filter ? u.filter(e, o) : e
        },
        special: {
            load: {
                noBubble: !0
            },
            focus: {
                trigger: function() {
                    return this !== _() && this.focus ? (this.focus(), !1) : void 0
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    return this === _() && this.blur ? (this.blur(), !1) : void 0
                },
                delegateType: "focusout"
            },
            click: {
                trigger: function() {
                    return "checkbox" === this.type && this.click && n.nodeName(this, "input") ? (this.click(), !1) : void 0
                },
                _default: function(e) {
                    return n.nodeName(e.target, "a")
                }
            },
            beforeunload: {
                postDispatch: function(e) {
                    void 0 !== e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)
                }
            }
        },
        simulate: function(e, t, r, i) {
            var s = n.extend(new n.Event, r, {
                type: e,
                isSimulated: !0,
                originalEvent: {}
            });
            i ? n.event.trigger(s, null, t) : n.event.dispatch.call(t, s),
            s.isDefaultPrevented() && r.preventDefault()
        }
    },
    n.removeEvent = function(e, t, n) {
        e.removeEventListener && e.removeEventListener(t, n, !1)
    },
    n.Event = function(e, t) {
        return this instanceof n.Event ? (e && e.type ? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented && e.returnValue === !1 ? Z: $) : this.type = e, t && n.extend(this, t), this.timeStamp = e && e.timeStamp || n.now(), void(this[n.expando] = !0)) : new n.Event(e, t)
    },
    n.Event.prototype = {
        isDefaultPrevented: $,
        isPropagationStopped: $,
        isImmediatePropagationStopped: $,
        preventDefault: function() {
            var e = this.originalEvent;
            this.isDefaultPrevented = Z,
            e && e.preventDefault && e.preventDefault()
        },
        stopPropagation: function() {
            var e = this.originalEvent;
            this.isPropagationStopped = Z,
            e && e.stopPropagation && e.stopPropagation()
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;
            this.isImmediatePropagationStopped = Z,
            e && e.stopImmediatePropagation && e.stopImmediatePropagation(),
            this.stopPropagation()
        }
    },
    n.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    },
    function(e, t) {
        n.event.special[e] = {
            delegateType: t,
            bindType: t,
            handle: function(e) {
                var r, i = this,
                s = e.relatedTarget,
                o = e.handleObj;
                return (!s || s !== i && !n.contains(i, s)) && (e.type = o.origType, r = o.handler.apply(this, arguments), e.type = t),
                r
            }
        }
    }),
    k.focusinBubbles || n.each({
        focus: "focusin",
        blur: "focusout"
    },
    function(e, t) {
        var r = function(e) {
            n.event.simulate(t, e.target, n.event.fix(e), !0)
        };
        n.event.special[t] = {
            setup: function() {
                var n = this.ownerDocument || this,
                i = L.access(n, t);
                i || n.addEventListener(e, r, !0),
                L.access(n, t, (i || 0) + 1)
            },
            teardown: function() {
                var n = this.ownerDocument || this,
                i = L.access(n, t) - 1;
                i ? L.access(n, t, i) : (n.removeEventListener(e, r, !0), L.remove(n, t))
            }
        }
    }),
    n.fn.extend({
        on: function(e, t, r, i, s) {
            var o, u;
            if ("object" == typeof e) {
                "string" != typeof t && (r = r || t, t = void 0);
                for (u in e) this.on(u, t, r, e[u], s);
                return this
            }
            if (null == r && null == i ? (i = t, r = t = void 0) : null == i && ("string" == typeof t ? (i = r, r = void 0) : (i = r, r = t, t = void 0)), i === !1) i = $;
            else if (!i) return this;
            return 1 === s && (o = i, i = function(e) {
                return n().off(e),
                o.apply(this, arguments)
            },
            i.guid = o.guid || (o.guid = n.guid++)),
            this.each(function() {
                n.event.add(this, e, i, r, t)
            })
        },
        one: function(e, t, n, r) {
            return this.on(e, t, n, r, 1)
        },
        off: function(e, t, r) {
            var i, s;
            if (e && e.preventDefault && e.handleObj) return i = e.handleObj,
            n(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace: i.origType, i.selector, i.handler),
            this;
            if ("object" == typeof e) {
                for (s in e) this.off(s, t, e[s]);
                return this
            }
            return (t === !1 || "function" == typeof t) && (r = t, t = void 0),
            r === !1 && (r = $),
            this.each(function() {
                n.event.remove(this, e, r, t)
            })
        },
        trigger: function(e, t) {
            return this.each(function() {
                n.event.trigger(e, t, this)
            })
        },
        triggerHandler: function(e, t) {
            var r = this[0];
            return r ? n.event.trigger(e, t, r, !0) : void 0
        }
    });
    var aa = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
    ba = /<([\w:]+)/,
    ca = /<|&#?\w+;/,
    da = /<(?:script|style|link)/i,
    ea = /checked\s*(?:[^=]|=\s*.checked.)/i,
    fa = /^$|\/(?:java|ecma)script/i,
    ga = /^true\/(.*)/,
    ha = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
    ia = {
        option: [1, "<select multiple='multiple'>", "</select>"],
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
        _default: [0, "", ""]
    };
    ia.optgroup = ia.option,
    ia.tbody = ia.tfoot = ia.colgroup = ia.caption = ia.thead,
    ia.th = ia.td,
    n.extend({
        clone: function(e, t, r) {
            var i, s, o, u, a = e.cloneNode(!0),
            f = n.contains(e.ownerDocument, e);
            if (! (k.noCloneChecked || 1 !== e.nodeType && 11 !== e.nodeType || n.isXMLDoc(e))) for (u = oa(a), o = oa(e), i = 0, s = o.length; s > i; i++) pa(o[i], u[i]);
            if (t) if (r) for (o = o || oa(e), u = u || oa(a), i = 0, s = o.length; s > i; i++) na(o[i], u[i]);
            else na(e, a);
            return u = oa(a, "script"),
            u.length > 0 && ma(u, !f && oa(e, "script")),
            a
        },
        buildFragment: function(e, t, r, i) {
            for (var s, o, u, a, f, l, c = t.createDocumentFragment(), h = [], p = 0, d = e.length; d > p; p++) if (s = e[p], s || 0 === s) if ("object" === n.type(s)) n.merge(h, s.nodeType ? [s] : s);
            else if (ca.test(s)) {
                o = o || c.appendChild(t.createElement("div")),
                u = (ba.exec(s) || ["", ""])[1].toLowerCase(),
                a = ia[u] || ia._default,
                o.innerHTML = a[1] + s.replace(aa, "<$1></$2>") + a[2],
                l = a[0];
                while (l--) o = o.lastChild;
                n.merge(h, o.childNodes),
                o = c.firstChild,
                o.textContent = ""
            } else h.push(t.createTextNode(s));
            c.textContent = "",
            p = 0;
            while (s = h[p++]) if ((!i || -1 === n.inArray(s, i)) && (f = n.contains(s.ownerDocument, s), o = oa(c.appendChild(s), "script"), f && ma(o), r)) {
                l = 0;
                while (s = o[l++]) fa.test(s.type || "") && r.push(s)
            }
            return c
        },
        cleanData: function(e) {
            for (var t, r, i, s, o = n.event.special,
            u = 0; void 0 !== (r = e[u]); u++) {
                if (n.acceptData(r) && (s = r[L.expando], s && (t = L.cache[s]))) {
                    if (t.events) for (i in t.events) o[i] ? n.event.remove(r, i) : n.removeEvent(r, i, t.handle);
                    L.cache[s] && delete L.cache[s]
                }
                delete M.cache[r[M.expando]]
            }
        }
    }),
    n.fn.extend({
        text: function(e) {
            return J(this,
            function(e) {
                return void 0 === e ? n.text(this) : this.empty().each(function() { (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = e)
                })
            },
            null, e, arguments.length)
        },
        append: function() {
            return this.domManip(arguments,
            function(e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = ja(this, e);
                    t.appendChild(e)
                }
            })
        },
        prepend: function() {
            return this.domManip(arguments,
            function(e) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var t = ja(this, e);
                    t.insertBefore(e, t.firstChild)
                }
            })
        },
        before: function() {
            return this.domManip(arguments,
            function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this)
            })
        },
        after: function() {
            return this.domManip(arguments,
            function(e) {
                this.parentNode && this.parentNode.insertBefore(e, this.nextSibling)
            })
        },
        remove: function(e, t) {
            for (var r, i = e ? n.filter(e, this) : this, s = 0; null != (r = i[s]); s++) t || 1 !== r.nodeType || n.cleanData(oa(r)),
            r.parentNode && (t && n.contains(r.ownerDocument, r) && ma(oa(r, "script")), r.parentNode.removeChild(r));
            return this
        },
        empty: function() {
            for (var e, t = 0; null != (e = this[t]); t++) 1 === e.nodeType && (n.cleanData(oa(e, !1)), e.textContent = "");
            return this
        },
        clone: function(e, t) {
            return e = null == e ? !1 : e,
            t = null == t ? e: t,
            this.map(function() {
                return n.clone(this, e, t)
            })
        },
        html: function(e) {
            return J(this,
            function(e) {
                var t = this[0] || {},
                r = 0,
                i = this.length;
                if (void 0 === e && 1 === t.nodeType) return t.innerHTML;
                if ("string" == typeof e && !da.test(e) && !ia[(ba.exec(e) || ["", ""])[1].toLowerCase()]) {
                    e = e.replace(aa, "<$1></$2>");
                    try {
                        for (; i > r; r++) t = this[r] || {},
                        1 === t.nodeType && (n.cleanData(oa(t, !1)), t.innerHTML = e);
                        t = 0
                    } catch(s) {}
                }
                t && this.empty().append(e)
            },
            null, e, arguments.length)
        },
        replaceWith: function() {
            var e = arguments[0];
            return this.domManip(arguments,
            function(t) {
                e = this.parentNode,
                n.cleanData(oa(this)),
                e && e.replaceChild(t, this)
            }),
            e && (e.length || e.nodeType) ? this: this.remove()
        },
        detach: function(e) {
            return this.remove(e, !0)
        },
        domManip: function(t, r) {
            t = e.apply([], t);
            var i, s, o, u, a, f, l = 0,
            c = this.length,
            h = this,
            p = c - 1,
            d = t[0],
            v = n.isFunction(d);
            if (v || c > 1 && "string" == typeof d && !k.checkClone && ea.test(d)) return this.each(function(e) {
                var n = h.eq(e);
                v && (t[0] = d.call(this, e, n.html())),
                n.domManip(t, r)
            });
            if (c && (i = n.buildFragment(t, this[0].ownerDocument, !1, this), s = i.firstChild, 1 === i.childNodes.length && (i = s), s)) {
                for (o = n.map(oa(i, "script"), ka), u = o.length; c > l; l++) a = i,
                l !== p && (a = n.clone(a, !0, !0), u && n.merge(o, oa(a, "script"))),
                r.call(this[l], a, l);
                if (u) for (f = o[o.length - 1].ownerDocument, n.map(o, la), l = 0; u > l; l++) a = o[l],
                fa.test(a.type || "") && !L.access(a, "globalEval") && n.contains(f, a) && (a.src ? n._evalUrl && n._evalUrl(a.src) : n.globalEval(a.textContent.replace(ha, "")))
            }
            return this
        }
    }),
    n.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    },
    function(e, t) {
        n.fn[e] = function(e) {
            for (var r, i = [], s = n(e), o = s.length - 1, u = 0; o >= u; u++) r = u === o ? this: this.clone(!0),
            n(s[u])[t](r),
            f.apply(i, r.get());
            return this.pushStack(i)
        }
    });
    var qa, ra = {},
    ua = /^margin/,
    va = new RegExp("^(" + Q + ")(?!px)[a-z%]+$", "i"),
    wa = function(e) {
        return e.ownerDocument.defaultView.opener ? e.ownerDocument.defaultView.getComputedStyle(e, null) : a.getComputedStyle(e, null)
    }; !
    function() {
        var e, t, r = l.documentElement,
        i = l.createElement("div"),
        s = l.createElement("div");
        if (s.style) {
            s.style.backgroundClip = "content-box",
            s.cloneNode(!0).style.backgroundClip = "",
            k.clearCloneStyle = "content-box" === s.style.backgroundClip,
            i.style.cssText = "border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",
            i.appendChild(s);
            function o() {
                s.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",
                s.innerHTML = "",
                r.appendChild(i);
                var n = a.getComputedStyle(s, null);
                e = "1%" !== n.top,
                t = "4px" === n.width,
                r.removeChild(i)
            }
            a.getComputedStyle && n.extend(k, {
                pixelPosition: function() {
                    return o(),
                    e
                },
                boxSizingReliable: function() {
                    return null == t && o(),
                    t
                },
                reliableMarginRight: function() {
                    var e, t = s.appendChild(l.createElement("div"));
                    return t.style.cssText = s.style.cssText = "-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",
                    t.style.marginRight = t.style.width = "0",
                    s.style.width = "1px",
                    r.appendChild(i),
                    e = !parseFloat(a.getComputedStyle(t, null).marginRight),
                    r.removeChild(i),
                    s.removeChild(t),
                    e
                }
            })
        }
    } (),
    n.swap = function(e, t, n, r) {
        var i, s, o = {};
        for (s in t) o[s] = e.style[s],
        e.style[s] = t[s];
        i = n.apply(e, r || []);
        for (s in t) e.style[s] = o[s];
        return i
    };
    var za = /^(none|table(?!-c[ea]).+)/,
    Aa = new RegExp("^(" + Q + ")(.*)$", "i"),
    Ba = new RegExp("^([+-])=(" + Q + ")", "i"),
    Ca = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    },
    Da = {
        letterSpacing: "0",
        fontWeight: "400"
    },
    Ea = ["Webkit", "O", "Moz", "ms"];
    n.extend({
        cssHooks: {
            opacity: {
                get: function(e, t) {
                    if (t) {
                        var n = xa(e, "opacity");
                        return "" === n ? "1": n
                    }
                }
            }
        },
        cssNumber: {
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {
            "float": "cssFloat"
        },
        style: function(e, t, r, i) {
            if (e && 3 !== e.nodeType && 8 !== e.nodeType && e.style) {
                var s, o, u, a = n.camelCase(t),
                f = e.style;
                return t = n.cssProps[a] || (n.cssProps[a] = Fa(f, a)),
                u = n.cssHooks[t] || n.cssHooks[a],
                void 0 === r ? u && "get" in u && void 0 !== (s = u.get(e, !1, i)) ? s: f[t] : (o = typeof r, "string" === o && (s = Ba.exec(r)) && (r = (s[1] + 1) * s[2] + parseFloat(n.css(e, t)), o = "number"), null != r && r === r && ("number" !== o || n.cssNumber[a] || (r += "px"), k.clearCloneStyle || "" !== r || 0 !== t.indexOf("background") || (f[t] = "inherit"), u && "set" in u && void 0 === (r = u.set(e, r, i)) || (f[t] = r)), void 0)
            }
        },
        css: function(e, t, r, i) {
            var s, o, u, a = n.camelCase(t);
            return t = n.cssProps[a] || (n.cssProps[a] = Fa(e.style, a)),
            u = n.cssHooks[t] || n.cssHooks[a],
            u && "get" in u && (s = u.get(e, !0, r)),
            void 0 === s && (s = xa(e, t, i)),
            "normal" === s && t in Da && (s = Da[t]),
            "" === r || r ? (o = parseFloat(s), r === !0 || n.isNumeric(o) ? o || 0 : s) : s
        }
    }),
    n.each(["height", "width"],
    function(e, t) {
        n.cssHooks[t] = {
            get: function(e, r, i) {
                return r ? za.test(n.css(e, "display")) && 0 === e.offsetWidth ? n.swap(e, Ca,
                function() {
                    return Ia(e, t, i)
                }) : Ia(e, t, i) : void 0
            },
            set: function(e, r, i) {
                var s = i && wa(e);
                return Ga(e, r, i ? Ha(e, t, i, "border-box" === n.css(e, "boxSizing", !1, s), s) : 0)
            }
        }
    }),
    n.cssHooks.marginRight = ya(k.reliableMarginRight,
    function(e, t) {
        return t ? n.swap(e, {
            display: "inline-block"
        },
        xa, [e, "marginRight"]) : void 0
    }),
    n.each({
        margin: "",
        padding: "",
        border: "Width"
    },
    function(e, t) {
        n.cssHooks[e + t] = {
            expand: function(n) {
                for (var r = 0,
                i = {},
                s = "string" == typeof n ? n.split(" ") : [n]; 4 > r; r++) i[e + R[r] + t] = s[r] || s[r - 2] || s[0];
                return i
            }
        },
        ua.test(e) || (n.cssHooks[e + t].set = Ga)
    }),
    n.fn.extend({
        css: function(e, t) {
            return J(this,
            function(e, t, r) {
                var i, s, o = {},
                u = 0;
                if (n.isArray(t)) {
                    for (i = wa(e), s = t.length; s > u; u++) o[t[u]] = n.css(e, t[u], !1, i);
                    return o
                }
                return void 0 !== r ? n.style(e, t, r) : n.css(e, t)
            },
            e, t, arguments.length > 1)
        },
        show: function() {
            return Ja(this, !0)
        },
        hide: function() {
            return Ja(this)
        },
        toggle: function(e) {
            return "boolean" == typeof e ? e ? this.show() : this.hide() : this.each(function() {
                S(this) ? n(this).show() : n(this).hide()
            })
        }
    }),
    n.Tween = Ka,
    Ka.prototype = {
        constructor: Ka,
        init: function(e, t, r, i, s, o) {
            this.elem = e,
            this.prop = r,
            this.easing = s || "swing",
            this.options = t,
            this.start = this.now = this.cur(),
            this.end = i,
            this.unit = o || (n.cssNumber[r] ? "": "px")
        },
        cur: function() {
            var e = Ka.propHooks[this.prop];
            return e && e.get ? e.get(this) : Ka.propHooks._default.get(this)
        },
        run: function(e) {
            var t, r = Ka.propHooks[this.prop];
            return this.options.duration ? this.pos = t = n.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration) : this.pos = t = e,
            this.now = (this.end - this.start) * t + this.start,
            this.options.step && this.options.step.call(this.elem, this.now, this),
            r && r.set ? r.set(this) : Ka.propHooks._default.set(this),
            this
        }
    },
    Ka.prototype.init.prototype = Ka.prototype,
    Ka.propHooks = {
        _default: {
            get: function(e) {
                var t;
                return null == e.elem[e.prop] || e.elem.style && null != e.elem.style[e.prop] ? (t = n.css(e.elem, e.prop, ""), t && "auto" !== t ? t: 0) : e.elem[e.prop]
            },
            set: function(e) {
                n.fx.step[e.prop] ? n.fx.step[e.prop](e) : e.elem.style && (null != e.elem.style[n.cssProps[e.prop]] || n.cssHooks[e.prop]) ? n.style(e.elem, e.prop, e.now + e.unit) : e.elem[e.prop] = e.now
            }
        }
    },
    Ka.propHooks.scrollTop = Ka.propHooks.scrollLeft = {
        set: function(e) {
            e.elem.nodeType && e.elem.parentNode && (e.elem[e.prop] = e.now)
        }
    },
    n.easing = {
        linear: function(e) {
            return e
        },
        swing: function(e) {
            return.5 - Math.cos(e * Math.PI) / 2
        }
    },
    n.fx = Ka.prototype.init,
    n.fx.step = {};
    var La, Ma, Na = /^(?:toggle|show|hide)$/,
    Oa = new RegExp("^(?:([+-])=|)(" + Q + ")([a-z%]*)$", "i"),
    Pa = /queueHooks$/,
    Qa = [Va],
    Ra = {
        "*": [function(e, t) {
            var r = this.createTween(e, t),
            i = r.cur(),
            s = Oa.exec(t),
            o = s && s[3] || (n.cssNumber[e] ? "": "px"),
            u = (n.cssNumber[e] || "px" !== o && +i) && Oa.exec(n.css(r.elem, e)),
            a = 1,
            f = 20;
            if (u && u[3] !== o) {
                o = o || u[3],
                s = s || [],
                u = +i || 1;
                do a = a || ".5",
                u /= a,
                n.style(r.elem, e, u + o);
                while (a !== (a = r.cur() / i) && 1 !== a && --f)
            }
            return s && (u = r.start = +u || +i || 0, r.unit = o, r.end = s[1] ? u + (s[1] + 1) * s[2] : +s[2]),
            r
        }]
    };
    n.Animation = n.extend(Xa, {
        tweener: function(e, t) {
            n.isFunction(e) ? (t = e, e = ["*"]) : e = e.split(" ");
            for (var r, i = 0,
            s = e.length; s > i; i++) r = e[i],
            Ra[r] = Ra[r] || [],
            Ra[r].unshift(t)
        },
        prefilter: function(e, t) {
            t ? Qa.unshift(e) : Qa.push(e)
        }
    }),
    n.speed = function(e, t, r) {
        var i = e && "object" == typeof e ? n.extend({},
        e) : {
            complete: r || !r && t || n.isFunction(e) && e,
            duration: e,
            easing: r && t || t && !n.isFunction(t) && t
        };
        return i.duration = n.fx.off ? 0 : "number" == typeof i.duration ? i.duration: i.duration in n.fx.speeds ? n.fx.speeds[i.duration] : n.fx.speeds._default,
        (null == i.queue || i.queue === !0) && (i.queue = "fx"),
        i.old = i.complete,
        i.complete = function() {
            n.isFunction(i.old) && i.old.call(this),
            i.queue && n.dequeue(this, i.queue)
        },
        i
    },
    n.fn.extend({
        fadeTo: function(e, t, n, r) {
            return this.filter(S).css("opacity", 0).show().end().animate({
                opacity: t
            },
            e, n, r)
        },
        animate: function(e, t, r, i) {
            var s = n.isEmptyObject(e),
            o = n.speed(t, r, i),
            u = function() {
                var t = Xa(this, n.extend({},
                e), o); (s || L.get(this, "finish")) && t.stop(!0)
            };
            return u.finish = u,
            s || o.queue === !1 ? this.each(u) : this.queue(o.queue, u)
        },
        stop: function(e, t, r) {
            var i = function(e) {
                var t = e.stop;
                delete e.stop,
                t(r)
            };
            return "string" != typeof e && (r = t, t = e, e = void 0),
            t && e !== !1 && this.queue(e || "fx", []),
            this.each(function() {
                var t = !0,
                s = null != e && e + "queueHooks",
                o = n.timers,
                u = L.get(this);
                if (s) u[s] && u[s].stop && i(u[s]);
                else for (s in u) u[s] && u[s].stop && Pa.test(s) && i(u[s]);
                for (s = o.length; s--;) o[s].elem !== this || null != e && o[s].queue !== e || (o[s].anim.stop(r), t = !1, o.splice(s, 1)); (t || !r) && n.dequeue(this, e)
            })
        },
        finish: function(e) {
            return e !== !1 && (e = e || "fx"),
            this.each(function() {
                var t, r = L.get(this),
                i = r[e + "queue"],
                s = r[e + "queueHooks"],
                o = n.timers,
                u = i ? i.length: 0;
                for (r.finish = !0, n.queue(this, e, []), s && s.stop && s.stop.call(this, !0), t = o.length; t--;) o[t].elem === this && o[t].queue === e && (o[t].anim.stop(!0), o.splice(t, 1));
                for (t = 0; u > t; t++) i[t] && i[t].finish && i[t].finish.call(this);
                delete r.finish
            })
        }
    }),
    n.each(["toggle", "show", "hide"],
    function(e, t) {
        var r = n.fn[t];
        n.fn[t] = function(e, n, i) {
            return null == e || "boolean" == typeof e ? r.apply(this, arguments) : this.animate(Ta(t, !0), e, n, i)
        }
    }),
    n.each({
        slideDown: Ta("show"),
        slideUp: Ta("hide"),
        slideToggle: Ta("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    },
    function(e, t) {
        n.fn[e] = function(e, n, r) {
            return this.animate(t, e, n, r)
        }
    }),
    n.timers = [],
    n.fx.tick = function() {
        var e, t = 0,
        r = n.timers;
        for (La = n.now(); t < r.length; t++) e = r[t],
        e() || r[t] !== e || r.splice(t--, 1);
        r.length || n.fx.stop(),
        La = void 0
    },
    n.fx.timer = function(e) {
        n.timers.push(e),
        e() ? n.fx.start() : n.timers.pop()
    },
    n.fx.interval = 13,
    n.fx.start = function() {
        Ma || (Ma = setInterval(n.fx.tick, n.fx.interval))
    },
    n.fx.stop = function() {
        clearInterval(Ma),
        Ma = null
    },
    n.fx.speeds = {
        slow: 600,
        fast: 200,
        _default: 400
    },
    n.fn.delay = function(e, t) {
        return e = n.fx ? n.fx.speeds[e] || e: e,
        t = t || "fx",
        this.queue(t,
        function(t, n) {
            var r = setTimeout(t, e);
            n.stop = function() {
                clearTimeout(r)
            }
        })
    },
    function() {
        var e = l.createElement("input"),
        t = l.createElement("select"),
        n = t.appendChild(l.createElement("option"));
        e.type = "checkbox",
        k.checkOn = "" !== e.value,
        k.optSelected = n.selected,
        t.disabled = !0,
        k.optDisabled = !n.disabled,
        e = l.createElement("input"),
        e.value = "t",
        e.type = "radio",
        k.radioValue = "t" === e.value
    } ();
    var Ya, Za, $a = n.expr.attrHandle;
    n.fn.extend({
        attr: function(e, t) {
            return J(this, n.attr, e, t, arguments.length > 1)
        },
        removeAttr: function(e) {
            return this.each(function() {
                n.removeAttr(this, e)
            })
        }
    }),
    n.extend({
        attr: function(e, t, r) {
            var i, s, o = e.nodeType;
            if (e && 3 !== o && 8 !== o && 2 !== o) return typeof e.getAttribute === U ? n.prop(e, t, r) : (1 === o && n.isXMLDoc(e) || (t = t.toLowerCase(), i = n.attrHooks[t] || (n.expr.match.bool.test(t) ? Za: Ya)), void 0 === r ? i && "get" in i && null !== (s = i.get(e, t)) ? s: (s = n.find.attr(e, t), null == s ? void 0 : s) : null !== r ? i && "set" in i && void 0 !== (s = i.set(e, r, t)) ? s: (e.setAttribute(t, r + ""), r) : void n.removeAttr(e, t))
        },
        removeAttr: function(e, t) {
            var r, i, s = 0,
            o = t && t.match(E);
            if (o && 1 === e.nodeType) while (r = o[s++]) i = n.propFix[r] || r,
            n.expr.match.bool.test(r) && (e[i] = !1),
            e.removeAttribute(r)
        },
        attrHooks: {
            type: {
                set: function(e, t) {
                    if (!k.radioValue && "radio" === t && n.nodeName(e, "input")) {
                        var r = e.value;
                        return e.setAttribute("type", t),
                        r && (e.value = r),
                        t
                    }
                }
            }
        }
    }),
    Za = {
        set: function(e, t, r) {
            return t === !1 ? n.removeAttr(e, r) : e.setAttribute(r, r),
            r
        }
    },
    n.each(n.expr.match.bool.source.match(/\w+/g),
    function(e, t) {
        var r = $a[t] || n.find.attr;
        $a[t] = function(e, t, n) {
            var i, s;
            return n || (s = $a[t], $a[t] = i, i = null != r(e, t, n) ? t.toLowerCase() : null, $a[t] = s),
            i
        }
    });
    var _a = /^(?:input|select|textarea|button)$/i;
    n.fn.extend({
        prop: function(e, t) {
            return J(this, n.prop, e, t, arguments.length > 1)
        },
        removeProp: function(e) {
            return this.each(function() {
                delete this[n.propFix[e] || e]
            })
        }
    }),
    n.extend({
        propFix: {
            "for": "htmlFor",
            "class": "className"
        },
        prop: function(e, t, r) {
            var i, s, o, u = e.nodeType;
            if (e && 3 !== u && 8 !== u && 2 !== u) return o = 1 !== u || !n.isXMLDoc(e),
            o && (t = n.propFix[t] || t, s = n.propHooks[t]),
            void 0 !== r ? s && "set" in s && void 0 !== (i = s.set(e, r, t)) ? i: e[t] = r: s && "get" in s && null !== (i = s.get(e, t)) ? i: e[t]
        },
        propHooks: {
            tabIndex: {
                get: function(e) {
                    return e.hasAttribute("tabindex") || _a.test(e.nodeName) || e.href ? e.tabIndex: -1
                }
            }
        }
    }),
    k.optSelected || (n.propHooks.selected = {
        get: function(e) {
            var t = e.parentNode;
            return t && t.parentNode && t.parentNode.selectedIndex,
            null
        }
    }),
    n.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"],
    function() {
        n.propFix[this.toLowerCase()] = this
    });
    var ab = /[\t\r\n\f]/g;
    n.fn.extend({
        addClass: function(e) {
            var t, r, i, s, o, u, a = "string" == typeof e && e,
            f = 0,
            l = this.length;
            if (n.isFunction(e)) return this.each(function(t) {
                n(this).addClass(e.call(this, t, this.className))
            });
            if (a) for (t = (e || "").match(E) || []; l > f; f++) if (r = this[f], i = 1 === r.nodeType && (r.className ? (" " + r.className + " ").replace(ab, " ") : " ")) {
                o = 0;
                while (s = t[o++]) i.indexOf(" " + s + " ") < 0 && (i += s + " ");
                u = n.trim(i),
                r.className !== u && (r.className = u)
            }
            return this
        },
        removeClass: function(e) {
            var t, r, i, s, o, u, a = 0 === arguments.length || "string" == typeof e && e,
            f = 0,
            l = this.length;
            if (n.isFunction(e)) return this.each(function(t) {
                n(this).removeClass(e.call(this, t, this.className))
            });
            if (a) for (t = (e || "").match(E) || []; l > f; f++) if (r = this[f], i = 1 === r.nodeType && (r.className ? (" " + r.className + " ").replace(ab, " ") : "")) {
                o = 0;
                while (s = t[o++]) while (i.indexOf(" " + s + " ") >= 0) i = i.replace(" " + s + " ", " ");
                u = e ? n.trim(i) : "",
                r.className !== u && (r.className = u)
            }
            return this
        },
        toggleClass: function(e, t) {
            var r = typeof e;
            return "boolean" == typeof t && "string" === r ? t ? this.addClass(e) : this.removeClass(e) : this.each(n.isFunction(e) ?
            function(r) {
                n(this).toggleClass(e.call(this, r, this.className, t), t)
            }: function() {
                if ("string" === r) {
                    var t, i = 0,
                    s = n(this),
                    o = e.match(E) || [];
                    while (t = o[i++]) s.hasClass(t) ? s.removeClass(t) : s.addClass(t)
                } else(r === U || "boolean" === r) && (this.className && L.set(this, "__className__", this.className), this.className = this.className || e === !1 ? "": L.get(this, "__className__") || "")
            })
        },
        hasClass: function(e) {
            for (var t = " " + e + " ",
            n = 0,
            r = this.length; r > n; n++) if (1 === this[n].nodeType && (" " + this[n].className + " ").replace(ab, " ").indexOf(t) >= 0) return ! 0;
            return ! 1
        }
    });
    var bb = /\r/g;
    n.fn.extend({
        val: function(e) {
            var t, r, i, s = this[0];
            if (arguments.length) return i = n.isFunction(e),
            this.each(function(r) {
                var s;
                1 === this.nodeType && (s = i ? e.call(this, r, n(this).val()) : e, null == s ? s = "": "number" == typeof s ? s += "": n.isArray(s) && (s = n.map(s,
                function(e) {
                    return null == e ? "": e + ""
                })), t = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], t && "set" in t && void 0 !== t.set(this, s, "value") || (this.value = s))
            });
            if (s) return t = n.valHooks[s.type] || n.valHooks[s.nodeName.toLowerCase()],
            t && "get" in t && void 0 !== (r = t.get(s, "value")) ? r: (r = s.value, "string" == typeof r ? r.replace(bb, "") : null == r ? "": r)
        }
    }),
    n.extend({
        valHooks: {
            option: {
                get: function(e) {
                    var t = n.find.attr(e, "value");
                    return null != t ? t: n.trim(n.text(e))
                }
            },
            select: {
                get: function(e) {
                    for (var t, r, i = e.options,
                    s = e.selectedIndex,
                    o = "select-one" === e.type || 0 > s,
                    u = o ? null: [], a = o ? s + 1 : i.length, f = 0 > s ? a: o ? s: 0; a > f; f++) if (r = i[f], !(!r.selected && f !== s || (k.optDisabled ? r.disabled: null !== r.getAttribute("disabled")) || r.parentNode.disabled && n.nodeName(r.parentNode, "optgroup"))) {
                        if (t = n(r).val(), o) return t;
                        u.push(t)
                    }
                    return u
                },
                set: function(e, t) {
                    var r, i, s = e.options,
                    o = n.makeArray(t),
                    u = s.length;
                    while (u--) i = s[u],
                    (i.selected = n.inArray(i.value, o) >= 0) && (r = !0);
                    return r || (e.selectedIndex = -1),
                    o
                }
            }
        }
    }),
    n.each(["radio", "checkbox"],
    function() {
        n.valHooks[this] = {
            set: function(e, t) {
                return n.isArray(t) ? e.checked = n.inArray(n(e).val(), t) >= 0 : void 0
            }
        },
        k.checkOn || (n.valHooks[this].get = function(e) {
            return null === e.getAttribute("value") ? "on": e.value
        })
    }),
    n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),
    function(e, t) {
        n.fn[t] = function(e, n) {
            return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t)
        }
    }),
    n.fn.extend({
        hover: function(e, t) {
            return this.mouseenter(e).mouseleave(t || e)
        },
        bind: function(e, t, n) {
            return this.on(e, null, t, n)
        },
        unbind: function(e, t) {
            return this.off(e, null, t)
        },
        delegate: function(e, t, n, r) {
            return this.on(t, e, n, r)
        },
        undelegate: function(e, t, n) {
            return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n)
        }
    });
    var cb = n.now(),
    db = /\?/;
    n.parseJSON = function(e) {
        return JSON.parse(e + "")
    },
    n.parseXML = function(e) {
        var t, r;
        if (!e || "string" != typeof e) return null;
        try {
            r = new DOMParser,
            t = r.parseFromString(e, "text/xml")
        } catch(i) {
            t = void 0
        }
        return (!t || t.getElementsByTagName("parsererror").length) && n.error("Invalid XML: " + e),
        t
    };
    var eb = /#.*$/,
    fb = /([?&])_=[^&]*/,
    gb = /^(.*?):[ \t]*([^\r\n]*)$/gm,
    hb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
    ib = /^(?:GET|HEAD)$/,
    jb = /^\/\//,
    kb = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,
    lb = {},
    mb = {},
    nb = "*/".concat("*"),
    ob = a.location.href,
    pb = kb.exec(ob.toLowerCase()) || [];
    n.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: ob,
            type: "GET",
            isLocal: hb.test(pb[1]),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": nb,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {
                xml: /xml/,
                html: /html/,
                json: /json/
            },
            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },
            converters: {
                "* text": String,
                "text html": !0,
                "text json": n.parseJSON,
                "text xml": n.parseXML
            },
            flatOptions: {
                url: !0,
                context: !0
            }
        },
        ajaxSetup: function(e, t) {
            return t ? sb(sb(e, n.ajaxSettings), t) : sb(n.ajaxSettings, e)
        },
        ajaxPrefilter: qb(lb),
        ajaxTransport: qb(mb),
        ajax: function(e, t) {
            function T(e, t, o, a) {
                var l, g, y, w, E, x = t;
                2 !== b && (b = 2, u && clearTimeout(u), r = void 0, s = a || "", S.readyState = e > 0 ? 4 : 0, l = e >= 200 && 300 > e || 304 === e, o && (w = tb(c, S, o)), w = ub(c, w, S, l), l ? (c.ifModified && (E = S.getResponseHeader("Last-Modified"), E && (n.lastModified[i] = E), E = S.getResponseHeader("etag"), E && (n.etag[i] = E)), 204 === e || "HEAD" === c.type ? x = "nocontent": 304 === e ? x = "notmodified": (x = w.state, g = w.data, y = w.error, l = !y)) : (y = x, (e || !x) && (x = "error", 0 > e && (e = 0))), S.status = e, S.statusText = (t || x) + "", l ? d.resolveWith(h, [g, x, S]) : d.rejectWith(h, [S, x, y]), S.statusCode(m), m = void 0, f && p.trigger(l ? "ajaxSuccess": "ajaxError", [S, c, l ? g: y]), v.fireWith(h, [S, x]), f && (p.trigger("ajaxComplete", [S, c]), --n.active || n.event.trigger("ajaxStop")))
            }
            "object" == typeof e && (t = e, e = void 0),
            t = t || {};
            var r, i, s, o, u, a, f, l, c = n.ajaxSetup({},
            t),
            h = c.context || c,
            p = c.context && (h.nodeType || h.jquery) ? n(h) : n.event,
            d = n.Deferred(),
            v = n.Callbacks("once memory"),
            m = c.statusCode || {},
            g = {},
            y = {},
            b = 0,
            w = "canceled",
            S = {
                readyState: 0,
                getResponseHeader: function(e) {
                    var t;
                    if (2 === b) {
                        if (!o) {
                            o = {};
                            while (t = gb.exec(s)) o[t[1].toLowerCase()] = t[2]
                        }
                        t = o[e.toLowerCase()]
                    }
                    return null == t ? null: t
                },
                getAllResponseHeaders: function() {
                    return 2 === b ? s: null
                },
                setRequestHeader: function(e, t) {
                    var n = e.toLowerCase();
                    return b || (e = y[n] = y[n] || e, g[e] = t),
                    this
                },
                overrideMimeType: function(e) {
                    return b || (c.mimeType = e),
                    this
                },
                statusCode: function(e) {
                    var t;
                    if (e) if (2 > b) for (t in e) m[t] = [m[t], e[t]];
                    else S.always(e[S.status]);
                    return this
                },
                abort: function(e) {
                    var t = e || w;
                    return r && r.abort(t),
                    T(0, t),
                    this
                }
            };
            if (d.promise(S).complete = v.add, S.success = S.done, S.error = S.fail, c.url = ((e || c.url || ob) + "").replace(eb, "").replace(jb, pb[1] + "//"), c.type = t.method || t.type || c.method || c.type, c.dataTypes = n.trim(c.dataType || "*").toLowerCase().match(E) || [""], null == c.crossDomain && (a = kb.exec(c.url.toLowerCase()), c.crossDomain = !(!a || a[1] === pb[1] && a[2] === pb[2] && (a[3] || ("http:" === a[1] ? "80": "443")) === (pb[3] || ("http:" === pb[1] ? "80": "443")))), c.data && c.processData && "string" != typeof c.data && (c.data = n.param(c.data, c.traditional)), rb(lb, c, t, S), 2 === b) return S;
            f = n.event && c.global,
            f && 0 === n.active++&&n.event.trigger("ajaxStart"),
            c.type = c.type.toUpperCase(),
            c.hasContent = !ib.test(c.type),
            i = c.url,
            c.hasContent || (c.data && (i = c.url += (db.test(i) ? "&": "?") + c.data, delete c.data), c.cache === !1 && (c.url = fb.test(i) ? i.replace(fb, "$1_=" + cb++) : i + (db.test(i) ? "&": "?") + "_=" + cb++)),
            c.ifModified && (n.lastModified[i] && S.setRequestHeader("If-Modified-Since", n.lastModified[i]), n.etag[i] && S.setRequestHeader("If-None-Match", n.etag[i])),
            (c.data && c.hasContent && c.contentType !== !1 || t.contentType) && S.setRequestHeader("Content-Type", c.contentType),
            S.setRequestHeader("Accept", c.dataTypes[0] && c.accepts[c.dataTypes[0]] ? c.accepts[c.dataTypes[0]] + ("*" !== c.dataTypes[0] ? ", " + nb + "; q=0.01": "") : c.accepts["*"]);
            for (l in c.headers) S.setRequestHeader(l, c.headers[l]);
            if (!c.beforeSend || c.beforeSend.call(h, S, c) !== !1 && 2 !== b) {
                w = "abort";
                for (l in {
                    success: 1,
                    error: 1,
                    complete: 1
                }) S[l](c[l]);
                if (r = rb(mb, c, t, S)) {
                    S.readyState = 1,
                    f && p.trigger("ajaxSend", [S, c]),
                    c.async && c.timeout > 0 && (u = setTimeout(function() {
                        S.abort("timeout")
                    },
                    c.timeout));
                    try {
                        b = 1,
                        r.send(g, T)
                    } catch(x) {
                        if (! (2 > b)) throw x;
                        T( - 1, x)
                    }
                } else T( - 1, "No Transport");
                return S
            }
            return S.abort()
        },
        getJSON: function(e, t, r) {
            return n.get(e, t, r, "json")
        },
        getScript: function(e, t) {
            return n.get(e, void 0, t, "script")
        }
    }),
    n.each(["get", "post"],
    function(e, t) {
        n[t] = function(e, r, i, s) {
            return n.isFunction(r) && (s = s || i, i = r, r = void 0),
            n.ajax({
                url: e,
                type: t,
                dataType: s,
                data: r,
                success: i
            })
        }
    }),
    n._evalUrl = function(e) {
        return n.ajax({
            url: e,
            type: "GET",
            dataType: "script",
            async: !1,
            global: !1,
            "throws": !0
        })
    },
    n.fn.extend({
        wrapAll: function(e) {
            var t;
            return n.isFunction(e) ? this.each(function(t) {
                n(this).wrapAll(e.call(this, t))
            }) : (this[0] && (t = n(e, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && t.insertBefore(this[0]), t.map(function() {
                var e = this;
                while (e.firstElementChild) e = e.firstElementChild;
                return e
            }).append(this)), this)
        },
        wrapInner: function(e) {
            return this.each(n.isFunction(e) ?
            function(t) {
                n(this).wrapInner(e.call(this, t))
            }: function() {
                var t = n(this),
                r = t.contents();
                r.length ? r.wrapAll(e) : t.append(e)
            })
        },
        wrap: function(e) {
            var t = n.isFunction(e);
            return this.each(function(r) {
                n(this).wrapAll(t ? e.call(this, r) : e)
            })
        },
        unwrap: function() {
            return this.parent().each(function() {
                n.nodeName(this, "body") || n(this).replaceWith(this.childNodes)
            }).end()
        }
    }),
    n.expr.filters.hidden = function(e) {
        return e.offsetWidth <= 0 && e.offsetHeight <= 0
    },
    n.expr.filters.visible = function(e) {
        return ! n.expr.filters.hidden(e)
    };
    var vb = /%20/g,
    wb = /\[\]$/,
    xb = /\r?\n/g,
    yb = /^(?:submit|button|image|reset|file)$/i,
    zb = /^(?:input|select|textarea|keygen)/i;
    n.param = function(e, t) {
        var r, i = [],
        s = function(e, t) {
            t = n.isFunction(t) ? t() : null == t ? "": t,
            i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(t)
        };
        if (void 0 === t && (t = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(e) || e.jquery && !n.isPlainObject(e)) n.each(e,
        function() {
            s(this.name, this.value)
        });
        else for (r in e) Ab(r, e[r], t, s);
        return i.join("&").replace(vb, "+")
    },
    n.fn.extend({
        serialize: function() {
            return n.param(this.serializeArray())
        },
        serializeArray: function() {
            return this.map(function() {
                var e = n.prop(this, "elements");
                return e ? n.makeArray(e) : this
            }).filter(function() {
                var e = this.type;
                return this.name && !n(this).is(":disabled") && zb.test(this.nodeName) && !yb.test(e) && (this.checked || !T.test(e))
            }).map(function(e, t) {
                var r = n(this).val();
                return null == r ? null: n.isArray(r) ? n.map(r,
                function(e) {
                    return {
                        name: t.name,
                        value: e.replace(xb, "\r\n")
                    }
                }) : {
                    name: t.name,
                    value: r.replace(xb, "\r\n")
                }
            }).get()
        }
    }),
    n.ajaxSettings.xhr = function() {
        try {
            return new XMLHttpRequest
        } catch(e) {}
    };
    var Bb = 0,
    Cb = {},
    Db = {
        0 : 200,
        1223 : 204
    },
    Eb = n.ajaxSettings.xhr();
    a.attachEvent && a.attachEvent("onunload",
    function() {
        for (var e in Cb) Cb[e]()
    }),
    k.cors = !!Eb && "withCredentials" in Eb,
    k.ajax = Eb = !!Eb,
    n.ajaxTransport(function(e) {
        var t;
        return k.cors || Eb && !e.crossDomain ? {
            send: function(n, r) {
                var i, s = e.xhr(),
                o = ++Bb;
                if (s.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields) for (i in e.xhrFields) s[i] = e.xhrFields[i];
                e.mimeType && s.overrideMimeType && s.overrideMimeType(e.mimeType),
                e.crossDomain || n["X-Requested-With"] || (n["X-Requested-With"] = "XMLHttpRequest");
                for (i in n) s.setRequestHeader(i, n[i]);
                t = function(e) {
                    return function() {
                        t && (delete Cb[o], t = s.onload = s.onerror = null, "abort" === e ? s.abort() : "error" === e ? r(s.status, s.statusText) : r(Db[s.status] || s.status, s.statusText, "string" == typeof s.responseText ? {
                            text: s.responseText
                        }: void 0, s.getAllResponseHeaders()))
                    }
                },
                s.onload = t(),
                s.onerror = t("error"),
                t = Cb[o] = t("abort");
                try {
                    s.send(e.hasContent && e.data || null)
                } catch(u) {
                    if (t) throw u
                }
            },
            abort: function() {
                t && t()
            }
        }: void 0
    }),
    n.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /(?:java|ecma)script/
        },
        converters: {
            "text script": function(e) {
                return n.globalEval(e),
                e
            }
        }
    }),
    n.ajaxPrefilter("script",
    function(e) {
        void 0 === e.cache && (e.cache = !1),
        e.crossDomain && (e.type = "GET")
    }),
    n.ajaxTransport("script",
    function(e) {
        if (e.crossDomain) {
            var t, r;
            return {
                send: function(i, s) {
                    t = n("<script>").prop({
                        async: !0,
                        charset: e.scriptCharset,
                        src: e.url
                    }).on("load error", r = function(e) {
                        t.remove(),
                        r = null,
                        e && s("error" === e.type ? 404 : 200, e.type)
                    }),
                    l.head.appendChild(t[0])
                },
                abort: function() {
                    r && r()
                }
            }
        }
    });
    var Fb = [],
    Gb = /(=)\?(?=&|$)|\?\?/;
    n.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var e = Fb.pop() || n.expando + "_" + cb++;
            return this[e] = !0,
            e
        }
    }),
    n.ajaxPrefilter("json jsonp",
    function(e, t, r) {
        var i, s, o, u = e.jsonp !== !1 && (Gb.test(e.url) ? "url": "string" == typeof e.data && !(e.contentType || "").indexOf("application/x-www-form-urlencoded") && Gb.test(e.data) && "data");
        return u || "jsonp" === e.dataTypes[0] ? (i = e.jsonpCallback = n.isFunction(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, u ? e[u] = e[u].replace(Gb, "$1" + i) : e.jsonp !== !1 && (e.url += (db.test(e.url) ? "&": "?") + e.jsonp + "=" + i), e.converters["script json"] = function() {
            return o || n.error(i + " was not called"),
            o[0]
        },
        e.dataTypes[0] = "json", s = a[i], a[i] = function() {
            o = arguments
        },
        r.always(function() {
            a[i] = s,
            e[i] && (e.jsonpCallback = t.jsonpCallback, Fb.push(i)),
            o && n.isFunction(s) && s(o[0]),
            o = s = void 0
        }), "script") : void 0
    }),
    n.parseHTML = function(e, t, r) {
        if (!e || "string" != typeof e) return null;
        "boolean" == typeof t && (r = t, t = !1),
        t = t || l;
        var i = v.exec(e),
        s = !r && [];
        return i ? [t.createElement(i[1])] : (i = n.buildFragment([e], t, s), s && s.length && n(s).remove(), n.merge([], i.childNodes))
    };
    var Hb = n.fn.load;
    n.fn.load = function(e, t, r) {
        if ("string" != typeof e && Hb) return Hb.apply(this, arguments);
        var i, s, o, u = this,
        a = e.indexOf(" ");
        return a >= 0 && (i = n.trim(e.slice(a)), e = e.slice(0, a)),
        n.isFunction(t) ? (r = t, t = void 0) : t && "object" == typeof t && (s = "POST"),
        u.length > 0 && n.ajax({
            url: e,
            type: s,
            dataType: "html",
            data: t
        }).done(function(e) {
            o = arguments,
            u.html(i ? n("<div>").append(n.parseHTML(e)).find(i) : e)
        }).complete(r &&
        function(e, t) {
            u.each(r, o || [e.responseText, t, e])
        }),
        this
    },
    n.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"],
    function(e, t) {
        n.fn[t] = function(e) {
            return this.on(t, e)
        }
    }),
    n.expr.filters.animated = function(e) {
        return n.grep(n.timers,
        function(t) {
            return e === t.elem
        }).length
    };
    var Ib = a.document.documentElement;
    n.offset = {
        setOffset: function(e, t, r) {
            var i, s, o, u, a, f, l, c = n.css(e, "position"),
            h = n(e),
            p = {};
            "static" === c && (e.style.position = "relative"),
            a = h.offset(),
            o = n.css(e, "top"),
            f = n.css(e, "left"),
            l = ("absolute" === c || "fixed" === c) && (o + f).indexOf("auto") > -1,
            l ? (i = h.position(), u = i.top, s = i.left) : (u = parseFloat(o) || 0, s = parseFloat(f) || 0),
            n.isFunction(t) && (t = t.call(e, r, a)),
            null != t.top && (p.top = t.top - a.top + u),
            null != t.left && (p.left = t.left - a.left + s),
            "using" in t ? t.using.call(e, p) : h.css(p)
        }
    },
    n.fn.extend({
        offset: function(e) {
            if (arguments.length) return void 0 === e ? this: this.each(function(t) {
                n.offset.setOffset(this, e, t)
            });
            var t, r, i = this[0],
            s = {
                top: 0,
                left: 0
            },
            o = i && i.ownerDocument;
            if (o) return t = o.documentElement,
            n.contains(t, i) ? (typeof i.getBoundingClientRect !== U && (s = i.getBoundingClientRect()), r = Jb(o), {
                top: s.top + r.pageYOffset - t.clientTop,
                left: s.left + r.pageXOffset - t.clientLeft
            }) : s
        },
        position: function() {
            if (this[0]) {
                var e, t, r = this[0],
                i = {
                    top: 0,
                    left: 0
                };
                return "fixed" === n.css(r, "position") ? t = r.getBoundingClientRect() : (e = this.offsetParent(), t = this.offset(), n.nodeName(e[0], "html") || (i = e.offset()), i.top += n.css(e[0], "borderTopWidth", !0), i.left += n.css(e[0], "borderLeftWidth", !0)),
                {
                    top: t.top - i.top - n.css(r, "marginTop", !0),
                    left: t.left - i.left - n.css(r, "marginLeft", !0)
                }
            }
        },
        offsetParent: function() {
            return this.map(function() {
                var e = this.offsetParent || Ib;
                while (e && !n.nodeName(e, "html") && "static" === n.css(e, "position")) e = e.offsetParent;
                return e || Ib
            })
        }
    }),
    n.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    },
    function(e, t) {
        var r = "pageYOffset" === t;
        n.fn[e] = function(n) {
            return J(this,
            function(e, n, i) {
                var s = Jb(e);
                return void 0 === i ? s ? s[t] : e[n] : void(s ? s.scrollTo(r ? a.pageXOffset: i, r ? i: a.pageYOffset) : e[n] = i)
            },
            e, n, arguments.length, null)
        }
    }),
    n.each(["top", "left"],
    function(e, t) {
        n.cssHooks[t] = ya(k.pixelPosition,
        function(e, r) {
            return r ? (r = xa(e, t), va.test(r) ? n(e).position()[t] + "px": r) : void 0
        })
    }),
    n.each({
        Height: "height",
        Width: "width"
    },
    function(e, t) {
        n.each({
            padding: "inner" + e,
            content: t,
            "": "outer" + e
        },
        function(r, i) {
            n.fn[i] = function(i, s) {
                var o = arguments.length && (r || "boolean" != typeof i),
                u = r || (i === !0 || s === !0 ? "margin": "border");
                return J(this,
                function(t, r, i) {
                    var s;
                    return n.isWindow(t) ? t.document.documentElement["client" + e] : 9 === t.nodeType ? (s = t.documentElement, Math.max(t.body["scroll" + e], s["scroll" + e], t.body["offset" + e], s["offset" + e], s["client" + e])) : void 0 === i ? n.css(t, r, u) : n.style(t, r, i, u)
                },
                t, o ? i: void 0, o, null)
            }
        })
    }),
    n.fn.size = function() {
        return this.length
    },
    n.fn.andSelf = n.fn.addBack,
    "function" == typeof define && define.amd && define("jquery", [],
    function() {
        return n
    });
    var Kb = a.jQuery,
    Lb = a.$;
    return n.noConflict = function(e) {
        return a.$ === n && (a.$ = Lb),
        e && a.jQuery === n && (a.jQuery = Kb),
        n
    },
    typeof b === U && (a.jQuery = a.$ = n),
    n
}),
function() {
    var e = this,
    t = e._,
    n = {},
    r = Array.prototype,
    i = Object.prototype,
    s = Function.prototype,
    o = r.push,
    u = r.slice,
    a = r.concat,
    f = i.toString,
    l = i.hasOwnProperty,
    c = r.forEach,
    h = r.map,
    p = r.reduce,
    d = r.reduceRight,
    v = r.filter,
    m = r.every,
    g = r.some,
    y = r.indexOf,
    b = r.lastIndexOf,
    w = Array.isArray,
    E = Object.keys,
    S = s.bind,
    x = function(e) {
        return e instanceof x ? e: this instanceof x ? void(this._wrapped = e) : new x(e)
    };
    "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = x), exports._ = x) : e._ = x,
    x.VERSION = "1.6.0";
    var T = x.each = x.forEach = function(e, t, r) {
        if (null == e) return e;
        if (c && e.forEach === c) e.forEach(t, r);
        else if (e.length === +e.length) {
            for (var i = 0,
            s = e.length; s > i; i++) if (t.call(r, e[i], i, e) === n) return
        } else for (var o = x.keys(e), i = 0, s = o.length; s > i; i++) if (t.call(r, e[o[i]], o[i], e) === n) return;
        return e
    };
    x.map = x.collect = function(e, t, n) {
        var r = [];
        return null == e ? r: h && e.map === h ? e.map(t, n) : (T(e,
        function(e, i, s) {
            r.push(t.call(n, e, i, s))
        }), r)
    };
    var N = "Reduce of empty array with no initial value";
    x.reduce = x.foldl = x.inject = function(e, t, n, r) {
        var i = arguments.length > 2;
        if (null == e && (e = []), p && e.reduce === p) return r && (t = x.bind(t, r)),
        i ? e.reduce(t, n) : e.reduce(t);
        if (T(e,
        function(e, s, o) {
            i ? n = t.call(r, n, e, s, o) : (n = e, i = !0)
        }), !i) throw new TypeError(N);
        return n
    },
    x.reduceRight = x.foldr = function(e, t, n, r) {
        var i = arguments.length > 2;
        if (null == e && (e = []), d && e.reduceRight === d) return r && (t = x.bind(t, r)),
        i ? e.reduceRight(t, n) : e.reduceRight(t);
        var s = e.length;
        if (s !== +s) {
            var o = x.keys(e);
            s = o.length
        }
        if (T(e,
        function(u, a, f) {
            a = o ? o[--s] : --s,
            i ? n = t.call(r, n, e[a], a, f) : (n = e[a], i = !0)
        }), !i) throw new TypeError(N);
        return n
    },
    x.find = x.detect = function(e, t, n) {
        var r;
        return C(e,
        function(e, i, s) {
            return t.call(n, e, i, s) ? (r = e, !0) : void 0
        }),
        r
    },
    x.filter = x.select = function(e, t, n) {
        var r = [];
        return null == e ? r: v && e.filter === v ? e.filter(t, n) : (T(e,
        function(e, i, s) {
            t.call(n, e, i, s) && r.push(e)
        }), r)
    },
    x.reject = function(e, t, n) {
        return x.filter(e,
        function(e, r, i) {
            return ! t.call(n, e, r, i)
        },
        n)
    },
    x.every = x.all = function(e, t, r) {
        t || (t = x.identity);
        var i = !0;
        return null == e ? i: m && e.every === m ? e.every(t, r) : (T(e,
        function(e, s, o) {
            return (i = i && t.call(r, e, s, o)) ? void 0 : n
        }), !!i)
    };
    var C = x.some = x.any = function(e, t, r) {
        t || (t = x.identity);
        var i = !1;
        return null == e ? i: g && e.some === g ? e.some(t, r) : (T(e,
        function(e, s, o) {
            return i || (i = t.call(r, e, s, o)) ? n: void 0
        }), !!i)
    };
    x.contains = x.include = function(e, t) {
        return null == e ? !1 : y && e.indexOf === y ? e.indexOf(t) != -1 : C(e,
        function(e) {
            return e === t
        })
    },
    x.invoke = function(e, t) {
        var n = u.call(arguments, 2),
        r = x.isFunction(t);
        return x.map(e,
        function(e) {
            return (r ? t: e[t]).apply(e, n)
        })
    },
    x.pluck = function(e, t) {
        return x.map(e, x.property(t))
    },
    x.where = function(e, t) {
        return x.filter(e, x.matches(t))
    },
    x.findWhere = function(e, t) {
        return x.find(e, x.matches(t))
    },
    x.max = function(e, t, n) {
        if (!t && x.isArray(e) && e[0] === +e[0] && e.length < 65535) return Math.max.apply(Math, e);
        var r = -1 / 0,
        i = -1 / 0;
        return T(e,
        function(e, s, o) {
            var u = t ? t.call(n, e, s, o) : e;
            u > i && (r = e, i = u)
        }),
        r
    },
    x.min = function(e, t, n) {
        if (!t && x.isArray(e) && e[0] === +e[0] && e.length < 65535) return Math.min.apply(Math, e);
        var r = 1 / 0,
        i = 1 / 0;
        return T(e,
        function(e, s, o) {
            var u = t ? t.call(n, e, s, o) : e;
            i > u && (r = e, i = u)
        }),
        r
    },
    x.shuffle = function(e) {
        var t, n = 0,
        r = [];
        return T(e,
        function(e) {
            t = x.random(n++),
            r[n - 1] = r[t],
            r[t] = e
        }),
        r
    },
    x.sample = function(e, t, n) {
        return null == t || n ? (e.length !== +e.length && (e = x.values(e)), e[x.random(e.length - 1)]) : x.shuffle(e).slice(0, Math.max(0, t))
    };
    var k = function(e) {
        return null == e ? x.identity: x.isFunction(e) ? e: x.property(e)
    };
    x.sortBy = function(e, t, n) {
        return t = k(t),
        x.pluck(x.map(e,
        function(e, r, i) {
            return {
                value: e,
                index: r,
                criteria: t.call(n, e, r, i)
            }
        }).sort(function(e, t) {
            var n = e.criteria,
            r = t.criteria;
            if (n !== r) {
                if (n > r || n === void 0) return 1;
                if (r > n || r === void 0) return - 1
            }
            return e.index - t.index
        }), "value")
    };
    var L = function(e) {
        return function(t, n, r) {
            var i = {};
            return n = k(n),
            T(t,
            function(s, o) {
                var u = n.call(r, s, o, t);
                e(i, u, s)
            }),
            i
        }
    };
    x.groupBy = L(function(e, t, n) {
        x.has(e, t) ? e[t].push(n) : e[t] = [n]
    }),
    x.indexBy = L(function(e, t, n) {
        e[t] = n
    }),
    x.countBy = L(function(e, t) {
        x.has(e, t) ? e[t]++:e[t] = 1
    }),
    x.sortedIndex = function(e, t, n, r) {
        n = k(n);
        for (var i = n.call(r, t), s = 0, o = e.length; o > s;) {
            var u = s + o >>> 1;
            n.call(r, e[u]) < i ? s = u + 1 : o = u
        }
        return s
    },
    x.toArray = function(e) {
        return e ? x.isArray(e) ? u.call(e) : e.length === +e.length ? x.map(e, x.identity) : x.values(e) : []
    },
    x.size = function(e) {
        return null == e ? 0 : e.length === +e.length ? e.length: x.keys(e).length
    },
    x.first = x.head = x.take = function(e, t, n) {
        return null == e ? void 0 : null == t || n ? e[0] : 0 > t ? [] : u.call(e, 0, t)
    },
    x.initial = function(e, t, n) {
        return u.call(e, 0, e.length - (null == t || n ? 1 : t))
    },
    x.last = function(e, t, n) {
        return null == e ? void 0 : null == t || n ? e[e.length - 1] : u.call(e, Math.max(e.length - t, 0))
    },
    x.rest = x.tail = x.drop = function(e, t, n) {
        return u.call(e, null == t || n ? 1 : t)
    },
    x.compact = function(e) {
        return x.filter(e, x.identity)
    };
    var A = function(e, t, n) {
        return t && x.every(e, x.isArray) ? a.apply(n, e) : (T(e,
        function(e) {
            x.isArray(e) || x.isArguments(e) ? t ? o.apply(n, e) : A(e, t, n) : n.push(e)
        }), n)
    };
    x.flatten = function(e, t) {
        return A(e, t, [])
    },
    x.without = function(e) {
        return x.difference(e, u.call(arguments, 1))
    },
    x.partition = function(e, t) {
        var n = [],
        r = [];
        return T(e,
        function(e) { (t(e) ? n: r).push(e)
        }),
        [n, r]
    },
    x.uniq = x.unique = function(e, t, n, r) {
        x.isFunction(t) && (r = n, n = t, t = !1);
        var i = n ? x.map(e, n, r) : e,
        s = [],
        o = [];
        return T(i,
        function(n, r) { (t ? r && o[o.length - 1] === n: x.contains(o, n)) || (o.push(n), s.push(e[r]))
        }),
        s
    },
    x.union = function() {
        return x.uniq(x.flatten(arguments, !0))
    },
    x.intersection = function(e) {
        var t = u.call(arguments, 1);
        return x.filter(x.uniq(e),
        function(e) {
            return x.every(t,
            function(t) {
                return x.contains(t, e)
            })
        })
    },
    x.difference = function(e) {
        var t = a.apply(r, u.call(arguments, 1));
        return x.filter(e,
        function(e) {
            return ! x.contains(t, e)
        })
    },
    x.zip = function() {
        for (var e = x.max(x.pluck(arguments, "length").concat(0)), t = new Array(e), n = 0; e > n; n++) t[n] = x.pluck(arguments, "" + n);
        return t
    },
    x.object = function(e, t) {
        if (null == e) return {};
        for (var n = {},
        r = 0,
        i = e.length; i > r; r++) t ? n[e[r]] = t[r] : n[e[r][0]] = e[r][1];
        return n
    },
    x.indexOf = function(e, t, n) {
        if (null == e) return - 1;
        var r = 0,
        i = e.length;
        if (n) {
            if ("number" != typeof n) return r = x.sortedIndex(e, t),
            e[r] === t ? r: -1;
            r = 0 > n ? Math.max(0, i + n) : n
        }
        if (y && e.indexOf === y) return e.indexOf(t, n);
        for (; i > r; r++) if (e[r] === t) return r;
        return - 1
    },
    x.lastIndexOf = function(e, t, n) {
        if (null == e) return - 1;
        var r = null != n;
        if (b && e.lastIndexOf === b) return r ? e.lastIndexOf(t, n) : e.lastIndexOf(t);
        for (var i = r ? n: e.length; i--;) if (e[i] === t) return i;
        return - 1
    },
    x.range = function(e, t, n) {
        arguments.length <= 1 && (t = e || 0, e = 0),
        n = arguments[2] || 1;
        for (var r = Math.max(Math.ceil((t - e) / n), 0), i = 0, s = new Array(r); r > i;) s[i++] = e,
        e += n;
        return s
    };
    var O = function() {};
    x.bind = function(e, t) {
        var n, r;
        if (S && e.bind === S) return S.apply(e, u.call(arguments, 1));
        if (!x.isFunction(e)) throw new TypeError;
        return n = u.call(arguments, 2),
        r = function() {
            if (this instanceof r) {
                O.prototype = e.prototype;
                var i = new O;
                O.prototype = null;
                var s = e.apply(i, n.concat(u.call(arguments)));
                return Object(s) === s ? s: i
            }
            return e.apply(t, n.concat(u.call(arguments)))
        }
    },
    x.partial = function(e) {
        var t = u.call(arguments, 1);
        return function() {
            for (var n = 0,
            r = t.slice(), i = 0, s = r.length; s > i; i++) r[i] === x && (r[i] = arguments[n++]);
            for (; n < arguments.length;) r.push(arguments[n++]);
            return e.apply(this, r)
        }
    },
    x.bindAll = function(e) {
        var t = u.call(arguments, 1);
        if (0 === t.length) throw new Error("bindAll must be passed function names");
        return T(t,
        function(t) {
            e[t] = x.bind(e[t], e)
        }),
        e
    },
    x.memoize = function(e, t) {
        var n = {};
        return t || (t = x.identity),
        function() {
            var r = t.apply(this, arguments);
            return x.has(n, r) ? n[r] : n[r] = e.apply(this, arguments)
        }
    },
    x.delay = function(e, t) {
        var n = u.call(arguments, 2);
        return setTimeout(function() {
            return e.apply(null, n)
        },
        t)
    },
    x.defer = function(e) {
        return x.delay.apply(x, [e, 1].concat(u.call(arguments, 1)))
    },
    x.throttle = function(e, t, n) {
        var r, i, s, o = null,
        u = 0;
        n || (n = {});
        var a = function() {
            u = n.leading === !1 ? 0 : x.now(),
            o = null,
            s = e.apply(r, i),
            r = i = null
        };
        return function() {
            var f = x.now();
            u || n.leading !== !1 || (u = f);
            var l = t - (f - u);
            return r = this,
            i = arguments,
            0 >= l ? (clearTimeout(o), o = null, u = f, s = e.apply(r, i), r = i = null) : o || n.trailing === !1 || (o = setTimeout(a, l)),
            s
        }
    },
    x.debounce = function(e, t, n) {
        var r, i, s, o, u, a = function() {
            var f = x.now() - o;
            t > f ? r = setTimeout(a, t - f) : (r = null, n || (u = e.apply(s, i), s = i = null))
        };
        return function() {
            s = this,
            i = arguments,
            o = x.now();
            var f = n && !r;
            return r || (r = setTimeout(a, t)),
            f && (u = e.apply(s, i), s = i = null),
            u
        }
    },
    x.once = function(e) {
        var t, n = !1;
        return function() {
            return n ? t: (n = !0, t = e.apply(this, arguments), e = null, t)
        }
    },
    x.wrap = function(e, t) {
        return x.partial(t, e)
    },
    x.compose = function() {
        var e = arguments;
        return function() {
            for (var t = arguments,
            n = e.length - 1; n >= 0; n--) t = [e[n].apply(this, t)];
            return t[0]
        }
    },
    x.after = function(e, t) {
        return function() {
            return--e < 1 ? t.apply(this, arguments) : void 0
        }
    },
    x.keys = function(e) {
        if (!x.isObject(e)) return [];
        if (E) return E(e);
        var t = [];
        for (var n in e) x.has(e, n) && t.push(n);
        return t
    },
    x.values = function(e) {
        for (var t = x.keys(e), n = t.length, r = new Array(n), i = 0; n > i; i++) r[i] = e[t[i]];
        return r
    },
    x.pairs = function(e) {
        for (var t = x.keys(e), n = t.length, r = new Array(n), i = 0; n > i; i++) r[i] = [t[i], e[t[i]]];
        return r
    },
    x.invert = function(e) {
        for (var t = {},
        n = x.keys(e), r = 0, i = n.length; i > r; r++) t[e[n[r]]] = n[r];
        return t
    },
    x.functions = x.methods = function(e) {
        var t = [];
        for (var n in e) x.isFunction(e[n]) && t.push(n);
        return t.sort()
    },
    x.extend = function(e) {
        return T(u.call(arguments, 1),
        function(t) {
            if (t) for (var n in t) e[n] = t[n]
        }),
        e
    },
    x.pick = function(e) {
        var t = {},
        n = a.apply(r, u.call(arguments, 1));
        return T(n,
        function(n) {
            n in e && (t[n] = e[n])
        }),
        t
    },
    x.omit = function(e) {
        var t = {},
        n = a.apply(r, u.call(arguments, 1));
        for (var i in e) x.contains(n, i) || (t[i] = e[i]);
        return t
    },
    x.defaults = function(e) {
        return T(u.call(arguments, 1),
        function(t) {
            if (t) for (var n in t) e[n] === void 0 && (e[n] = t[n])
        }),
        e
    },
    x.clone = function(e) {
        return x.isObject(e) ? x.isArray(e) ? e.slice() : x.extend({},
        e) : e
    },
    x.tap = function(e, t) {
        return t(e),
        e
    };
    var M = function(e, t, n, r) {
        if (e === t) return 0 !== e || 1 / e == 1 / t;
        if (null == e || null == t) return e === t;
        e instanceof x && (e = e._wrapped),
        t instanceof x && (t = t._wrapped);
        var i = f.call(e);
        if (i != f.call(t)) return ! 1;
        switch (i) {
        case "[object String]":
            return e == String(t);
        case "[object Number]":
            return e != +e ? t != +t: 0 == e ? 1 / e == 1 / t: e == +t;
        case "[object Date]":
        case "[object Boolean]":
            return + e == +t;
        case "[object RegExp]":
            return e.source == t.source && e.global == t.global && e.multiline == t.multiline && e.ignoreCase == t.ignoreCase
        }
        if ("object" != typeof e || "object" != typeof t) return ! 1;
        for (var s = n.length; s--;) if (n[s] == e) return r[s] == t;
        var o = e.constructor,
        u = t.constructor;
        if (o !== u && !(x.isFunction(o) && o instanceof o && x.isFunction(u) && u instanceof u) && "constructor" in e && "constructor" in t) return ! 1;
        n.push(e),
        r.push(t);
        var a = 0,
        l = !0;
        if ("[object Array]" == i) {
            if (a = e.length, l = a == t.length) for (; a--&&(l = M(e[a], t[a], n, r)););
        } else {
            for (var c in e) if (x.has(e, c) && (a++, !(l = x.has(t, c) && M(e[c], t[c], n, r)))) break;
            if (l) {
                for (c in t) if (x.has(t, c) && !(a--)) break;
                l = !a
            }
        }
        return n.pop(),
        r.pop(),
        l
    };
    x.isEqual = function(e, t) {
        return M(e, t, [], [])
    },
    x.isEmpty = function(e) {
        if (null == e) return ! 0;
        if (x.isArray(e) || x.isString(e)) return 0 === e.length;
        for (var t in e) if (x.has(e, t)) return ! 1;
        return ! 0
    },
    x.isElement = function(e) {
        return !! e && 1 === e.nodeType
    },
    x.isArray = w ||
    function(e) {
        return "[object Array]" == f.call(e)
    },
    x.isObject = function(e) {
        return e === Object(e)
    },
    T(["Arguments", "Function", "String", "Number", "Date", "RegExp"],
    function(e) {
        x["is" + e] = function(t) {
            return f.call(t) == "[object " + e + "]"
        }
    }),
    x.isArguments(arguments) || (x.isArguments = function(e) {
        return !! e && !!x.has(e, "callee")
    }),
    "function" != typeof / . / &&(x.isFunction = function(e) {
        return "function" == typeof e
    }),
    x.isFinite = function(e) {
        return isFinite(e) && !isNaN(parseFloat(e))
    },
    x.isNaN = function(e) {
        return x.isNumber(e) && e != +e
    },
    x.isBoolean = function(e) {
        return e === !0 || e === !1 || "[object Boolean]" == f.call(e)
    },
    x.isNull = function(e) {
        return null === e
    },
    x.isUndefined = function(e) {
        return e === void 0
    },
    x.has = function(e, t) {
        return l.call(e, t)
    },
    x.noConflict = function() {
        return e._ = t,
        this
    },
    x.identity = function(e) {
        return e
    },
    x.constant = function(e) {
        return function() {
            return e
        }
    },
    x.property = function(e) {
        return function(t) {
            return t[e]
        }
    },
    x.matches = function(e) {
        return function(t) {
            if (t === e) return ! 0;
            for (var n in e) if (e[n] !== t[n]) return ! 1;
            return ! 0
        }
    },
    x.times = function(e, t, n) {
        for (var r = Array(Math.max(0, e)), i = 0; e > i; i++) r[i] = t.call(n, i);
        return r
    },
    x.random = function(e, t) {
        return null == t && (t = e, e = 0),
        e + Math.floor(Math.random() * (t - e + 1))
    },
    x.now = Date.now ||
    function() {
        return (new Date).getTime()
    };
    var _ = {
        escape: {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;"
        }
    };
    _.unescape = x.invert(_.escape);
    var D = {
        escape: new RegExp("[" + x.keys(_.escape).join("") + "]", "g"),
        unescape: new RegExp("(" + x.keys(_.unescape).join("|") + ")", "g")
    };
    x.each(["escape", "unescape"],
    function(e) {
        x[e] = function(t) {
            return null == t ? "": ("" + t).replace(D[e],
            function(t) {
                return _[e][t]
            })
        }
    }),
    x.result = function(e, t) {
        if (null == e) return void 0;
        var n = e[t];
        return x.isFunction(n) ? n.call(e) : n
    },
    x.mixin = function(e) {
        T(x.functions(e),
        function(t) {
            var n = x[t] = e[t];
            x.prototype[t] = function() {
                var e = [this._wrapped];
                return o.apply(e, arguments),
                F.call(this, n.apply(x, e))
            }
        })
    };
    var P = 0;
    x.uniqueId = function(e) {
        var t = ++P + "";
        return e ? e + t: t
    },
    x.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };
    var H = /(.)^/,
    B = {
        "'": "'",
        "\\": "\\",
        "\r": "r",
        "\n": "n",
        "	": "t",
        "\u2028": "u2028",
        "\u2029": "u2029"
    },
    j = /\\|'|\r|\n|\t|\u2028|\u2029/g;
    x.template = function(e, t, n) {
        var r;
        n = x.defaults({},
        n, x.templateSettings);
        var i = new RegExp([(n.escape || H).source, (n.interpolate || H).source, (n.evaluate || H).source].join("|") + "|$", "g"),
        s = 0,
        o = "__p+='";
        e.replace(i,
        function(t, n, r, i, u) {
            return o += e.slice(s, u).replace(j,
            function(e) {
                return "\\" + B[e]
            }),
            n && (o += "'+\n((__t=(" + n + "))==null?'':_.escape(__t))+\n'"),
            r && (o += "'+\n((__t=(" + r + "))==null?'':__t)+\n'"),
            i && (o += "';\n" + i + "\n__p+='"),
            s = u + t.length,
            t
        }),
        o += "';\n",
        n.variable || (o = "with(obj||{}){\n" + o + "}\n"),
        o = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + o + "return __p;\n";
        try {
            r = new Function(n.variable || "obj", "_", o)
        } catch(u) {
            throw u.source = o,
            u
        }
        if (t) return r(t, x);
        var a = function(e) {
            return r.call(this, e, x)
        };
        return a.source = "function(" + (n.variable || "obj") + "){\n" + o + "}",
        a
    },
    x.chain = function(e) {
        return x(e).chain()
    };
    var F = function(e) {
        return this._chain ? x(e).chain() : e
    };
    x.mixin(x),
    T(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"],
    function(e) {
        var t = r[e];
        x.prototype[e] = function() {
            var n = this._wrapped;
            return t.apply(n, arguments),
            "shift" != e && "splice" != e || 0 !== n.length || delete n[0],
            F.call(this, n)
        }
    }),
    T(["concat", "join", "slice"],
    function(e) {
        var t = r[e];
        x.prototype[e] = function() {
            return F.call(this, t.apply(this._wrapped, arguments))
        }
    }),
    x.extend(x.prototype, {
        chain: function() {
            return this._chain = !0,
            this
        },
        value: function() {
            return this._wrapped
        }
    }),
    "function" == typeof define && define.amd && define("underscore", [],
    function() {
        return x
    })
}.call(this),
function(e, t) {
    if (typeof define == "function" && define.amd) define("backbone", ["underscore", "jquery", "exports"],
    function(n, r, i) {
        e.Backbone = t(e, i, n, r)
    });
    else if (typeof exports != "undefined") {
        var n = require("underscore");
        t(e, exports, n)
    } else e.Backbone = t(e, {},
    e._, e.jQuery || e.Zepto || e.ender || e.$)
} (this,
function(e, t, n, r) {
    var i = e.Backbone,
    s = [],
    o = s.push,
    u = s.slice,
    a = s.splice;
    t.VERSION = "1.1.2",
    t.$ = r,
    t.noConflict = function() {
        return e.Backbone = i,
        this
    },
    t.emulateHTTP = !1,
    t.emulateJSON = !1;
    var f = t.Events = {
        on: function(e, t, n) {
            if (!c(this, "on", e, [t, n]) || !t) return this;
            this._events || (this._events = {});
            var r = this._events[e] || (this._events[e] = []);
            return r.push({
                callback: t,
                context: n,
                ctx: n || this
            }),
            this
        },
        once: function(e, t, r) {
            if (!c(this, "once", e, [t, r]) || !t) return this;
            var i = this,
            s = n.once(function() {
                i.off(e, s),
                t.apply(this, arguments)
            });
            return s._callback = t,
            this.on(e, s, r)
        },
        off: function(e, t, r) {
            var i, s, o, u, a, f, l, h;
            if (!this._events || !c(this, "off", e, [t, r])) return this;
            if (!e && !t && !r) return this._events = void 0,
            this;
            u = e ? [e] : n.keys(this._events);
            for (a = 0, f = u.length; a < f; a++) {
                e = u[a];
                if (o = this._events[e]) {
                    this._events[e] = i = [];
                    if (t || r) for (l = 0, h = o.length; l < h; l++) s = o[l],
                    (t && t !== s.callback && t !== s.callback._callback || r && r !== s.context) && i.push(s);
                    i.length || delete this._events[e]
                }
            }
            return this
        },
        trigger: function(e) {
            if (!this._events) return this;
            var t = u.call(arguments, 1);
            if (!c(this, "trigger", e, t)) return this;
            var n = this._events[e],
            r = this._events.all;
            return n && h(n, t),
            r && h(r, arguments),
            this
        },
        stopListening: function(e, t, r) {
            var i = this._listeningTo;
            if (!i) return this;
            var s = !t && !r; ! r && typeof t == "object" && (r = this),
            e && ((i = {})[e._listenId] = e);
            for (var o in i) e = i[o],
            e.off(t, r, this),
            (s || n.isEmpty(e._events)) && delete this._listeningTo[o];
            return this
        }
    },
    l = /\s+/,
    c = function(e, t, n, r) {
        if (!n) return ! 0;
        if (typeof n == "object") {
            for (var i in n) e[t].apply(e, [i, n[i]].concat(r));
            return ! 1
        }
        if (l.test(n)) {
            var s = n.split(l);
            for (var o = 0,
            u = s.length; o < u; o++) e[t].apply(e, [s[o]].concat(r));
            return ! 1
        }
        return ! 0
    },
    h = function(e, t) {
        var n, r = -1,
        i = e.length,
        s = t[0],
        o = t[1],
        u = t[2];
        switch (t.length) {
        case 0:
            while (++r < i)(n = e[r]).callback.call(n.ctx);
            return;
        case 1:
            while (++r < i)(n = e[r]).callback.call(n.ctx, s);
            return;
        case 2:
            while (++r < i)(n = e[r]).callback.call(n.ctx, s, o);
            return;
        case 3:
            while (++r < i)(n = e[r]).callback.call(n.ctx, s, o, u);
            return;
        default:
            while (++r < i)(n = e[r]).callback.apply(n.ctx, t);
            return
        }
    },
    p = {
        listenTo: "on",
        listenToOnce: "once"
    };
    n.each(p,
    function(e, t) {
        f[t] = function(t, r, i) {
            var s = this._listeningTo || (this._listeningTo = {}),
            o = t._listenId || (t._listenId = n.uniqueId("l"));
            return s[o] = t,
            !i && typeof r == "object" && (i = this),
            t[e](r, i, this),
            this
        }
    }),
    f.bind = f.on,
    f.unbind = f.off,
    n.extend(t, f);
    var d = t.Model = function(e, t) {
        var r = e || {};
        t || (t = {}),
        this.cid = n.uniqueId("c"),
        this.attributes = {},
        t.collection && (this.collection = t.collection),
        t.parse && (r = this.parse(r, t) || {}),
        r = n.defaults({},
        r, n.result(this, "defaults")),
        this.set(r, t),
        this.changed = {},
        this.initialize.apply(this, arguments)
    };
    n.extend(d.prototype, f, {
        changed: null,
        validationError: null,
        idAttribute: "id",
        initialize: function() {},
        toJSON: function(e) {
            return n.clone(this.attributes)
        },
        sync: function() {
            return t.sync.apply(this, arguments)
        },
        get: function(e) {
            return this.attributes[e]
        },
        escape: function(e) {
            return n.escape(this.get(e))
        },
        has: function(e) {
            return this.get(e) != null
        },
        set: function(e, t, r) {
            var i, s, o, u, a, f, l, c;
            if (e == null) return this;
            typeof e == "object" ? (s = e, r = t) : (s = {})[e] = t,
            r || (r = {});
            if (!this._validate(s, r)) return ! 1;
            o = r.unset,
            a = r.silent,
            u = [],
            f = this._changing,
            this._changing = !0,
            f || (this._previousAttributes = n.clone(this.attributes), this.changed = {}),
            c = this.attributes,
            l = this._previousAttributes,
            this.idAttribute in s && (this.id = s[this.idAttribute]);
            for (i in s) t = s[i],
            n.isEqual(c[i], t) || u.push(i),
            n.isEqual(l[i], t) ? delete this.changed[i] : this.changed[i] = t,
            o ? delete c[i] : c[i] = t;
            if (!a) {
                u.length && (this._pending = r);
                for (var h = 0,
                p = u.length; h < p; h++) this.trigger("change:" + u[h], this, c[u[h]], r)
            }
            if (f) return this;
            if (!a) while (this._pending) r = this._pending,
            this._pending = !1,
            this.trigger("change", this, r);
            return this._pending = !1,
            this._changing = !1,
            this
        },
        unset: function(e, t) {
            return this.set(e, void 0, n.extend({},
            t, {
                unset: !0
            }))
        },
        clear: function(e) {
            var t = {};
            for (var r in this.attributes) t[r] = void 0;
            return this.set(t, n.extend({},
            e, {
                unset: !0
            }))
        },
        hasChanged: function(e) {
            return e == null ? !n.isEmpty(this.changed) : n.has(this.changed, e)
        },
        changedAttributes: function(e) {
            if (!e) return this.hasChanged() ? n.clone(this.changed) : !1;
            var t, r = !1,
            i = this._changing ? this._previousAttributes: this.attributes;
            for (var s in e) {
                if (n.isEqual(i[s], t = e[s])) continue; (r || (r = {}))[s] = t
            }
            return r
        },
        previous: function(e) {
            return e == null || !this._previousAttributes ? null: this._previousAttributes[e]
        },
        previousAttributes: function() {
            return n.clone(this._previousAttributes)
        },
        fetch: function(e) {
            e = e ? n.clone(e) : {},
            e.parse === void 0 && (e.parse = !0);
            var t = this,
            r = e.success;
            return e.success = function(n) {
                if (!t.set(t.parse(n, e), e)) return ! 1;
                r && r(t, n, e),
                t.trigger("sync", t, n, e)
            },
            I(this, e),
            this.sync("read", this, e)
        },
        save: function(e, t, r) {
            var i, s, o, u = this.attributes;
            e == null || typeof e == "object" ? (i = e, r = t) : (i = {})[e] = t,
            r = n.extend({
                validate: !0
            },
            r);
            if (i && !r.wait) {
                if (!this.set(i, r)) return ! 1
            } else if (!this._validate(i, r)) return ! 1;
            i && r.wait && (this.attributes = n.extend({},
            u, i)),
            r.parse === void 0 && (r.parse = !0);
            var a = this,
            f = r.success;
            return r.success = function(e) {
                a.attributes = u;
                var t = a.parse(e, r);
                r.wait && (t = n.extend(i || {},
                t));
                if (n.isObject(t) && !a.set(t, r)) return ! 1;
                f && f(a, e, r),
                a.trigger("sync", a, e, r)
            },
            I(this, r),
            s = this.isNew() ? "create": r.patch ? "patch": "update",
            s === "patch" && (r.attrs = i),
            o = this.sync(s, this, r),
            i && r.wait && (this.attributes = u),
            o
        },
        destroy: function(e) {
            e = e ? n.clone(e) : {};
            var t = this,
            r = e.success,
            i = function() {
                t.trigger("destroy", t, t.collection, e)
            };
            e.success = function(n) { (e.wait || t.isNew()) && i(),
                r && r(t, n, e),
                t.isNew() || t.trigger("sync", t, n, e)
            };
            if (this.isNew()) return e.success(),
            !1;
            I(this, e);
            var s = this.sync("delete", this, e);
            return e.wait || i(),
            s
        },
        url: function() {
            var e = n.result(this, "urlRoot") || n.result(this.collection, "url") || F();
            return this.isNew() ? e: e.replace(/([^\/])$/, "$1/") + encodeURIComponent(this.id)
        },
        parse: function(e, t) {
            return e
        },
        clone: function() {
            return new this.constructor(this.attributes)
        },
        isNew: function() {
            return ! this.has(this.idAttribute)
        },
        isValid: function(e) {
            return this._validate({},
            n.extend(e || {},
            {
                validate: !0
            }))
        },
        _validate: function(e, t) {
            if (!t.validate || !this.validate) return ! 0;
            e = n.extend({},
            this.attributes, e);
            var r = this.validationError = this.validate(e, t) || null;
            return r ? (this.trigger("invalid", this, r, n.extend(t, {
                validationError: r
            })), !1) : !0
        }
    });
    var v = ["keys", "values", "pairs", "invert", "pick", "omit"];
    n.each(v,
    function(e) {
        d.prototype[e] = function() {
            var t = u.call(arguments);
            return t.unshift(this.attributes),
            n[e].apply(n, t)
        }
    });
    var m = t.Collection = function(e, t) {
        t || (t = {}),
        t.model && (this.model = t.model),
        t.comparator !== void 0 && (this.comparator = t.comparator),
        this._reset(),
        this.initialize.apply(this, arguments),
        e && this.reset(e, n.extend({
            silent: !0
        },
        t))
    },
    g = {
        add: !0,
        remove: !0,
        merge: !0
    },
    y = {
        add: !0,
        remove: !1
    };
    n.extend(m.prototype, f, {
        model: d,
        initialize: function() {},
        toJSON: function(e) {
            return this.map(function(t) {
                return t.toJSON(e)
            })
        },
        sync: function() {
            return t.sync.apply(this, arguments)
        },
        add: function(e, t) {
            return this.set(e, n.extend({
                merge: !1
            },
            t, y))
        },
        remove: function(e, t) {
            var r = !n.isArray(e);
            e = r ? [e] : n.clone(e),
            t || (t = {});
            var i, s, o, u;
            for (i = 0, s = e.length; i < s; i++) {
                u = e[i] = this.get(e[i]);
                if (!u) continue;
                delete this._byId[u.id],
                delete this._byId[u.cid],
                o = this.indexOf(u),
                this.models.splice(o, 1),
                this.length--,
                t.silent || (t.index = o, u.trigger("remove", u, this, t)),
                this._removeReference(u, t)
            }
            return r ? e[0] : e
        },
        set: function(e, t) {
            t = n.defaults({},
            t, g),
            t.parse && (e = this.parse(e, t));
            var r = !n.isArray(e);
            e = r ? e ? [e] : [] : n.clone(e);
            var i, s, o, u, a, f, l, c = t.at,
            h = this.model,
            p = this.comparator && c == null && t.sort !== !1,
            v = n.isString(this.comparator) ? this.comparator: null,
            m = [],
            y = [],
            b = {},
            w = t.add,
            E = t.merge,
            S = t.remove,
            x = !p && w && S ? [] : !1;
            for (i = 0, s = e.length; i < s; i++) {
                a = e[i] || {},
                a instanceof d ? o = u = a: o = a[h.prototype.idAttribute || "id"];
                if (f = this.get(o)) S && (b[f.cid] = !0),
                E && (a = a === u ? u.attributes: a, t.parse && (a = f.parse(a, t)), f.set(a, t), p && !l && f.hasChanged(v) && (l = !0)),
                e[i] = f;
                else if (w) {
                    u = e[i] = this._prepareModel(a, t);
                    if (!u) continue;
                    m.push(u),
                    this._addReference(u, t)
                }
                u = f || u,
                x && (u.isNew() || !b[u.id]) && x.push(u),
                b[u.id] = !0
            }
            if (S) {
                for (i = 0, s = this.length; i < s; ++i) b[(u = this.models[i]).cid] || y.push(u);
                y.length && this.remove(y, t)
            }
            if (m.length || x && x.length) {
                p && (l = !0),
                this.length += m.length;
                if (c != null) for (i = 0, s = m.length; i < s; i++) this.models.splice(c + i, 0, m[i]);
                else {
                    x && (this.models.length = 0);
                    var T = x || m;
                    for (i = 0, s = T.length; i < s; i++) this.models.push(T[i])
                }
            }
            l && this.sort({
                silent: !0
            });
            if (!t.silent) {
                for (i = 0, s = m.length; i < s; i++)(u = m[i]).trigger("add", u, this, t); (l || x && x.length) && this.trigger("sort", this, t)
            }
            return r ? e[0] : e
        },
        reset: function(e, t) {
            t || (t = {});
            for (var r = 0,
            i = this.models.length; r < i; r++) this._removeReference(this.models[r], t);
            return t.previousModels = this.models,
            this._reset(),
            e = this.add(e, n.extend({
                silent: !0
            },
            t)),
            t.silent || this.trigger("reset", this, t),
            e
        },
        push: function(e, t) {
            return this.add(e, n.extend({
                at: this.length
            },
            t))
        },
        pop: function(e) {
            var t = this.at(this.length - 1);
            return this.remove(t, e),
            t
        },
        unshift: function(e, t) {
            return this.add(e, n.extend({
                at: 0
            },
            t))
        },
        shift: function(e) {
            var t = this.at(0);
            return this.remove(t, e),
            t
        },
        slice: function() {
            return u.apply(this.models, arguments)
        },
        get: function(e) {
            return e == null ? void 0 : this._byId[e] || this._byId[e.id] || this._byId[e.cid]
        },
        at: function(e) {
            return this.models[e]
        },
        where: function(e, t) {
            return n.isEmpty(e) ? t ? void 0 : [] : this[t ? "find": "filter"](function(t) {
                for (var n in e) if (e[n] !== t.get(n)) return ! 1;
                return ! 0
            })
        },
        findWhere: function(e) {
            return this.where(e, !0)
        },
        sort: function(e) {
            if (!this.comparator) throw new Error("Cannot sort a set without a comparator");
            return e || (e = {}),
            n.isString(this.comparator) || this.comparator.length === 1 ? this.models = this.sortBy(this.comparator, this) : this.models.sort(n.bind(this.comparator, this)),
            e.silent || this.trigger("sort", this, e),
            this
        },
        pluck: function(e) {
            return n.invoke(this.models, "get", e)
        },
        fetch: function(e) {
            e = e ? n.clone(e) : {},
            e.parse === void 0 && (e.parse = !0);
            var t = e.success,
            r = this;
            return e.success = function(n) {
                var i = e.reset ? "reset": "set";
                r[i](n, e),
                t && t(r, n, e),
                r.trigger("sync", r, n, e)
            },
            I(this, e),
            this.sync("read", this, e)
        },
        create: function(e, t) {
            t = t ? n.clone(t) : {};
            if (! (e = this._prepareModel(e, t))) return ! 1;
            t.wait || this.add(e, t);
            var r = this,
            i = t.success;
            return t.success = function(e, n) {
                t.wait && r.add(e, t),
                i && i(e, n, t)
            },
            e.save(null, t),
            e
        },
        parse: function(e, t) {
            return e
        },
        clone: function() {
            return new this.constructor(this.models)
        },
        _reset: function() {
            this.length = 0,
            this.models = [],
            this._byId = {}
        },
        _prepareModel: function(e, t) {
            if (e instanceof d) return e;
            t = t ? n.clone(t) : {},
            t.collection = this;
            var r = new this.model(e, t);
            return r.validationError ? (this.trigger("invalid", this, r.validationError, t), !1) : r
        },
        _addReference: function(e, t) {
            this._byId[e.cid] = e,
            e.id != null && (this._byId[e.id] = e),
            e.collection || (e.collection = this),
            e.on("all", this._onModelEvent, this)
        },
        _removeReference: function(e, t) {
            this === e.collection && delete e.collection,
            e.off("all", this._onModelEvent, this)
        },
        _onModelEvent: function(e, t, n, r) {
            if ((e === "add" || e === "remove") && n !== this) return;
            e === "destroy" && this.remove(t, r),
            t && e === "change:" + t.idAttribute && (delete this._byId[t.previous(t.idAttribute)], t.id != null && (this._byId[t.id] = t)),
            this.trigger.apply(this, arguments)
        }
    });
    var b = ["forEach", "each", "map", "collect", "reduce", "foldl", "inject", "reduceRight", "foldr", "find", "detect", "filter", "select", "reject", "every", "all", "some", "any", "include", "contains", "invoke", "max", "min", "toArray", "size", "first", "head", "take", "initial", "rest", "tail", "drop", "last", "without", "difference", "indexOf", "shuffle", "lastIndexOf", "isEmpty", "chain", "sample"];
    n.each(b,
    function(e) {
        m.prototype[e] = function() {
            var t = u.call(arguments);
            return t.unshift(this.models),
            n[e].apply(n, t)
        }
    });
    var w = ["groupBy", "countBy", "sortBy", "indexBy"];
    n.each(w,
    function(e) {
        m.prototype[e] = function(t, r) {
            var i = n.isFunction(t) ? t: function(e) {
                return e.get(t)
            };
            return n[e](this.models, i, r)
        }
    });
    var E = t.View = function(e) {
        this.cid = n.uniqueId("view"),
        e || (e = {}),
        n.extend(this, n.pick(e, x)),
        this._ensureElement(),
        this.initialize.apply(this, arguments),
        this.delegateEvents()
    },
    S = /^(\S+)\s*(.*)$/,
    x = ["model", "collection", "el", "id", "attributes", "className", "tagName", "events"];
    n.extend(E.prototype, f, {
        tagName: "div",
        $: function(e) {
            return this.$el.find(e)
        },
        initialize: function() {},
        render: function() {
            return this
        },
        remove: function() {
            return this.$el.remove(),
            this.stopListening(),
            this
        },
        setElement: function(e, n) {
            return this.$el && this.undelegateEvents(),
            this.$el = e instanceof t.$ ? e: t.$(e),
            this.el = this.$el[0],
            n !== !1 && this.delegateEvents(),
            this
        },
        delegateEvents: function(e) {
            if (!e && !(e = n.result(this, "events"))) return this;
            this.undelegateEvents();
            for (var t in e) {
                var r = e[t];
                n.isFunction(r) || (r = this[e[t]]);
                if (!r) continue;
                var i = t.match(S),
                s = i[1],
                o = i[2];
                r = n.bind(r, this),
                s += ".delegateEvents" + this.cid,
                o === "" ? this.$el.on(s, r) : this.$el.on(s, o, r)
            }
            return this
        },
        undelegateEvents: function() {
            return this.$el.off(".delegateEvents" + this.cid),
            this
        },
        _ensureElement: function() {
            if (!this.el) {
                var e = n.extend({},
                n.result(this, "attributes"));
                this.id && (e.id = n.result(this, "id")),
                this.className && (e["class"] = n.result(this, "className"));
                var r = t.$("<" + n.result(this, "tagName") + ">").attr(e);
                this.setElement(r, !1)
            } else this.setElement(n.result(this, "el"), !1)
        }
    }),
    t.sync = function(e, r, i) {
        var s = N[e];
        n.defaults(i || (i = {}), {
            emulateHTTP: t.emulateHTTP,
            emulateJSON: t.emulateJSON
        });
        var o = {
            type: s,
            dataType: "json"
        };
        i.url || (o.url = n.result(r, "url") || F()),
        i.data == null && r && (e === "create" || e === "update" || e === "patch") && (o.contentType = "application/json", o.data = JSON.stringify(i.attrs || r.toJSON(i))),
        i.emulateJSON && (o.contentType = "application/x-www-form-urlencoded", o.data = o.data ? {
            model: o.data
        }: {});
        if (i.emulateHTTP && (s === "PUT" || s === "DELETE" || s === "PATCH")) {
            o.type = "POST",
            i.emulateJSON && (o.data._method = s);
            var u = i.beforeSend;
            i.beforeSend = function(e) {
                e.setRequestHeader("X-HTTP-Method-Override", s);
                if (u) return u.apply(this, arguments)
            }
        }
        o.type !== "GET" && !i.emulateJSON && (o.processData = !1),
        o.type === "PATCH" && T && (o.xhr = function() {
            return new ActiveXObject("Microsoft.XMLHTTP")
        });
        var a = i.xhr = t.ajax(n.extend(o, i));
        return r.trigger("request", r, a, i),
        a
    };
    var T = typeof window != "undefined" && !!window.ActiveXObject && (!window.XMLHttpRequest || !(new XMLHttpRequest).dispatchEvent),
    N = {
        create: "POST",
        update: "PUT",
        patch: "PATCH",
        "delete": "DELETE",
        read: "GET"
    };
    t.ajax = function() {
        return t.$.ajax.apply(t.$, arguments)
    };
    var C = t.Router = function(e) {
        e || (e = {}),
        e.routes && (this.routes = e.routes),
        this._bindRoutes(),
        this.initialize.apply(this, arguments)
    },
    k = /\((.*?)\)/g,
    L = /(\(\?)?:\w+/g,
    A = /\*\w+/g,
    O = /[\-{}\[\]+?.,\\\^$|#\s]/g;
    n.extend(C.prototype, f, {
        initialize: function() {},
        route: function(e, r, i) {
            n.isRegExp(e) || (e = this._routeToRegExp(e)),
            n.isFunction(r) && (i = r, r = ""),
            i || (i = this[r]);
            var s = this;
            return t.history.route(e,
            function(n) {
                var o = s._extractParameters(e, n);
                s.execute(i, o),
                s.trigger.apply(s, ["route:" + r].concat(o)),
                s.trigger("route", r, o),
                t.history.trigger("route", s, r, o)
            }),
            this
        },
        execute: function(e, t) {
            e && e.apply(this, t)
        },
        navigate: function(e, n) {
            return t.history.navigate(e, n),
            this
        },
        _bindRoutes: function() {
            if (!this.routes) return;
            this.routes = n.result(this, "routes");
            var e, t = n.keys(this.routes);
            while ((e = t.pop()) != null) this.route(e, this.routes[e])
        },
        _routeToRegExp: function(e) {
            return e = e.replace(O, "\\$&").replace(k, "(?:$1)?").replace(L,
            function(e, t) {
                return t ? e: "([^/?]+)"
            }).replace(A, "([^?]*?)"),
            new RegExp("^" + e + "(?:\\?([\\s\\S]*))?$")
        },
        _extractParameters: function(e, t) {
            var r = e.exec(t).slice(1);
            return n.map(r,
            function(e, t) {
                return t === r.length - 1 ? e || null: e ? decodeURIComponent(e) : null
            })
        }
    });
    var M = t.History = function() {
        this.handlers = [],
        n.bindAll(this, "checkUrl"),
        typeof window != "undefined" && (this.location = window.location, this.history = window.history)
    },
    _ = /^[#\/]|\s+$/g,
    D = /^\/+|\/+$/g,
    P = /msie [\w.]+/,
    H = /\/$/,
    B = /#.*$/;
    M.started = !1,
    n.extend(M.prototype, f, {
        interval: 50,
        atRoot: function() {
            return this.location.pathname.replace(/[^\/]$/, "$&/") === this.root
        },
        getHash: function(e) {
            var t = (e || this).location.href.match(/#(.*)$/);
            return t ? t[1] : ""
        },
        getFragment: function(e, t) {
            if (e == null) if (this._hasPushState || !this._wantsHashChange || t) {
                e = decodeURI(this.location.pathname + this.location.search);
                var n = this.root.replace(H, "");
                e.indexOf(n) || (e = e.slice(n.length))
            } else e = this.getHash();
            return e.replace(_, "")
        },
        start: function(e) {
            if (M.started) throw new Error("Backbone.history has already been started");
            M.started = !0,
            this.options = n.extend({
                root: "/"
            },
            this.options, e),
            this.root = this.options.root,
            this._wantsHashChange = this.options.hashChange !== !1,
            this._wantsPushState = !!this.options.pushState,
            this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
            var r = this.getFragment(),
            i = document.documentMode,
            s = P.exec(navigator.userAgent.toLowerCase()) && (!i || i <= 7);
            this.root = ("/" + this.root + "/").replace(D, "/");
            if (s && this._wantsHashChange) {
                var o = t.$('<iframe src="javascript:0" tabindex="-1">');
                this.iframe = o.hide().appendTo("body")[0].contentWindow,
                this.navigate(r)
            }
            this._hasPushState ? t.$(window).on("popstate", this.checkUrl) : this._wantsHashChange && "onhashchange" in window && !s ? t.$(window).on("hashchange", this.checkUrl) : this._wantsHashChange && (this._checkUrlInterval = setInterval(this.checkUrl, this.interval)),
            this.fragment = r;
            var u = this.location;
            if (this._wantsHashChange && this._wantsPushState) {
                if (!this._hasPushState && !this.atRoot()) return this.fragment = this.getFragment(null, !0),
                this.location.replace(this.root + "#" + this.fragment),
                !0;
                this._hasPushState && this.atRoot() && u.hash && (this.fragment = this.getHash().replace(_, ""), this.history.replaceState({},
                document.title, this.root + this.fragment))
            }
            if (!this.options.silent) return this.loadUrl()
        },
        stop: function() {
            t.$(window).off("popstate", this.checkUrl).off("hashchange", this.checkUrl),
            this._checkUrlInterval && clearInterval(this._checkUrlInterval),
            M.started = !1
        },
        route: function(e, t) {
            this.handlers.unshift({
                route: e,
                callback: t
            })
        },
        checkUrl: function(e) {
            var t = this.getFragment();
            t === this.fragment && this.iframe && (t = this.getFragment(this.getHash(this.iframe)));
            if (t === this.fragment) return ! 1;
            this.iframe && this.navigate(t),
            this.loadUrl()
        },
        loadUrl: function(e) {
            return e = this.fragment = this.getFragment(e),
            n.any(this.handlers,
            function(t) {
                if (t.route.test(e)) return t.callback(e),
                !0
            })
        },
        navigate: function(e, t) {
            if (!M.started) return ! 1;
            if (!t || t === !0) t = {
                trigger: !!t
            };
            var n = this.root + (e = this.getFragment(e || ""));
            e = e.replace(B, "");
            if (this.fragment === e) return;
            this.fragment = e,
            e === "" && n !== "/" && (n = n.slice(0, -1));
            if (this._hasPushState) this.history[t.replace ? "replaceState": "pushState"]({},
            document.title, n);
            else {
                if (!this._wantsHashChange) return this.location.assign(n);
                this._updateHash(this.location, e, t.replace),
                this.iframe && e !== this.getFragment(this.getHash(this.iframe)) && (t.replace || this.iframe.document.open().close(), this._updateHash(this.iframe.location, e, t.replace))
            }
            if (t.trigger) return this.loadUrl(e)
        },
        _updateHash: function(e, t, n) {
            if (n) {
                var r = e.href.replace(/(javascript:|#).*$/, "");
                e.replace(r + "#" + t)
            } else e.hash = "#" + t
        }
    }),
    t.history = new M;
    var j = function(e, t) {
        var r = this,
        i;
        e && n.has(e, "constructor") ? i = e.constructor: i = function() {
            return r.apply(this, arguments)
        },
        n.extend(i, r, t);
        var s = function() {
            this.constructor = i
        };
        return s.prototype = r.prototype,
        i.prototype = new s,
        e && n.extend(i.prototype, e),
        i.__super__ = r.prototype,
        i
    };
    d.extend = m.extend = C.extend = E.extend = M.extend = j;
    var F = function() {
        throw new Error('A "url" property or function must be specified')
    },
    I = function(e, t) {
        var n = t.error;
        t.error = function(r) {
            n && n(e, r, t),
            e.trigger("error", e, r, t)
        }
    };
    return t
});
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global: this || window; (_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
    _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"],
    function(e, t, n) {
        var r = function(e) {
            var t, n = [],
            r = e.length;
            for (t = 0; t !== r; n.push(e[t++]));
            return n
        },
        i = function(e, t, n) {
            var r, i, s = e.cycle;
            for (r in s) i = s[r],
            e[r] = "function" == typeof i ? i.call(t[n], n) : i[n % i.length];
            delete e.cycle
        },
        s = function(e, t, r) {
            n.call(this, e, t, r),
            this._cycle = 0,
            this._yoyo = this.vars.yoyo === !0,
            this._repeat = this.vars.repeat || 0,
            this._repeatDelay = this.vars.repeatDelay || 0,
            this._dirty = !0,
            this.render = s.prototype.render
        },
        o = 1e-10,
        u = n._internals,
        a = u.isSelector,
        f = u.isArray,
        l = s.prototype = n.to({},
        .1, {}),
        c = [];
        s.version = "1.18.2",
        l.constructor = s,
        l.kill()._gc = !1,
        s.killTweensOf = s.killDelayedCallsTo = n.killTweensOf,
        s.getTweensOf = n.getTweensOf,
        s.lagSmoothing = n.lagSmoothing,
        s.ticker = n.ticker,
        s.render = n.render,
        l.invalidate = function() {
            return this._yoyo = this.vars.yoyo === !0,
            this._repeat = this.vars.repeat || 0,
            this._repeatDelay = this.vars.repeatDelay || 0,
            this._uncache(!0),
            n.prototype.invalidate.call(this)
        },
        l.updateTo = function(e, t) {
            var r, i = this.ratio,
            s = this.vars.immediateRender || e.immediateRender;
            t && this._startTime < this._timeline._time && (this._startTime = this._timeline._time, this._uncache(!1), this._gc ? this._enabled(!0, !1) : this._timeline.insert(this, this._startTime - this._delay));
            for (r in e) this.vars[r] = e[r];
            if (this._initted || s) if (t) this._initted = !1,
            s && this.render(0, !0, !0);
            else if (this._gc && this._enabled(!0, !1), this._notifyPluginsOfEnabled && this._firstPT && n._onPluginEvent("_onDisable", this), this._time / this._duration > .998) {
                var o = this._totalTime;
                this.render(0, !0, !1),
                this._initted = !1,
                this.render(o, !0, !1)
            } else if (this._initted = !1, this._init(), this._time > 0 || s) for (var u, a = 1 / (1 - i), f = this._firstPT; f;) u = f.s + f.c,
            f.c *= a,
            f.s = u - f.c,
            f = f._next;
            return this
        },
        l.render = function(e, t, n) {
            this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
            var r, i, s, a, f, l, c, h, p = this._dirty ? this.totalDuration() : this._totalDuration,
            d = this._time,
            v = this._totalTime,
            m = this._cycle,
            y = this._duration,
            b = this._rawPrevTime;
            if (e >= p - 1e-7 ? (this._totalTime = p, this._cycle = this._repeat, this._yoyo && 0 !== (1 & this._cycle) ? (this._time = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0) : (this._time = y, this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1), this._reversed || (r = !0, i = "onComplete", n = n || this._timeline.autoRemoveChildren), 0 === y && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (e = 0), (0 > b || 0 >= e && e >= -1e-7 || b === o && "isPause" !== this.data) && b !== e && (n = !0, b > o && (i = "onReverseComplete")), this._rawPrevTime = h = !t || e || b === e ? e: o)) : 1e-7 > e ? (this._totalTime = this._time = this._cycle = 0, this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0, (0 !== v || 0 === y && b > 0) && (i = "onReverseComplete", r = this._reversed), 0 > e && (this._active = !1, 0 === y && (this._initted || !this.vars.lazy || n) && (b >= 0 && (n = !0), this._rawPrevTime = h = !t || e || b === e ? e: o)), this._initted || (n = !0)) : (this._totalTime = this._time = e, 0 !== this._repeat && (a = y + this._repeatDelay, this._cycle = this._totalTime / a >> 0, 0 !== this._cycle && this._cycle === this._totalTime / a && this._cycle--, this._time = this._totalTime - this._cycle * a, this._yoyo && 0 !== (1 & this._cycle) && (this._time = y - this._time), this._time > y ? this._time = y: this._time < 0 && (this._time = 0)), this._easeType ? (f = this._time / y, l = this._easeType, c = this._easePower, (1 === l || 3 === l && f >= .5) && (f = 1 - f), 3 === l && (f *= 2), 1 === c ? f *= f: 2 === c ? f *= f * f: 3 === c ? f *= f * f * f: 4 === c && (f *= f * f * f * f), 1 === l ? this.ratio = 1 - f: 2 === l ? this.ratio = f: this._time / y < .5 ? this.ratio = f / 2 : this.ratio = 1 - f / 2) : this.ratio = this._ease.getRatio(this._time / y)), d === this._time && !n && m === this._cycle) return void(v !== this._totalTime && this._onUpdate && (t || this._callback("onUpdate")));
            if (!this._initted) {
                if (this._init(), !this._initted || this._gc) return;
                if (!n && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = d,
                this._totalTime = v,
                this._rawPrevTime = b,
                this._cycle = m,
                u.lazyTweens.push(this),
                void(this._lazy = [e, t]);
                this._time && !r ? this.ratio = this._ease.getRatio(this._time / y) : r && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
            }
            for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== d && e >= 0 && (this._active = !0), 0 === v && (2 === this._initted && e > 0 && this._init(), this._startAt && (e >= 0 ? this._startAt.render(e, t, n) : i || (i = "_dummyGS")), this.vars.onStart && (0 !== this._totalTime || 0 === y) && (t || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s,
            s = s._next;
            this._onUpdate && (0 > e && this._startAt && this._startTime && this._startAt.render(e, t, n), t || (this._totalTime !== v || r) && this._callback("onUpdate")),
            this._cycle !== m && (t || this._gc || this.vars.onRepeat && this._callback("onRepeat")),
            i && (!this._gc || n) && (0 > e && this._startAt && !this._onUpdate && this._startTime && this._startAt.render(e, t, n), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[i] && this._callback(i), 0 === y && this._rawPrevTime === o && h !== o && (this._rawPrevTime = 0))
        },
        s.to = function(e, t, n) {
            return new s(e, t, n)
        },
        s.from = function(e, t, n) {
            return n.runBackwards = !0,
            n.immediateRender = 0 != n.immediateRender,
            new s(e, t, n)
        },
        s.fromTo = function(e, t, n, r) {
            return r.startAt = n,
            r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender,
            new s(e, t, r)
        },
        s.staggerTo = s.allTo = function(e, t, o, u, l, h, p) {
            u = u || 0;
            var d, v, m, g, y = 0,
            b = [],
            w = function() {
                o.onComplete && o.onComplete.apply(o.onCompleteScope || this, arguments),
                l.apply(p || o.callbackScope || this, h || c)
            },
            E = o.cycle,
            S = o.startAt && o.startAt.cycle;
            for (f(e) || ("string" == typeof e && (e = n.selector(e) || e), a(e) && (e = r(e))), e = e || [], 0 > u && (e = r(e), e.reverse(), u *= -1), d = e.length - 1, m = 0; d >= m; m++) {
                v = {};
                for (g in o) v[g] = o[g];
                if (E && i(v, e, m), S) {
                    S = v.startAt = {};
                    for (g in o.startAt) S[g] = o.startAt[g];
                    i(v.startAt, e, m)
                }
                v.delay = y + (v.delay || 0),
                m === d && l && (v.onComplete = w),
                b[m] = new s(e[m], t, v),
                y += u
            }
            return b
        },
        s.staggerFrom = s.allFrom = function(e, t, n, r, i, o, u) {
            return n.runBackwards = !0,
            n.immediateRender = 0 != n.immediateRender,
            s.staggerTo(e, t, n, r, i, o, u)
        },
        s.staggerFromTo = s.allFromTo = function(e, t, n, r, i, o, u, a) {
            return r.startAt = n,
            r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender,
            s.staggerTo(e, t, r, i, o, u, a)
        },
        s.delayedCall = function(e, t, n, r, i) {
            return new s(t, 0, {
                delay: e,
                onComplete: t,
                onCompleteParams: n,
                callbackScope: r,
                onReverseComplete: t,
                onReverseCompleteParams: n,
                immediateRender: !1,
                useFrames: i,
                overwrite: 0
            })
        },
        s.set = function(e, t) {
            return new s(e, 0, t)
        },
        s.isTweening = function(e) {
            return n.getTweensOf(e, !0).length > 0
        };
        var h = function(e, t) {
            for (var r = [], i = 0, s = e._first; s;) s instanceof n ? r[i++] = s: (t && (r[i++] = s), r = r.concat(h(s, t)), i = r.length),
            s = s._next;
            return r
        },
        p = s.getAllTweens = function(t) {
            return h(e._rootTimeline, t).concat(h(e._rootFramesTimeline, t))
        };
        s.killAll = function(e, n, r, i) {
            null == n && (n = !0),
            null == r && (r = !0);
            var s, o, u, a = p(0 != i),
            f = a.length,
            l = n && r && i;
            for (u = 0; f > u; u++) o = a[u],
            (l || o instanceof t || (s = o.target === o.vars.onComplete) && r || n && !s) && (e ? o.totalTime(o._reversed ? 0 : o.totalDuration()) : o._enabled(!1, !1))
        },
        s.killChildTweensOf = function(e, t) {
            if (null != e) {
                var i, o, l, c, h, p = u.tweenLookup;
                if ("string" == typeof e && (e = n.selector(e) || e), a(e) && (e = r(e)), f(e)) for (c = e.length; --c > -1;) s.killChildTweensOf(e[c], t);
                else {
                    i = [];
                    for (l in p) for (o = p[l].target.parentNode; o;) o === e && (i = i.concat(p[l].tweens)),
                    o = o.parentNode;
                    for (h = i.length, c = 0; h > c; c++) t && i[c].totalTime(i[c].totalDuration()),
                    i[c]._enabled(!1, !1)
                }
            }
        };
        var d = function(e, n, r, i) {
            n = n !== !1,
            r = r !== !1,
            i = i !== !1;
            for (var s, o, u = p(i), a = n && r && i, f = u.length; --f > -1;) o = u[f],
            (a || o instanceof t || (s = o.target === o.vars.onComplete) && r || n && !s) && o.paused(e)
        };
        return s.pauseAll = function(e, t, n) {
            d(!0, e, t, n)
        },
        s.resumeAll = function(e, t, n) {
            d(!1, e, t, n)
        },
        s.globalTimeScale = function(t) {
            var r = e._rootTimeline,
            i = n.ticker.time;
            return arguments.length ? (t = t || o, r._startTime = i - (i - r._startTime) * r._timeScale / t, r = e._rootFramesTimeline, i = n.ticker.frame, r._startTime = i - (i - r._startTime) * r._timeScale / t, r._timeScale = e._rootTimeline._timeScale = t, t) : r._timeScale
        },
        l.progress = function(e) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - e: e) + this._cycle * (this._duration + this._repeatDelay), !1) : this._time / this.duration()
        },
        l.totalProgress = function(e) {
            return arguments.length ? this.totalTime(this.totalDuration() * e, !1) : this._totalTime / this.totalDuration()
        },
        l.time = function(e, t) {
            return arguments.length ? (this._dirty && this.totalDuration(), e > this._duration && (e = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? e = this._duration - e + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (e += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(e, t)) : this._time
        },
        l.duration = function(t) {
            return arguments.length ? e.prototype.duration.call(this, t) : this._duration
        },
        l.totalDuration = function(e) {
            return arguments.length ? -1 === this._repeat ? this: this.duration((e - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
        },
        l.repeat = function(e) {
            return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
        },
        l.repeatDelay = function(e) {
            return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
        },
        l.yoyo = function(e) {
            return arguments.length ? (this._yoyo = e, this) : this._yoyo
        },
        s
    },
    !0),
    _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"],
    function(e, t, n) {
        var r = function(e) {
            t.call(this, e),
            this._labels = {},
            this.autoRemoveChildren = this.vars.autoRemoveChildren === !0,
            this.smoothChildTiming = this.vars.smoothChildTiming === !0,
            this._sortChildren = !0,
            this._onUpdate = this.vars.onUpdate;
            var n, r, i = this.vars;
            for (r in i) n = i[r],
            a(n) && -1 !== n.join("").indexOf("{self}") && (i[r] = this._swapSelfInParams(n));
            a(i.tweens) && this.add(i.tweens, 0, i.align, i.stagger)
        },
        i = 1e-10,
        s = n._internals,
        o = r._internals = {},
        u = s.isSelector,
        a = s.isArray,
        f = s.lazyTweens,
        l = s.lazyRender,
        c = _gsScope._gsDefine.globals,
        h = function(e) {
            var t, n = {};
            for (t in e) n[t] = e[t];
            return n
        },
        p = function(e, t, n) {
            var r, i, s = e.cycle;
            for (r in s) i = s[r],
            e[r] = "function" == typeof i ? i.call(t[n], n) : i[n % i.length];
            delete e.cycle
        },
        d = o.pauseCallback = function() {},
        v = function(e) {
            var t, n = [],
            r = e.length;
            for (t = 0; t !== r; n.push(e[t++]));
            return n
        },
        m = r.prototype = new t;
        return r.version = "1.18.2",
        m.constructor = r,
        m.kill()._gc = m._forcingPlayhead = m._hasPause = !1,
        m.to = function(e, t, r, i) {
            var s = r.repeat && c.TweenMax || n;
            return t ? this.add(new s(e, t, r), i) : this.set(e, r, i)
        },
        m.from = function(e, t, r, i) {
            return this.add((r.repeat && c.TweenMax || n).from(e, t, r), i)
        },
        m.fromTo = function(e, t, r, i, s) {
            var o = i.repeat && c.TweenMax || n;
            return t ? this.add(o.fromTo(e, t, r, i), s) : this.set(e, i, s)
        },
        m.staggerTo = function(e, t, i, s, o, a, f, l) {
            var c, d, m = new r({
                onComplete: a,
                onCompleteParams: f,
                callbackScope: l,
                smoothChildTiming: this.smoothChildTiming
            }),
            g = i.cycle;
            for ("string" == typeof e && (e = n.selector(e) || e), e = e || [], u(e) && (e = v(e)), s = s || 0, 0 > s && (e = v(e), e.reverse(), s *= -1), d = 0; d < e.length; d++) c = h(i),
            c.startAt && (c.startAt = h(c.startAt), c.startAt.cycle && p(c.startAt, e, d)),
            g && p(c, e, d),
            m.to(e[d], t, c, d * s);
            return this.add(m, o)
        },
        m.staggerFrom = function(e, t, n, r, i, s, o, u) {
            return n.immediateRender = 0 != n.immediateRender,
            n.runBackwards = !0,
            this.staggerTo(e, t, n, r, i, s, o, u)
        },
        m.staggerFromTo = function(e, t, n, r, i, s, o, u, a) {
            return r.startAt = n,
            r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender,
            this.staggerTo(e, t, r, i, s, o, u, a)
        },
        m.call = function(e, t, r, i) {
            return this.add(n.delayedCall(0, e, t, r), i)
        },
        m.set = function(e, t, r) {
            return r = this._parseTimeOrLabel(r, 0, !0),
            null == t.immediateRender && (t.immediateRender = r === this._time && !this._paused),
            this.add(new n(e, 0, t), r)
        },
        r.exportRoot = function(e, t) {
            e = e || {},
            null == e.smoothChildTiming && (e.smoothChildTiming = !0);
            var i, s, o = new r(e),
            u = o._timeline;
            for (null == t && (t = !0), u._remove(o, !0), o._startTime = 0, o._rawPrevTime = o._time = o._totalTime = u._time, i = u._first; i;) s = i._next,
            t && i instanceof n && i.target === i.vars.onComplete || o.add(i, i._startTime - i._delay),
            i = s;
            return u.add(o, 0),
            o
        },
        m.add = function(i, s, o, u) {
            var f, l, c, h, p, d;
            if ("number" != typeof s && (s = this._parseTimeOrLabel(s, 0, !0, i)), !(i instanceof e)) {
                if (i instanceof Array || i && i.push && a(i)) {
                    for (o = o || "normal", u = u || 0, f = s, l = i.length, c = 0; l > c; c++) a(h = i[c]) && (h = new r({
                        tweens: h
                    })),
                    this.add(h, f),
                    "string" != typeof h && "function" != typeof h && ("sequence" === o ? f = h._startTime + h.totalDuration() / h._timeScale: "start" === o && (h._startTime -= h.delay())),
                    f += u;
                    return this._uncache(!0)
                }
                if ("string" == typeof i) return this.addLabel(i, s);
                if ("function" != typeof i) throw "Cannot add " + i + " into the timeline; it is not a tween, timeline, function, or string.";
                i = n.delayedCall(0, i)
            }
            if (t.prototype.add.call(this, i, s), (this._gc || this._time === this._duration) && !this._paused && this._duration < this.duration()) for (p = this, d = p.rawTime() > i._startTime; p._timeline;) d && p._timeline.smoothChildTiming ? p.totalTime(p._totalTime, !0) : p._gc && p._enabled(!0, !1),
            p = p._timeline;
            return this
        },
        m.remove = function(t) {
            if (t instanceof e) {
                this._remove(t, !1);
                var n = t._timeline = t.vars.useFrames ? e._rootFramesTimeline: e._rootTimeline;
                return t._startTime = (t._paused ? t._pauseTime: n._time) - (t._reversed ? t.totalDuration() - t._totalTime: t._totalTime) / t._timeScale,
                this
            }
            if (t instanceof Array || t && t.push && a(t)) {
                for (var r = t.length; --r > -1;) this.remove(t[r]);
                return this
            }
            return "string" == typeof t ? this.removeLabel(t) : this.kill(null, t)
        },
        m._remove = function(e, n) {
            t.prototype._remove.call(this, e, n);
            var r = this._last;
            return r ? this._time > r._startTime + r._totalDuration / r._timeScale && (this._time = this.duration(), this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0,
            this
        },
        m.append = function(e, t) {
            return this.add(e, this._parseTimeOrLabel(null, t, !0, e))
        },
        m.insert = m.insertMultiple = function(e, t, n, r) {
            return this.add(e, t || 0, n, r)
        },
        m.appendMultiple = function(e, t, n, r) {
            return this.add(e, this._parseTimeOrLabel(null, t, !0, e), n, r)
        },
        m.addLabel = function(e, t) {
            return this._labels[e] = this._parseTimeOrLabel(t),
            this
        },
        m.addPause = function(e, t, r, i) {
            var s = n.delayedCall(0, d, r, i || this);
            return s.vars.onComplete = s.vars.onReverseComplete = t,
            s.data = "isPause",
            this._hasPause = !0,
            this.add(s, e)
        },
        m.removeLabel = function(e) {
            return delete this._labels[e],
            this
        },
        m.getLabelTime = function(e) {
            return null != this._labels[e] ? this._labels[e] : -1
        },
        m._parseTimeOrLabel = function(t, n, r, i) {
            var s;
            if (i instanceof e && i.timeline === this) this.remove(i);
            else if (i && (i instanceof Array || i.push && a(i))) for (s = i.length; --s > -1;) i[s] instanceof e && i[s].timeline === this && this.remove(i[s]);
            if ("string" == typeof n) return this._parseTimeOrLabel(n, r && "number" == typeof t && null == this._labels[n] ? t - this.duration() : 0, r);
            if (n = n || 0, "string" != typeof t || !isNaN(t) && null == this._labels[t]) null == t && (t = this.duration());
            else {
                if (s = t.indexOf("="), -1 === s) return null == this._labels[t] ? r ? this._labels[t] = this.duration() + n: n: this._labels[t] + n;
                n = parseInt(t.charAt(s - 1) + "1", 10) * Number(t.substr(s + 1)),
                t = s > 1 ? this._parseTimeOrLabel(t.substr(0, s - 1), 0, r) : this.duration()
            }
            return Number(t) + n
        },
        m.seek = function(e, t) {
            return this.totalTime("number" == typeof e ? e: this._parseTimeOrLabel(e), t !== !1)
        },
        m.stop = function() {
            return this.paused(!0)
        },
        m.gotoAndPlay = function(e, t) {
            return this.play(e, t)
        },
        m.gotoAndStop = function(e, t) {
            return this.pause(e, t)
        },
        m.render = function(e, t, n) {
            this._gc && this._enabled(!0, !1);
            var r, s, o, u, a, c, h, p = this._dirty ? this.totalDuration() : this._totalDuration,
            d = this._time,
            v = this._startTime,
            m = this._timeScale,
            g = this._paused;
            if (e >= p - 1e-7) this._totalTime = this._time = p,
            this._reversed || this._hasPausedChild() || (s = !0, u = "onComplete", a = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 >= e && e >= -1e-7 || this._rawPrevTime < 0 || this._rawPrevTime === i) && this._rawPrevTime !== e && this._first && (a = !0, this._rawPrevTime > i && (u = "onReverseComplete"))),
            this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e: i,
            e = p + 1e-4;
            else if (1e-7 > e) if (this._totalTime = this._time = 0, (0 !== d || 0 === this._duration && this._rawPrevTime !== i && (this._rawPrevTime > 0 || 0 > e && this._rawPrevTime >= 0)) && (u = "onReverseComplete", s = this._reversed), 0 > e) this._active = !1,
            this._timeline.autoRemoveChildren && this._reversed ? (a = s = !0, u = "onReverseComplete") : this._rawPrevTime >= 0 && this._first && (a = !0),
            this._rawPrevTime = e;
            else {
                if (this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e: i, 0 === e && s) for (r = this._first; r && 0 === r._startTime;) r._duration || (s = !1),
                r = r._next;
                e = 0,
                this._initted || (a = !0)
            } else {
                if (this._hasPause && !this._forcingPlayhead && !t) {
                    if (e >= d) for (r = this._first; r && r._startTime <= e && !c;) r._duration || "isPause" !== r.data || r.ratio || 0 === r._startTime && 0 === this._rawPrevTime || (c = r),
                    r = r._next;
                    else for (r = this._last; r && r._startTime >= e && !c;) r._duration || "isPause" === r.data && r._rawPrevTime > 0 && (c = r),
                    r = r._prev;
                    c && (this._time = e = c._startTime, this._totalTime = e + this._cycle * (this._totalDuration + this._repeatDelay))
                }
                this._totalTime = this._time = this._rawPrevTime = e
            }
            if (this._time !== d && this._first || n || a || c) {
                if (this._initted || (this._initted = !0), this._active || !this._paused && this._time !== d && e > 0 && (this._active = !0), 0 === d && this.vars.onStart && 0 !== this._time && (t || this._callback("onStart")), h = this._time, h >= d) for (r = this._first; r && (o = r._next, h === this._time && (!this._paused || g));)(r._active || r._startTime <= h && !r._paused && !r._gc) && (c === r && this.pause(), r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)),
                r = o;
                else for (r = this._last; r && (o = r._prev, h === this._time && (!this._paused || g));) {
                    if (r._active || r._startTime <= d && !r._paused && !r._gc) {
                        if (c === r) {
                            for (c = r._prev; c && c.endTime() > this._time;) c.render(c._reversed ? c.totalDuration() - (e - c._startTime) * c._timeScale: (e - c._startTime) * c._timeScale, t, n),
                            c = c._prev;
                            c = null,
                            this.pause()
                        }
                        r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)
                    }
                    r = o
                }
                this._onUpdate && (t || (f.length && l(), this._callback("onUpdate"))),
                u && (this._gc || (v === this._startTime || m !== this._timeScale) && (0 === this._time || p >= this.totalDuration()) && (s && (f.length && l(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[u] && this._callback(u)))
            }
        },
        m._hasPausedChild = function() {
            for (var e = this._first; e;) {
                if (e._paused || e instanceof r && e._hasPausedChild()) return ! 0;
                e = e._next
            }
            return ! 1
        },
        m.getChildren = function(e, t, r, i) {
            i = i || -9999999999;
            for (var s = [], o = this._first, u = 0; o;) o._startTime < i || (o instanceof n ? t !== !1 && (s[u++] = o) : (r !== !1 && (s[u++] = o), e !== !1 && (s = s.concat(o.getChildren(!0, t, r)), u = s.length))),
            o = o._next;
            return s
        },
        m.getTweensOf = function(e, t) {
            var r, i, s = this._gc,
            o = [],
            u = 0;
            for (s && this._enabled(!0, !0), r = n.getTweensOf(e), i = r.length; --i > -1;)(r[i].timeline === this || t && this._contains(r[i])) && (o[u++] = r[i]);
            return s && this._enabled(!1, !0),
            o
        },
        m.recent = function() {
            return this._recent
        },
        m._contains = function(e) {
            for (var t = e.timeline; t;) {
                if (t === this) return ! 0;
                t = t.timeline
            }
            return ! 1
        },
        m.shiftChildren = function(e, t, n) {
            n = n || 0;
            for (var r, i = this._first,
            s = this._labels; i;) i._startTime >= n && (i._startTime += e),
            i = i._next;
            if (t) for (r in s) s[r] >= n && (s[r] += e);
            return this._uncache(!0)
        },
        m._kill = function(e, t) {
            if (!e && !t) return this._enabled(!1, !1);
            for (var n = t ? this.getTweensOf(t) : this.getChildren(!0, !0, !1), r = n.length, i = !1; --r > -1;) n[r]._kill(e, t) && (i = !0);
            return i
        },
        m.clear = function(e) {
            var t = this.getChildren(!1, !0, !0),
            n = t.length;
            for (this._time = this._totalTime = 0; --n > -1;) t[n]._enabled(!1, !1);
            return e !== !1 && (this._labels = {}),
            this._uncache(!0)
        },
        m.invalidate = function() {
            for (var t = this._first; t;) t.invalidate(),
            t = t._next;
            return e.prototype.invalidate.call(this)
        },
        m._enabled = function(e, n) {
            if (e === this._gc) for (var r = this._first; r;) r._enabled(e, !0),
            r = r._next;
            return t.prototype._enabled.call(this, e, n)
        },
        m.totalTime = function(t, n, r) {
            this._forcingPlayhead = !0;
            var i = e.prototype.totalTime.apply(this, arguments);
            return this._forcingPlayhead = !1,
            i
        },
        m.duration = function(e) {
            return arguments.length ? (0 !== this.duration() && 0 !== e && this.timeScale(this._duration / e), this) : (this._dirty && this.totalDuration(), this._duration)
        },
        m.totalDuration = function(e) {
            if (!arguments.length) {
                if (this._dirty) {
                    for (var t, n, r = 0,
                    i = this._last,
                    s = 999999999999; i;) t = i._prev,
                    i._dirty && i.totalDuration(),
                    i._startTime > s && this._sortChildren && !i._paused ? this.add(i, i._startTime - i._delay) : s = i._startTime,
                    i._startTime < 0 && !i._paused && (r -= i._startTime, this._timeline.smoothChildTiming && (this._startTime += i._startTime / this._timeScale), this.shiftChildren( - i._startTime, !1, -9999999999), s = 0),
                    n = i._startTime + i._totalDuration / i._timeScale,
                    n > r && (r = n),
                    i = t;
                    this._duration = this._totalDuration = r,
                    this._dirty = !1
                }
                return this._totalDuration
            }
            return e && this.totalDuration() ? this.timeScale(this._totalDuration / e) : this
        },
        m.paused = function(t) {
            if (!t) for (var n = this._first,
            r = this._time; n;) n._startTime === r && "isPause" === n.data && (n._rawPrevTime = 0),
            n = n._next;
            return e.prototype.paused.apply(this, arguments)
        },
        m.usesFrames = function() {
            for (var t = this._timeline; t._timeline;) t = t._timeline;
            return t === e._rootFramesTimeline
        },
        m.rawTime = function() {
            return this._paused ? this._totalTime: (this._timeline.rawTime() - this._startTime) * this._timeScale
        },
        r
    },
    !0),
    _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"],
    function(e, t, n) {
        var r = function(t) {
            e.call(this, t),
            this._repeat = this.vars.repeat || 0,
            this._repeatDelay = this.vars.repeatDelay || 0,
            this._cycle = 0,
            this._yoyo = this.vars.yoyo === !0,
            this._dirty = !0
        },
        i = 1e-10,
        s = t._internals,
        o = s.lazyTweens,
        u = s.lazyRender,
        a = new n(null, null, 1, 0),
        f = r.prototype = new e;
        return f.constructor = r,
        f.kill()._gc = !1,
        r.version = "1.18.2",
        f.invalidate = function() {
            return this._yoyo = this.vars.yoyo === !0,
            this._repeat = this.vars.repeat || 0,
            this._repeatDelay = this.vars.repeatDelay || 0,
            this._uncache(!0),
            e.prototype.invalidate.call(this)
        },
        f.addCallback = function(e, n, r, i) {
            return this.add(t.delayedCall(0, e, r, i), n)
        },
        f.removeCallback = function(e, t) {
            if (e) if (null == t) this._kill(null, e);
            else for (var n = this.getTweensOf(e, !1), r = n.length, i = this._parseTimeOrLabel(t); --r > -1;) n[r]._startTime === i && n[r]._enabled(!1, !1);
            return this
        },
        f.removePause = function(t) {
            return this.removeCallback(e._internals.pauseCallback, t)
        },
        f.tweenTo = function(e, n) {
            n = n || {};
            var r, i, s, o = {
                ease: a,
                useFrames: this.usesFrames(),
                immediateRender: !1
            };
            for (i in n) o[i] = n[i];
            return o.time = this._parseTimeOrLabel(e),
            r = Math.abs(Number(o.time) - this._time) / this._timeScale || .001,
            s = new t(this, r, o),
            o.onStart = function() {
                s.target.paused(!0),
                s.vars.time !== s.target.time() && r === s.duration() && s.duration(Math.abs(s.vars.time - s.target.time()) / s.target._timeScale),
                n.onStart && s._callback("onStart")
            },
            s
        },
        f.tweenFromTo = function(e, t, n) {
            n = n || {},
            e = this._parseTimeOrLabel(e),
            n.startAt = {
                onComplete: this.seek,
                onCompleteParams: [e],
                callbackScope: this
            },
            n.immediateRender = n.immediateRender !== !1;
            var r = this.tweenTo(t, n);
            return r.duration(Math.abs(r.vars.time - e) / this._timeScale || .001)
        },
        f.render = function(e, t, n) {
            this._gc && this._enabled(!0, !1);
            var r, s, a, f, l, c, p, d, v = this._dirty ? this.totalDuration() : this._totalDuration,
            m = this._duration,
            y = this._time,
            b = this._totalTime,
            w = this._startTime,
            E = this._timeScale,
            S = this._rawPrevTime,
            x = this._paused,
            T = this._cycle;
            if (e >= v - 1e-7) this._locked || (this._totalTime = v, this._cycle = this._repeat),
            this._reversed || this._hasPausedChild() || (s = !0, f = "onComplete", l = !!this._timeline.autoRemoveChildren, 0 === this._duration && (0 >= e && e >= -1e-7 || 0 > S || S === i) && S !== e && this._first && (l = !0, S > i && (f = "onReverseComplete"))),
            this._rawPrevTime = this._duration || !t || e || this._rawPrevTime === e ? e: i,
            this._yoyo && 0 !== (1 & this._cycle) ? this._time = e = 0 : (this._time = m, e = m + 1e-4);
            else if (1e-7 > e) if (this._locked || (this._totalTime = this._cycle = 0), this._time = 0, (0 !== y || 0 === m && S !== i && (S > 0 || 0 > e && S >= 0) && !this._locked) && (f = "onReverseComplete", s = this._reversed), 0 > e) this._active = !1,
            this._timeline.autoRemoveChildren && this._reversed ? (l = s = !0, f = "onReverseComplete") : S >= 0 && this._first && (l = !0),
            this._rawPrevTime = e;
            else {
                if (this._rawPrevTime = m || !t || e || this._rawPrevTime === e ? e: i, 0 === e && s) for (r = this._first; r && 0 === r._startTime;) r._duration || (s = !1),
                r = r._next;
                e = 0,
                this._initted || (l = !0)
            } else if (0 === m && 0 > S && (l = !0), this._time = this._rawPrevTime = e, this._locked || (this._totalTime = e, 0 !== this._repeat && (c = m + this._repeatDelay, this._cycle = this._totalTime / c >> 0, 0 !== this._cycle && this._cycle === this._totalTime / c && this._cycle--, this._time = this._totalTime - this._cycle * c, this._yoyo && 0 !== (1 & this._cycle) && (this._time = m - this._time), this._time > m ? (this._time = m, e = m + 1e-4) : this._time < 0 ? this._time = e = 0 : e = this._time)), this._hasPause && !this._forcingPlayhead && !t) {
                if (e = this._time, e >= y) for (r = this._first; r && r._startTime <= e && !p;) r._duration || "isPause" !== r.data || r.ratio || 0 === r._startTime && 0 === this._rawPrevTime || (p = r),
                r = r._next;
                else for (r = this._last; r && r._startTime >= e && !p;) r._duration || "isPause" === r.data && r._rawPrevTime > 0 && (p = r),
                r = r._prev;
                p && (this._time = e = p._startTime, this._totalTime = e + this._cycle * (this._totalDuration + this._repeatDelay))
            }
            if (this._cycle !== T && !this._locked) {
                var N = this._yoyo && 0 !== (1 & T),
                C = N === (this._yoyo && 0 !== (1 & this._cycle)),
                k = this._totalTime,
                L = this._cycle,
                A = this._rawPrevTime,
                O = this._time;
                if (this._totalTime = T * m, this._cycle < T ? N = !N: this._totalTime += m, this._time = y, this._rawPrevTime = 0 === m ? S - 1e-4: S, this._cycle = T, this._locked = !0, y = N ? 0 : m, this.render(y, t, 0 === m), t || this._gc || this.vars.onRepeat && this._callback("onRepeat"), y !== this._time) return;
                if (C && (y = N ? m + 1e-4: -0.0001, this.render(y, !0, !1)), this._locked = !1, this._paused && !x) return;
                this._time = O,
                this._totalTime = k,
                this._cycle = L,
                this._rawPrevTime = A
            }
            if (! (this._time !== y && this._first || n || l || p)) return void(b !== this._totalTime && this._onUpdate && (t || this._callback("onUpdate")));
            if (this._initted || (this._initted = !0), this._active || !this._paused && this._totalTime !== b && e > 0 && (this._active = !0), 0 === b && this.vars.onStart && 0 !== this._totalTime && (t || this._callback("onStart")), d = this._time, d >= y) for (r = this._first; r && (a = r._next, d === this._time && (!this._paused || x));)(r._active || r._startTime <= this._time && !r._paused && !r._gc) && (p === r && this.pause(), r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)),
            r = a;
            else for (r = this._last; r && (a = r._prev, d === this._time && (!this._paused || x));) {
                if (r._active || r._startTime <= y && !r._paused && !r._gc) {
                    if (p === r) {
                        for (p = r._prev; p && p.endTime() > this._time;) p.render(p._reversed ? p.totalDuration() - (e - p._startTime) * p._timeScale: (e - p._startTime) * p._timeScale, t, n),
                        p = p._prev;
                        p = null,
                        this.pause()
                    }
                    r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (e - r._startTime) * r._timeScale, t, n) : r.render((e - r._startTime) * r._timeScale, t, n)
                }
                r = a
            }
            this._onUpdate && (t || (o.length && u(), this._callback("onUpdate"))),
            f && (this._locked || this._gc || (w === this._startTime || E !== this._timeScale) && (0 === this._time || v >= this.totalDuration()) && (s && (o.length && u(), this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[f] && this._callback(f)))
        },
        f.getActive = function(e, t, n) {
            null == e && (e = !0),
            null == t && (t = !0),
            null == n && (n = !1);
            var r, i, s = [],
            o = this.getChildren(e, t, n),
            u = 0,
            a = o.length;
            for (r = 0; a > r; r++) i = o[r],
            i.isActive() && (s[u++] = i);
            return s
        },
        f.getLabelAfter = function(e) {
            e || 0 !== e && (e = this._time);
            var t, n = this.getLabelsArray(),
            r = n.length;
            for (t = 0; r > t; t++) if (n[t].time > e) return n[t].name;
            return null
        },
        f.getLabelBefore = function(e) {
            null == e && (e = this._time);
            for (var t = this.getLabelsArray(), n = t.length; --n > -1;) if (t[n].time < e) return t[n].name;
            return null
        },
        f.getLabelsArray = function() {
            var e, t = [],
            n = 0;
            for (e in this._labels) t[n++] = {
                time: this._labels[e],
                name: e
            };
            return t.sort(function(e, t) {
                return e.time - t.time
            }),
            t
        },
        f.progress = function(e, t) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 !== (1 & this._cycle) ? 1 - e: e) + this._cycle * (this._duration + this._repeatDelay), t) : this._time / this.duration()
        },
        f.totalProgress = function(e, t) {
            return arguments.length ? this.totalTime(this.totalDuration() * e, t) : this._totalTime / this.totalDuration()
        },
        f.totalDuration = function(t) {
            return arguments.length ? -1 !== this._repeat && t ? this.timeScale(this.totalDuration() / t) : this: (this._dirty && (e.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
        },
        f.time = function(e, t) {
            return arguments.length ? (this._dirty && this.totalDuration(), e > this._duration && (e = this._duration), this._yoyo && 0 !== (1 & this._cycle) ? e = this._duration - e + this._cycle * (this._duration + this._repeatDelay) : 0 !== this._repeat && (e += this._cycle * (this._duration + this._repeatDelay)), this.totalTime(e, t)) : this._time
        },
        f.repeat = function(e) {
            return arguments.length ? (this._repeat = e, this._uncache(!0)) : this._repeat
        },
        f.repeatDelay = function(e) {
            return arguments.length ? (this._repeatDelay = e, this._uncache(!0)) : this._repeatDelay
        },
        f.yoyo = function(e) {
            return arguments.length ? (this._yoyo = e, this) : this._yoyo
        },
        f.currentLabel = function(e) {
            return arguments.length ? this.seek(e, !0) : this.getLabelBefore(this._time + 1e-8)
        },
        r
    },
    !0),
    function() {
        var e = 180 / Math.PI,
        t = [],
        n = [],
        r = [],
        i = {},
        s = _gsScope._gsDefine.globals,
        o = function(e, t, n, r) {
            this.a = e,
            this.b = t,
            this.c = n,
            this.d = r,
            this.da = r - e,
            this.ca = n - e,
            this.ba = t - e
        },
        u = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
        a = function(e, t, n, r) {
            var i = {
                a: e
            },
            s = {},
            o = {},
            u = {
                c: r
            },
            a = (e + t) / 2,
            f = (t + n) / 2,
            l = (n + r) / 2,
            c = (a + f) / 2,
            h = (f + l) / 2,
            p = (h - c) / 8;
            return i.b = a + (e - a) / 4,
            s.b = c + p,
            i.c = s.a = (i.b + s.b) / 2,
            s.c = o.a = (c + h) / 2,
            o.b = h - p,
            u.b = l + (r - l) / 4,
            o.c = u.a = (o.b + u.b) / 2,
            [i, s, o, u]
        },
        f = function(e, i, s, o, u) {
            var f, l, c, h, p, d, v, m, g, y, w, E, S, x = e.length - 1,
            T = 0,
            N = e[0].a;
            for (f = 0; x > f; f++) p = e[T],
            l = p.a,
            c = p.d,
            h = e[T + 1].d,
            u ? (w = t[f], E = n[f], S = (E + w) * i * .25 / (o ? .5 : r[f] || .5), d = c - (c - l) * (o ? .5 * i: 0 !== w ? S / w: 0), v = c + (h - c) * (o ? .5 * i: 0 !== E ? S / E: 0), m = c - (d + ((v - d) * (3 * w / (w + E) + .5) / 4 || 0))) : (d = c - (c - l) * i * .5, v = c + (h - c) * i * .5, m = c - (d + v) / 2),
            d += m,
            v += m,
            p.c = g = d,
            0 !== f ? p.b = N: p.b = N = p.a + .6 * (p.c - p.a),
            p.da = c - l,
            p.ca = g - l,
            p.ba = N - l,
            s ? (y = a(l, N, g, c), e.splice(T, 1, y[0], y[1], y[2], y[3]), T += 4) : T++,
            N = v;
            p = e[T],
            p.b = N,
            p.c = N + .4 * (p.d - N),
            p.da = p.d - p.a,
            p.ca = p.c - p.a,
            p.ba = N - p.a,
            s && (y = a(p.a, N, p.c, p.d), e.splice(T, 1, y[0], y[1], y[2], y[3]))
        },
        l = function(e, r, i, s) {
            var u, a, f, l, c, h, p = [];
            if (s) for (e = [s].concat(e), a = e.length; --a > -1;)"string" == typeof(h = e[a][r]) && "=" === h.charAt(1) && (e[a][r] = s[r] + Number(h.charAt(0) + h.substr(2)));
            if (u = e.length - 2, 0 > u) return p[0] = new o(e[0][r], 0, 0, e[ - 1 > u ? 0 : 1][r]),
            p;
            for (a = 0; u > a; a++) f = e[a][r],
            l = e[a + 1][r],
            p[a] = new o(f, 0, 0, l),
            i && (c = e[a + 2][r], t[a] = (t[a] || 0) + (l - f) * (l - f), n[a] = (n[a] || 0) + (c - l) * (c - l));
            return p[a] = new o(e[a][r], 0, 0, e[a + 1][r]),
            p
        },
        c = function(e, s, o, a, c, h) {
            var p, d, v, m, g, y, w, E, S = {},
            x = [],
            T = h || e[0];
            c = "string" == typeof c ? "," + c + ",": u,
            null == s && (s = 1);
            for (d in e[0]) x.push(d);
            if (e.length > 1) {
                for (E = e[e.length - 1], w = !0, p = x.length; --p > -1;) if (d = x[p], Math.abs(T[d] - E[d]) > .05) {
                    w = !1;
                    break
                }
                w && (e = e.concat(), h && e.unshift(h), e.push(e[1]), h = e[e.length - 3])
            }
            for (t.length = n.length = r.length = 0, p = x.length; --p > -1;) d = x[p],
            i[d] = -1 !== c.indexOf("," + d + ","),
            S[d] = l(e, d, i[d], h);
            for (p = t.length; --p > -1;) t[p] = Math.sqrt(t[p]),
            n[p] = Math.sqrt(n[p]);
            if (!a) {
                for (p = x.length; --p > -1;) if (i[d]) for (v = S[x[p]], y = v.length - 1, m = 0; y > m; m++) g = v[m + 1].da / n[m] + v[m].da / t[m],
                r[m] = (r[m] || 0) + g * g;
                for (p = r.length; --p > -1;) r[p] = Math.sqrt(r[p])
            }
            for (p = x.length, m = o ? 4 : 1; --p > -1;) d = x[p],
            v = S[d],
            f(v, s, o, a, i[d]),
            w && (v.splice(0, m), v.splice(v.length - m, m));
            return S
        },
        h = function(e, t, n) {
            t = t || "soft";
            var r, i, s, u, a, f, l, c, h, p, d, v = {},
            m = "cubic" === t ? 3 : 2,
            y = "soft" === t,
            b = [];
            if (y && n && (e = [n].concat(e)), null == e || e.length < m + 1) throw "invalid Bezier data";
            for (h in e[0]) b.push(h);
            for (f = b.length; --f > -1;) {
                for (h = b[f], v[h] = a = [], p = 0, c = e.length, l = 0; c > l; l++) r = null == n ? e[l][h] : "string" == typeof(d = e[l][h]) && "=" === d.charAt(1) ? n[h] + Number(d.charAt(0) + d.substr(2)) : Number(d),
                y && l > 1 && c - 1 > l && (a[p++] = (r + a[p - 2]) / 2),
                a[p++] = r;
                for (c = p - m + 1, p = 0, l = 0; c > l; l += m) r = a[l],
                i = a[l + 1],
                s = a[l + 2],
                u = 2 === m ? 0 : a[l + 3],
                a[p++] = d = 3 === m ? new o(r, i, s, u) : new o(r, (2 * i + r) / 3, (2 * i + s) / 3, s);
                a.length = p
            }
            return v
        },
        p = function(e, t, n) {
            for (var r, i, s, o, u, a, f, l, c, h, p, d = 1 / n,
            v = e.length; --v > -1;) for (h = e[v], s = h.a, o = h.d - s, u = h.c - s, a = h.b - s, r = i = 0, l = 1; n >= l; l++) f = d * l,
            c = 1 - f,
            r = i - (i = (f * f * o + 3 * c * (f * u + c * a)) * f),
            p = v * n + l - 1,
            t[p] = (t[p] || 0) + r * r
        },
        d = function(e, t) {
            t = t >> 0 || 6;
            var n, r, i, s, o = [],
            u = [],
            a = 0,
            f = 0,
            l = t - 1,
            c = [],
            h = [];
            for (n in e) p(e[n], o, t);
            for (i = o.length, r = 0; i > r; r++) a += Math.sqrt(o[r]),
            s = r % t,
            h[s] = a,
            s === l && (f += a, s = r / t >> 0, c[s] = h, u[s] = f, a = 0, h = []);
            return {
                length: f,
                lengths: u,
                segments: c
            }
        },
        v = _gsScope._gsDefine.plugin({
            propName: "bezier",
            priority: -1,
            version: "1.3.4",
            API: 2,
            global: !0,
            init: function(e, t, n) {
                this._target = e,
                t instanceof Array && (t = {
                    values: t
                }),
                this._func = {},
                this._round = {},
                this._props = [],
                this._timeRes = null == t.timeResolution ? 6 : parseInt(t.timeResolution, 10);
                var r, i, s, o, u, a = t.values || [],
                f = {},
                l = a[0],
                p = t.autoRotate || n.vars.orientToBezier;
                this._autoRotate = p ? p instanceof Array ? p: [["x", "y", "rotation", p === !0 ? 0 : Number(p) || 0]] : null;
                for (r in l) this._props.push(r);
                for (s = this._props.length; --s > -1;) r = this._props[s],
                this._overwriteProps.push(r),
                i = this._func[r] = "function" == typeof e[r],
                f[r] = i ? e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r: "get" + r.substr(3)]() : parseFloat(e[r]),
                u || f[r] !== a[0][r] && (u = f);
                if (this._beziers = "cubic" !== t.type && "quadratic" !== t.type && "soft" !== t.type ? c(a, isNaN(t.curviness) ? 1 : t.curviness, !1, "thruBasic" === t.type, t.correlate, u) : h(a, t.type, f), this._segCount = this._beziers[r].length, this._timeRes) {
                    var v = d(this._beziers, this._timeRes);
                    this._length = v.length,
                    this._lengths = v.lengths,
                    this._segments = v.segments,
                    this._l1 = this._li = this._s1 = this._si = 0,
                    this._l2 = this._lengths[0],
                    this._curSeg = this._segments[0],
                    this._s2 = this._curSeg[0],
                    this._prec = 1 / this._curSeg.length
                }
                if (p = this._autoRotate) for (this._initialRotations = [], p[0] instanceof Array || (this._autoRotate = p = [p]), s = p.length; --s > -1;) {
                    for (o = 0; 3 > o; o++) r = p[s][o],
                    this._func[r] = "function" == typeof e[r] ? e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r: "get" + r.substr(3)] : !1;
                    r = p[s][2],
                    this._initialRotations[s] = this._func[r] ? this._func[r].call(this._target) : this._target[r]
                }
                return this._startRatio = n.vars.runBackwards ? 1 : 0,
                !0
            },
            set: function(t) {
                var n, r, i, s, o, u, a, f, l, c, h = this._segCount,
                p = this._func,
                d = this._target,
                v = t !== this._startRatio;
                if (this._timeRes) {
                    if (l = this._lengths, c = this._curSeg, t *= this._length, i = this._li, t > this._l2 && h - 1 > i) {
                        for (f = h - 1; f > i && (this._l2 = l[++i]) <= t;);
                        this._l1 = l[i - 1],
                        this._li = i,
                        this._curSeg = c = this._segments[i],
                        this._s2 = c[this._s1 = this._si = 0]
                    } else if (t < this._l1 && i > 0) {
                        for (; i > 0 && (this._l1 = l[--i]) >= t;);
                        0 === i && t < this._l1 ? this._l1 = 0 : i++,
                        this._l2 = l[i],
                        this._li = i,
                        this._curSeg = c = this._segments[i],
                        this._s1 = c[(this._si = c.length - 1) - 1] || 0,
                        this._s2 = c[this._si]
                    }
                    if (n = i, t -= this._l1, i = this._si, t > this._s2 && i < c.length - 1) {
                        for (f = c.length - 1; f > i && (this._s2 = c[++i]) <= t;);
                        this._s1 = c[i - 1],
                        this._si = i
                    } else if (t < this._s1 && i > 0) {
                        for (; i > 0 && (this._s1 = c[--i]) >= t;);
                        0 === i && t < this._s1 ? this._s1 = 0 : i++,
                        this._s2 = c[i],
                        this._si = i
                    }
                    u = (i + (t - this._s1) / (this._s2 - this._s1)) * this._prec
                } else n = 0 > t ? 0 : t >= 1 ? h - 1 : h * t >> 0,
                u = (t - n * (1 / h)) * h;
                for (r = 1 - u, i = this._props.length; --i > -1;) s = this._props[i],
                o = this._beziers[s][n],
                a = (u * u * o.da + 3 * r * (u * o.ca + r * o.ba)) * u + o.a,
                this._round[s] && (a = Math.round(a)),
                p[s] ? d[s](a) : d[s] = a;
                if (this._autoRotate) {
                    var m, g, y, b, w, E, S, x = this._autoRotate;
                    for (i = x.length; --i > -1;) s = x[i][2],
                    E = x[i][3] || 0,
                    S = x[i][4] === !0 ? 1 : e,
                    o = this._beziers[x[i][0]],
                    m = this._beziers[x[i][1]],
                    o && m && (o = o[n], m = m[n], g = o.a + (o.b - o.a) * u, b = o.b + (o.c - o.b) * u, g += (b - g) * u, b += (o.c + (o.d - o.c) * u - b) * u, y = m.a + (m.b - m.a) * u, w = m.b + (m.c - m.b) * u, y += (w - y) * u, w += (m.c + (m.d - m.c) * u - w) * u, a = v ? Math.atan2(w - y, b - g) * S + E: this._initialRotations[i], p[s] ? d[s](a) : d[s] = a)
                }
            }
        }),
        m = v.prototype;
        v.bezierThrough = c,
        v.cubicToQuadratic = a,
        v._autoCSS = !0,
        v.quadraticToCubic = function(e, t, n) {
            return new o(e, (2 * t + e) / 3, (2 * t + n) / 3, n)
        },
        v._cssRegister = function() {
            var e = s.CSSPlugin;
            if (e) {
                var t = e._internals,
                n = t._parseToProxy,
                r = t._setPluginRatio,
                i = t.CSSPropTween;
                t._registerComplexSpecialProp("bezier", {
                    parser: function(e, t, s, o, u, a) {
                        t instanceof Array && (t = {
                            values: t
                        }),
                        a = new v;
                        var f, l, c, h = t.values,
                        p = h.length - 1,
                        d = [],
                        m = {};
                        if (0 > p) return u;
                        for (f = 0; p >= f; f++) c = n(e, h[f], o, u, a, p !== f),
                        d[f] = c.end;
                        for (l in t) m[l] = t[l];
                        return m.values = d,
                        u = new i(e, "bezier", 0, 0, c.pt, 2),
                        u.data = c,
                        u.plugin = a,
                        u.setRatio = r,
                        0 === m.autoRotate && (m.autoRotate = !0),
                        !m.autoRotate || m.autoRotate instanceof Array || (f = m.autoRotate === !0 ? 0 : Number(m.autoRotate), m.autoRotate = null != c.end.left ? [["left", "top", "rotation", f, !1]] : null != c.end.x ? [["x", "y", "rotation", f, !1]] : !1),
                        m.autoRotate && (o._transform || o._enableTransforms(!1), c.autoRotate = o._target._gsTransform),
                        a._onInitTween(c.proxy, m, o._tween),
                        u
                    }
                })
            }
        },
        m._roundProps = function(e, t) {
            for (var n = this._overwriteProps,
            r = n.length; --r > -1;)(e[n[r]] || e.bezier || e.bezierThrough) && (this._round[n[r]] = t)
        },
        m._kill = function(e) {
            var t, n, r = this._props;
            for (t in this._beziers) if (t in e) for (delete this._beziers[t], delete this._func[t], n = r.length; --n > -1;) r[n] === t && r.splice(n, 1);
            return this._super._kill.call(this, e)
        }
    } (),
    _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"],
    function(e, t) {
        var n, r, i, s, o = function() {
            e.call(this, "css"),
            this._overwriteProps.length = 0,
            this.setRatio = o.prototype.setRatio
        },
        u = _gsScope._gsDefine.globals,
        a = {},
        f = o.prototype = new e("css");
        f.constructor = o,
        o.version = "1.18.2",
        o.API = 2,
        o.defaultTransformPerspective = 0,
        o.defaultSkewType = "compensated",
        o.defaultSmoothOrigin = !0,
        f = "px",
        o.suffixMap = {
            top: f,
            right: f,
            bottom: f,
            left: f,
            width: f,
            height: f,
            fontSize: f,
            padding: f,
            margin: f,
            perspective: f,
            lineHeight: ""
        };
        var l, c, h, p, d, v, m = /(?:\d|\-\d|\.\d|\-\.\d)+/g,
        g = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
        y = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi,
        b = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
        w = /(?:\d|\-|\+|=|#|\.)*/g,
        E = /opacity *= *([^)]*)/i,
        S = /opacity:([^;]*)/i,
        x = /alpha\(opacity *=.+?\)/i,
        T = /^(rgb|hsl)/,
        N = /([A-Z])/g,
        C = /-([a-z])/gi,
        k = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi,
        L = function(e, t) {
            return t.toUpperCase()
        },
        A = /(?:Left|Right|Width)/i,
        O = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
        M = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i,
        _ = /,(?=[^\)]*(?:\(|$))/gi,
        D = Math.PI / 180,
        P = 180 / Math.PI,
        H = {},
        B = document,
        j = function(e) {
            return B.createElementNS ? B.createElementNS("http://www.w3.org/1999/xhtml", e) : B.createElement(e)
        },
        F = j("div"),
        I = j("img"),
        q = o._internals = {
            _specialProps: a
        },
        R = navigator.userAgent,
        U = function() {
            var e = R.indexOf("Android"),
            t = j("a");
            return h = -1 !== R.indexOf("Safari") && -1 === R.indexOf("Chrome") && ( - 1 === e || Number(R.substr(e + 8, 1)) > 3),
            d = h && Number(R.substr(R.indexOf("Version/") + 8, 1)) < 6,
            p = -1 !== R.indexOf("Firefox"),
            (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(R) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(R)) && (v = parseFloat(RegExp.$1)),
            t ? (t.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(t.style.opacity)) : !1
        } (),
        z = function(e) {
            return E.test("string" == typeof e ? e: (e.currentStyle ? e.currentStyle.filter: e.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
        },
        W = function(e) {
            window.console && console.log(e)
        },
        X = "",
        V = "",
        $ = function(e, t) {
            t = t || F;
            var n, r, i = t.style;
            if (void 0 !== i[e]) return e;
            for (e = e.charAt(0).toUpperCase() + e.substr(1), n = ["O", "Moz", "ms", "Ms", "Webkit"], r = 5; --r > -1 && void 0 === i[n[r] + e];);
            return r >= 0 ? (V = 3 === r ? "ms": n[r], X = "-" + V.toLowerCase() + "-", V + e) : null
        },
        J = B.defaultView ? B.defaultView.getComputedStyle: function() {},
        K = o.getStyle = function(e, t, n, r, i) {
            var s;
            return U || "opacity" !== t ? (!r && e.style[t] ? s = e.style[t] : (n = n || J(e)) ? s = n[t] || n.getPropertyValue(t) || n.getPropertyValue(t.replace(N, "-$1").toLowerCase()) : e.currentStyle && (s = e.currentStyle[t]), null == i || s && "none" !== s && "auto" !== s && "auto auto" !== s ? s: i) : z(e)
        },
        Q = q.convertToPixels = function(e, n, r, i, s) {
            if ("px" === i || !i) return r;
            if ("auto" === i || !r) return 0;
            var u, a, f, l = A.test(n),
            c = e,
            h = F.style,
            p = 0 > r;
            if (p && (r = -r), "%" === i && -1 !== n.indexOf("border")) u = r / 100 * (l ? e.clientWidth: e.clientHeight);
            else {
                if (h.cssText = "border:0 solid red;position:" + K(e, "position") + ";line-height:0;", "%" !== i && c.appendChild && "v" !== i.charAt(0) && "rem" !== i) h[l ? "borderLeftWidth": "borderTopWidth"] = r + i;
                else {
                    if (c = e.parentNode || B.body, a = c._gsCache, f = t.ticker.frame, a && l && a.time === f) return a.width * r / 100;
                    h[l ? "width": "height"] = r + i
                }
                c.appendChild(F),
                u = parseFloat(F[l ? "offsetWidth": "offsetHeight"]),
                c.removeChild(F),
                l && "%" === i && o.cacheWidths !== !1 && (a = c._gsCache = c._gsCache || {},
                a.time = f, a.width = u / r * 100),
                0 !== u || s || (u = Q(e, n, r, i, !0))
            }
            return p ? -u: u
        },
        G = q.calculateOffset = function(e, t, n) {
            if ("absolute" !== K(e, "position", n)) return 0;
            var r = "left" === t ? "Left": "Top",
            i = K(e, "margin" + r, n);
            return e["offset" + r] - (Q(e, t, parseFloat(i), i.replace(w, "")) || 0)
        },
        Y = function(e, t) {
            var n, r, i, s = {};
            if (t = t || J(e, null)) if (n = t.length) for (; --n > -1;) i = t[n],
            ( - 1 === i.indexOf("-transform") || Nt === i) && (s[i.replace(C, L)] = t.getPropertyValue(i));
            else for (n in t)( - 1 === n.indexOf("Transform") || Tt === n) && (s[n] = t[n]);
            else if (t = e.currentStyle || e.style) for (n in t)"string" == typeof n && void 0 === s[n] && (s[n.replace(C, L)] = t[n]);
            return U || (s.opacity = z(e)),
            r = jt(e, t, !1),
            s.rotation = r.rotation,
            s.skewX = r.skewX,
            s.scaleX = r.scaleX,
            s.scaleY = r.scaleY,
            s.x = r.x,
            s.y = r.y,
            kt && (s.z = r.z, s.rotationX = r.rotationX, s.rotationY = r.rotationY, s.scaleZ = r.scaleZ),
            s.filters && delete s.filters,
            s
        },
        Z = function(e, t, n, r, i) {
            var s, o, u, a = {},
            f = e.style;
            for (o in n)"cssText" !== o && "length" !== o && isNaN(o) && (t[o] !== (s = n[o]) || i && i[o]) && -1 === o.indexOf("Origin") && ("number" == typeof s || "string" == typeof s) && (a[o] = "auto" !== s || "left" !== o && "top" !== o ? "" !== s && "auto" !== s && "none" !== s || "string" != typeof t[o] || "" === t[o].replace(b, "") ? s: 0 : G(e, o), void 0 !== f[o] && (u = new dt(f, o, f[o], u)));
            if (r) for (o in r)"className" !== o && (a[o] = r[o]);
            return {
                difs: a,
                firstMPT: u
            }
        },
        et = {
            width: ["Left", "Right"],
            height: ["Top", "Bottom"]
        },
        tt = ["marginLeft", "marginRight", "marginTop", "marginBottom"],
        nt = function(e, t, n) {
            var r = parseFloat("width" === t ? e.offsetWidth: e.offsetHeight),
            i = et[t],
            s = i.length;
            for (n = n || J(e, null); --s > -1;) r -= parseFloat(K(e, "padding" + i[s], n, !0)) || 0,
            r -= parseFloat(K(e, "border" + i[s] + "Width", n, !0)) || 0;
            return r
        },
        rt = function(e, t) {
            if ("contain" === e || "auto" === e || "auto auto" === e) return e + " "; (null == e || "" === e) && (e = "0 0");
            var n = e.split(" "),
            r = -1 !== e.indexOf("left") ? "0%": -1 !== e.indexOf("right") ? "100%": n[0],
            i = -1 !== e.indexOf("top") ? "0%": -1 !== e.indexOf("bottom") ? "100%": n[1];
            return null == i ? i = "center" === r ? "50%": "0": "center" === i && (i = "50%"),
            ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"),
            e = r + " " + i + (n.length > 2 ? " " + n[2] : ""),
            t && (t.oxp = -1 !== r.indexOf("%"), t.oyp = -1 !== i.indexOf("%"), t.oxr = "=" === r.charAt(1), t.oyr = "=" === i.charAt(1), t.ox = parseFloat(r.replace(b, "")), t.oy = parseFloat(i.replace(b, "")), t.v = e),
            t || e
        },
        it = function(e, t) {
            return "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) : parseFloat(e) - parseFloat(t)
        },
        st = function(e, t) {
            return null == e ? t: "string" == typeof e && "=" === e.charAt(1) ? parseInt(e.charAt(0) + "1", 10) * parseFloat(e.substr(2)) + t: parseFloat(e)
        },
        ot = function(e, t, n, r) {
            var i, s, o, u, a, f = 1e-6;
            return null == e ? u = t: "number" == typeof e ? u = e: (i = 360, s = e.split("_"), a = "=" === e.charAt(1), o = (a ? parseInt(e.charAt(0) + "1", 10) * parseFloat(s[0].substr(2)) : parseFloat(s[0])) * ( - 1 === e.indexOf("rad") ? 1 : P) - (a ? 0 : t), s.length && (r && (r[n] = t + o), -1 !== e.indexOf("short") && (o %= i, o !== o % (i / 2) && (o = 0 > o ? o + i: o - i)), -1 !== e.indexOf("_cw") && 0 > o ? o = (o + 9999999999 * i) % i - (o / i | 0) * i: -1 !== e.indexOf("ccw") && o > 0 && (o = (o - 9999999999 * i) % i - (o / i | 0) * i)), u = t + o),
            f > u && u > -f && (u = 0),
            u
        },
        ut = {
            aqua: [0, 255, 255],
            lime: [0, 255, 0],
            silver: [192, 192, 192],
            black: [0, 0, 0],
            maroon: [128, 0, 0],
            teal: [0, 128, 128],
            blue: [0, 0, 255],
            navy: [0, 0, 128],
            white: [255, 255, 255],
            fuchsia: [255, 0, 255],
            olive: [128, 128, 0],
            yellow: [255, 255, 0],
            orange: [255, 165, 0],
            gray: [128, 128, 128],
            purple: [128, 0, 128],
            green: [0, 128, 0],
            red: [255, 0, 0],
            pink: [255, 192, 203],
            cyan: [0, 255, 255],
            transparent: [255, 255, 255, 0]
        },
        at = function(e, t, n) {
            return e = 0 > e ? e + 1 : e > 1 ? e - 1 : e,
            255 * (1 > 6 * e ? t + (n - t) * e * 6 : .5 > e ? n: 2 > 3 * e ? t + (n - t) * (2 / 3 - e) * 6 : t) + .5 | 0
        },
        ft = o.parseColor = function(e, t) {
            var n, r, i, s, o, u, a, f, l, c, h;
            if (e) if ("number" == typeof e) n = [e >> 16, e >> 8 & 255, 255 & e];
            else {
                if ("," === e.charAt(e.length - 1) && (e = e.substr(0, e.length - 1)), ut[e]) n = ut[e];
                else if ("#" === e.charAt(0)) 4 === e.length && (r = e.charAt(1), i = e.charAt(2), s = e.charAt(3), e = "#" + r + r + i + i + s + s),
                e = parseInt(e.substr(1), 16),
                n = [e >> 16, e >> 8 & 255, 255 & e];
                else if ("hsl" === e.substr(0, 3)) if (n = h = e.match(m), t) {
                    if ( - 1 !== e.indexOf("=")) return e.match(g)
                } else o = Number(n[0]) % 360 / 360,
                u = Number(n[1]) / 100,
                a = Number(n[2]) / 100,
                i = .5 >= a ? a * (u + 1) : a + u - a * u,
                r = 2 * a - i,
                n.length > 3 && (n[3] = Number(e[3])),
                n[0] = at(o + 1 / 3, r, i),
                n[1] = at(o, r, i),
                n[2] = at(o - 1 / 3, r, i);
                else n = e.match(m) || ut.transparent;
                n[0] = Number(n[0]),
                n[1] = Number(n[1]),
                n[2] = Number(n[2]),
                n.length > 3 && (n[3] = Number(n[3]))
            } else n = ut.black;
            return t && !h && (r = n[0] / 255, i = n[1] / 255, s = n[2] / 255, f = Math.max(r, i, s), l = Math.min(r, i, s), a = (f + l) / 2, f === l ? o = u = 0 : (c = f - l, u = a > .5 ? c / (2 - f - l) : c / (f + l), o = f === r ? (i - s) / c + (s > i ? 6 : 0) : f === i ? (s - r) / c + 2 : (r - i) / c + 4, o *= 60), n[0] = o + .5 | 0, n[1] = 100 * u + .5 | 0, n[2] = 100 * a + .5 | 0),
            n
        },
        lt = function(e, t) {
            var n, r, i, s = e.match(ct) || [],
            o = 0,
            u = s.length ? "": e;
            for (n = 0; n < s.length; n++) r = s[n],
            i = e.substr(o, e.indexOf(r, o) - o),
            o += i.length + r.length,
            r = ft(r, t),
            3 === r.length && r.push(1),
            u += i + (t ? "hsla(" + r[0] + "," + r[1] + "%," + r[2] + "%," + r[3] : "rgba(" + r.join(",")) + ")";
            return u
        },
        ct = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
        for (f in ut) ct += "|" + f + "\\b";
        ct = new RegExp(ct + ")", "gi"),
        o.colorStringFilter = function(e) {
            var t, n = e[0] + e[1];
            ct.lastIndex = 0,
            ct.test(n) && (t = -1 !== n.indexOf("hsl(") || -1 !== n.indexOf("hsla("), e[0] = lt(e[0], t), e[1] = lt(e[1], t))
        },
        t.defaultStringFilter || (t.defaultStringFilter = o.colorStringFilter);
        var ht = function(e, t, n, r) {
            if (null == e) return function(e) {
                return e
            };
            var i, s = t ? (e.match(ct) || [""])[0] : "",
            o = e.split(s).join("").match(y) || [],
            u = e.substr(0, e.indexOf(o[0])),
            a = ")" === e.charAt(e.length - 1) ? ")": "",
            f = -1 !== e.indexOf(" ") ? " ": ",",
            l = o.length,
            c = l > 0 ? o[0].replace(m, "") : "";
            return l ? i = t ?
            function(e) {
                var t, h, p, d;
                if ("number" == typeof e) e += c;
                else if (r && _.test(e)) {
                    for (d = e.replace(_, "|").split("|"), p = 0; p < d.length; p++) d[p] = i(d[p]);
                    return d.join(",")
                }
                if (t = (e.match(ct) || [s])[0], h = e.split(t).join("").match(y) || [], p = h.length, l > p--) for (; ++p < l;) h[p] = n ? h[(p - 1) / 2 | 0] : o[p];
                return u + h.join(f) + f + t + a + ( - 1 !== e.indexOf("inset") ? " inset": "")
            }: function(e) {
                var t, s, h;
                if ("number" == typeof e) e += c;
                else if (r && _.test(e)) {
                    for (s = e.replace(_, "|").split("|"), h = 0; h < s.length; h++) s[h] = i(s[h]);
                    return s.join(",")
                }
                if (t = e.match(y) || [], h = t.length, l > h--) for (; ++h < l;) t[h] = n ? t[(h - 1) / 2 | 0] : o[h];
                return u + t.join(f) + a
            }: function(e) {
                return e
            }
        },
        pt = function(e) {
            return e = e.split(","),
            function(t, n, r, i, s, o, u) {
                var a, f = (n + "").split(" ");
                for (u = {},
                a = 0; 4 > a; a++) u[e[a]] = f[a] = f[a] || f[(a - 1) / 2 >> 0];
                return i.parse(t, u, s, o)
            }
        },
        dt = (q._setPluginRatio = function(e) {
            this.plugin.setRatio(e);
            for (var t, n, r, i, s, o = this.data,
            u = o.proxy,
            a = o.firstMPT,
            f = 1e-6; a;) t = u[a.v],
            a.r ? t = Math.round(t) : f > t && t > -f && (t = 0),
            a.t[a.p] = t,
            a = a._next;
            if (o.autoRotate && (o.autoRotate.rotation = u.rotation), 1 === e || 0 === e) for (a = o.firstMPT, s = 1 === e ? "e": "b"; a;) {
                if (n = a.t, n.type) {
                    if (1 === n.type) {
                        for (i = n.xs0 + n.s + n.xs1, r = 1; r < n.l; r++) i += n["xn" + r] + n["xs" + (r + 1)];
                        n[s] = i
                    }
                } else n[s] = n.s + n.xs0;
                a = a._next
            }
        },
        function(e, t, n, r, i) {
            this.t = e,
            this.p = t,
            this.v = n,
            this.r = i,
            r && (r._prev = this, this._next = r)
        }),
        vt = (q._parseToProxy = function(e, t, n, r, i, s) {
            var o, u, a, f, l, c = r,
            h = {},
            p = {},
            d = n._transform,
            v = H;
            for (n._transform = null, H = t, r = l = n.parse(e, t, r, i), H = v, s && (n._transform = d, c && (c._prev = null, c._prev && (c._prev._next = null))); r && r !== c;) {
                if (r.type <= 1 && (u = r.p, p[u] = r.s + r.c, h[u] = r.s, s || (f = new dt(r, "s", u, f, r.r), r.c = 0), 1 === r.type)) for (o = r.l; --o > 0;) a = "xn" + o,
                u = r.p + "_" + a,
                p[u] = r.data[a],
                h[u] = r[a],
                s || (f = new dt(r, a, u, f, r.rxp[a]));
                r = r._next
            }
            return {
                proxy: h,
                end: p,
                firstMPT: f,
                pt: l
            }
        },
        q.CSSPropTween = function(e, t, r, i, o, u, a, f, l, c, h) {
            this.t = e,
            this.p = t,
            this.s = r,
            this.c = i,
            this.n = a || t,
            e instanceof vt || s.push(this.n),
            this.r = f,
            this.type = u || 0,
            l && (this.pr = l, n = !0),
            this.b = void 0 === c ? r: c,
            this.e = void 0 === h ? r + i: h,
            o && (this._next = o, o._prev = this)
        }),
        mt = function(e, t, n, r, i, s) {
            var o = new vt(e, t, n, r - n, i, -1, s);
            return o.b = n,
            o.e = o.xs0 = r,
            o
        },
        gt = o.parseComplex = function(e, t, n, r, i, s, o, u, a, f) {
            n = n || s || "",
            o = new vt(e, t, 0, 0, o, f ? 2 : 1, null, !1, u, n, r),
            r += "";
            var c, h, p, d, v, y, b, w, E, S, x, T, N, C = n.split(", ").join(",").split(" "),
            k = r.split(", ").join(",").split(" "),
            L = C.length,
            A = l !== !1;
            for (( - 1 !== r.indexOf(",") || -1 !== n.indexOf(",")) && (C = C.join(" ").replace(_, ", ").split(" "), k = k.join(" ").replace(_, ", ").split(" "), L = C.length), L !== k.length && (C = (s || "").split(" "), L = C.length), o.plugin = a, o.setRatio = f, ct.lastIndex = 0, c = 0; L > c; c++) if (d = C[c], v = k[c], w = parseFloat(d), w || 0 === w) o.appendXtra("", w, it(v, w), v.replace(g, ""), A && -1 !== v.indexOf("px"), !0);
            else if (i && ct.test(d)) T = "," === v.charAt(v.length - 1) ? "),": ")",
            N = -1 !== v.indexOf("hsl") && U,
            d = ft(d, N),
            v = ft(v, N),
            E = d.length + v.length > 6,
            E && !U && 0 === v[3] ? (o["xs" + o.l] += o.l ? " transparent": "transparent", o.e = o.e.split(k[c]).join("transparent")) : (U || (E = !1), N ? o.appendXtra(E ? "hsla(": "hsl(", d[0], it(v[0], d[0]), ",", !1, !0).appendXtra("", d[1], it(v[1], d[1]), "%,", !1).appendXtra("", d[2], it(v[2], d[2]), E ? "%,": "%" + T, !1) : o.appendXtra(E ? "rgba(": "rgb(", d[0], v[0] - d[0], ",", !0, !0).appendXtra("", d[1], v[1] - d[1], ",", !0).appendXtra("", d[2], v[2] - d[2], E ? ",": T, !0), E && (d = d.length < 4 ? 1 : d[3], o.appendXtra("", d, (v.length < 4 ? 1 : v[3]) - d, T, !1))),
            ct.lastIndex = 0;
            else if (y = d.match(m)) {
                if (b = v.match(g), !b || b.length !== y.length) return o;
                for (p = 0, h = 0; h < y.length; h++) x = y[h],
                S = d.indexOf(x, p),
                o.appendXtra(d.substr(p, S - p), Number(x), it(b[h], x), "", A && "px" === d.substr(S + x.length, 2), 0 === h),
                p = S + x.length;
                o["xs" + o.l] += d.substr(p)
            } else o["xs" + o.l] += o.l ? " " + v: v;
            if ( - 1 !== r.indexOf("=") && o.data) {
                for (T = o.xs0 + o.data.s, c = 1; c < o.l; c++) T += o["xs" + c] + o.data["xn" + c];
                o.e = T + o["xs" + c]
            }
            return o.l || (o.type = -1, o.xs0 = o.e),
            o.xfirst || o
        },
        yt = 9;
        for (f = vt.prototype, f.l = f.pr = 0; --yt > 0;) f["xn" + yt] = 0,
        f["xs" + yt] = "";
        f.xs0 = "",
        f._next = f._prev = f.xfirst = f.data = f.plugin = f.setRatio = f.rxp = null,
        f.appendXtra = function(e, t, n, r, i, s) {
            var o = this,
            u = o.l;
            return o["xs" + u] += s && u ? " " + e: e || "",
            n || 0 === u || o.plugin ? (o.l++, o.type = o.setRatio ? 2 : 1, o["xs" + o.l] = r || "", u > 0 ? (o.data["xn" + u] = t + n, o.rxp["xn" + u] = i, o["xn" + u] = t, o.plugin || (o.xfirst = new vt(o, "xn" + u, t, n, o.xfirst || o, 0, o.n, i, o.pr), o.xfirst.xs0 = 0), o) : (o.data = {
                s: t + n
            },
            o.rxp = {},
            o.s = t, o.c = n, o.r = i, o)) : (o["xs" + u] += t + (r || ""), o)
        };
        var bt = function(e, t) {
            t = t || {},
            this.p = t.prefix ? $(e) || e: e,
            a[e] = a[this.p] = this,
            this.format = t.formatter || ht(t.defaultValue, t.color, t.collapsible, t.multi),
            t.parser && (this.parse = t.parser),
            this.clrs = t.color,
            this.multi = t.multi,
            this.keyword = t.keyword,
            this.dflt = t.defaultValue,
            this.pr = t.priority || 0
        },
        wt = q._registerComplexSpecialProp = function(e, t, n) {
            "object" != typeof t && (t = {
                parser: n
            });
            var r, i, s = e.split(","),
            o = t.defaultValue;
            for (n = n || [o], r = 0; r < s.length; r++) t.prefix = 0 === r && t.prefix,
            t.defaultValue = n[r] || o,
            i = new bt(s[r], t)
        },
        Et = function(e) {
            if (!a[e]) {
                var t = e.charAt(0).toUpperCase() + e.substr(1) + "Plugin";
                wt(e, {
                    parser: function(e, n, r, i, s, o, f) {
                        var l = u.com.greensock.plugins[t];
                        return l ? (l._cssRegister(), a[r].parse(e, n, r, i, s, o, f)) : (W("Error: " + t + " js file not loaded."), s)
                    }
                })
            }
        };
        f = bt.prototype,
        f.parseComplex = function(e, t, n, r, i, s) {
            var o, u, a, f, l, c, h = this.keyword;
            if (this.multi && (_.test(n) || _.test(t) ? (u = t.replace(_, "|").split("|"), a = n.replace(_, "|").split("|")) : h && (u = [t], a = [n])), a) {
                for (f = a.length > u.length ? a.length: u.length, o = 0; f > o; o++) t = u[o] = u[o] || this.dflt,
                n = a[o] = a[o] || this.dflt,
                h && (l = t.indexOf(h), c = n.indexOf(h), l !== c && ( - 1 === c ? u[o] = u[o].split(h).join("") : -1 === l && (u[o] += " " + h)));
                t = u.join(", "),
                n = a.join(", ")
            }
            return gt(e, this.p, t, n, this.clrs, this.dflt, r, this.pr, i, s)
        },
        f.parse = function(e, t, n, r, s, o, u) {
            return this.parseComplex(e.style, this.format(K(e, this.p, i, !1, this.dflt)), this.format(t), s, o)
        },
        o.registerSpecialProp = function(e, t, n) {
            wt(e, {
                parser: function(e, r, i, s, o, u, a) {
                    var f = new vt(e, i, 0, 0, o, 2, i, !1, n);
                    return f.plugin = u,
                    f.setRatio = t(e, r, s._tween, i),
                    f
                },
                priority: n
            })
        },
        o.useSVGTransformAttr = h || p;
        var St, xt = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
        Tt = $("transform"),
        Nt = X + "transform",
        Ct = $("transformOrigin"),
        kt = null !== $("perspective"),
        Lt = q.Transform = function() {
            this.perspective = parseFloat(o.defaultTransformPerspective) || 0,
            this.force3D = o.defaultForce3D !== !1 && kt ? o.defaultForce3D || "auto": !1
        },
        At = window.SVGElement,
        Ot = function(e, t, n) {
            var r, i = B.createElementNS("http://www.w3.org/2000/svg", e),
            s = /([a-z])([A-Z])/g;
            for (r in n) i.setAttributeNS(null, r.replace(s, "$1-$2").toLowerCase(), n[r]);
            return t.appendChild(i),
            i
        },
        Mt = B.documentElement,
        _t = function() {
            var e, t, n, r = v || /Android/i.test(R) && !window.chrome;
            return B.createElementNS && !r && (e = Ot("svg", Mt), t = Ot("rect", e, {
                width: 100,
                height: 50,
                x: 100
            }), n = t.getBoundingClientRect().width, t.style[Ct] = "50% 50%", t.style[Tt] = "scaleX(0.5)", r = n === t.getBoundingClientRect().width && (!p || !kt), Mt.removeChild(e)),
            r
        } (),
        Dt = function(e, t, n, r, i) {
            var s, u, a, f, l, c, h, p, d, v, m, g, y, b, w = e._gsTransform,
            E = Bt(e, !0);
            w && (y = w.xOrigin, b = w.yOrigin),
            (!r || (s = r.split(" ")).length < 2) && (h = e.getBBox(), t = rt(t).split(" "), s = [( - 1 !== t[0].indexOf("%") ? parseFloat(t[0]) / 100 * h.width: parseFloat(t[0])) + h.x, ( - 1 !== t[1].indexOf("%") ? parseFloat(t[1]) / 100 * h.height: parseFloat(t[1])) + h.y]),
            n.xOrigin = f = parseFloat(s[0]),
            n.yOrigin = l = parseFloat(s[1]),
            r && E !== Ht && (c = E[0], h = E[1], p = E[2], d = E[3], v = E[4], m = E[5], g = c * d - h * p, u = f * (d / g) + l * ( - p / g) + (p * m - d * v) / g, a = f * ( - h / g) + l * (c / g) - (c * m - h * v) / g, f = n.xOrigin = s[0] = u, l = n.yOrigin = s[1] = a),
            w && (i || i !== !1 && o.defaultSmoothOrigin !== !1 ? (u = f - y, a = l - b, w.xOffset += u * E[0] + a * E[2] - u, w.yOffset += u * E[1] + a * E[3] - a) : w.xOffset = w.yOffset = 0),
            e.setAttribute("data-svg-origin", s.join(" "))
        },
        Pt = function(e) {
            return !! (At && "function" == typeof e.getBBox && e.getCTM && (!e.parentNode || e.parentNode.getBBox && e.parentNode.getCTM))
        },
        Ht = [1, 0, 0, 1, 0, 0],
        Bt = function(e, t) {
            var n, r, i, s, o, u = e._gsTransform || new Lt,
            a = 1e5;
            if (Tt ? r = K(e, Nt, null, !0) : e.currentStyle && (r = e.currentStyle.filter.match(O), r = r && 4 === r.length ? [r[0].substr(4), Number(r[2].substr(4)), Number(r[1].substr(4)), r[3].substr(4), u.x || 0, u.y || 0].join(",") : ""), n = !r || "none" === r || "matrix(1, 0, 0, 1, 0, 0)" === r, (u.svg || e.getBBox && Pt(e)) && (n && -1 !== (e.style[Tt] + "").indexOf("matrix") && (r = e.style[Tt], n = 0), i = e.getAttribute("transform"), n && i && ( - 1 !== i.indexOf("matrix") ? (r = i, n = 0) : -1 !== i.indexOf("translate") && (r = "matrix(1,0,0,1," + i.match(/(?:\-|\b)[\d\-\.e]+\b/gi).join(",") + ")", n = 0))), n) return Ht;
            for (i = (r || "").match(/(?:\-|\b)[\d\-\.e]+\b/gi) || [], yt = i.length; --yt > -1;) s = Number(i[yt]),
            i[yt] = (o = s - (s |= 0)) ? (o * a + (0 > o ? -0.5 : .5) | 0) / a + s: s;
            return t && i.length > 6 ? [i[0], i[1], i[4], i[5], i[12], i[13]] : i
        },
        jt = q.getTransform = function(e, n, r, s) {
            if (e._gsTransform && r && !s) return e._gsTransform;
            var u, a, f, l, c, h, p = r ? e._gsTransform || new Lt: new Lt,
            d = p.scaleX < 0,
            v = 2e-5,
            m = 1e5,
            g = kt ? parseFloat(K(e, Ct, n, !1, "0 0 0").split(" ")[2]) || p.zOrigin || 0 : 0,
            y = parseFloat(o.defaultTransformPerspective) || 0;
            if (p.svg = !!e.getBBox && !!Pt(e), p.svg && (Dt(e, K(e, Ct, i, !1, "50% 50%") + "", p, e.getAttribute("data-svg-origin")), St = o.useSVGTransformAttr || _t), u = Bt(e), u !== Ht) {
                if (16 === u.length) {
                    var b, w, E, S, x, T = u[0],
                    N = u[1],
                    C = u[2],
                    k = u[3],
                    L = u[4],
                    A = u[5],
                    O = u[6],
                    M = u[7],
                    _ = u[8],
                    D = u[9],
                    H = u[10],
                    B = u[12],
                    j = u[13],
                    F = u[14],
                    I = u[11],
                    q = Math.atan2(O, H);
                    p.zOrigin && (F = -p.zOrigin, B = _ * F - u[12], j = D * F - u[13], F = H * F + p.zOrigin - u[14]),
                    p.rotationX = q * P,
                    q && (S = Math.cos( - q), x = Math.sin( - q), b = L * S + _ * x, w = A * S + D * x, E = O * S + H * x, _ = L * -x + _ * S, D = A * -x + D * S, H = O * -x + H * S, I = M * -x + I * S, L = b, A = w, O = E),
                    q = Math.atan2( - C, H),
                    p.rotationY = q * P,
                    q && (S = Math.cos( - q), x = Math.sin( - q), b = T * S - _ * x, w = N * S - D * x, E = C * S - H * x, D = N * x + D * S, H = C * x + H * S, I = k * x + I * S, T = b, N = w, C = E),
                    q = Math.atan2(N, T),
                    p.rotation = q * P,
                    q && (S = Math.cos( - q), x = Math.sin( - q), T = T * S + L * x, w = N * S + A * x, A = N * -x + A * S, O = C * -x + O * S, N = w),
                    p.rotationX && Math.abs(p.rotationX) + Math.abs(p.rotation) > 359.9 && (p.rotationX = p.rotation = 0, p.rotationY = 180 - p.rotationY),
                    p.scaleX = (Math.sqrt(T * T + N * N) * m + .5 | 0) / m,
                    p.scaleY = (Math.sqrt(A * A + D * D) * m + .5 | 0) / m,
                    p.scaleZ = (Math.sqrt(O * O + H * H) * m + .5 | 0) / m,
                    p.skewX = 0,
                    p.perspective = I ? 1 / (0 > I ? -I: I) : 0,
                    p.x = B,
                    p.y = j,
                    p.z = F,
                    p.svg && (p.x -= p.xOrigin - (p.xOrigin * T - p.yOrigin * L), p.y -= p.yOrigin - (p.yOrigin * N - p.xOrigin * A))
                } else if ((!kt || s || !u.length || p.x !== u[4] || p.y !== u[5] || !p.rotationX && !p.rotationY) && (void 0 === p.x || "none" !== K(e, "display", n))) {
                    var R = u.length >= 6,
                    U = R ? u[0] : 1,
                    z = u[1] || 0,
                    W = u[2] || 0,
                    X = R ? u[3] : 1;
                    p.x = u[4] || 0,
                    p.y = u[5] || 0,
                    f = Math.sqrt(U * U + z * z),
                    l = Math.sqrt(X * X + W * W),
                    c = U || z ? Math.atan2(z, U) * P: p.rotation || 0,
                    h = W || X ? Math.atan2(W, X) * P + c: p.skewX || 0,
                    Math.abs(h) > 90 && Math.abs(h) < 270 && (d ? (f *= -1, h += 0 >= c ? 180 : -180, c += 0 >= c ? 180 : -180) : (l *= -1, h += 0 >= h ? 180 : -180)),
                    p.scaleX = f,
                    p.scaleY = l,
                    p.rotation = c,
                    p.skewX = h,
                    kt && (p.rotationX = p.rotationY = p.z = 0, p.perspective = y, p.scaleZ = 1),
                    p.svg && (p.x -= p.xOrigin - (p.xOrigin * U + p.yOrigin * W), p.y -= p.yOrigin - (p.xOrigin * z + p.yOrigin * X))
                }
                p.zOrigin = g;
                for (a in p) p[a] < v && p[a] > -v && (p[a] = 0)
            }
            return r && (e._gsTransform = p, p.svg && (St && e.style[Tt] ? t.delayedCall(.001,
            function() {
                Rt(e.style, Tt)
            }) : !St && e.getAttribute("transform") && t.delayedCall(.001,
            function() {
                e.removeAttribute("transform")
            }))),
            p
        },
        Ft = function(e) {
            var t, n, r = this.data,
            i = -r.rotation * D,
            s = i + r.skewX * D,
            o = 1e5,
            u = (Math.cos(i) * r.scaleX * o | 0) / o,
            a = (Math.sin(i) * r.scaleX * o | 0) / o,
            f = (Math.sin(s) * -r.scaleY * o | 0) / o,
            l = (Math.cos(s) * r.scaleY * o | 0) / o,
            c = this.t.style,
            h = this.t.currentStyle;
            if (h) {
                n = a,
                a = -f,
                f = -n,
                t = h.filter,
                c.filter = "";
                var p, d, m = this.t.offsetWidth,
                g = this.t.offsetHeight,
                y = "absolute" !== h.position,
                b = "progid:DXImageTransform.Microsoft.Matrix(M11=" + u + ", M12=" + a + ", M21=" + f + ", M22=" + l,
                S = r.x + m * r.xPercent / 100,
                x = r.y + g * r.yPercent / 100;
                if (null != r.ox && (p = (r.oxp ? m * r.ox * .01 : r.ox) - m / 2, d = (r.oyp ? g * r.oy * .01 : r.oy) - g / 2, S += p - (p * u + d * a), x += d - (p * f + d * l)), y ? (p = m / 2, d = g / 2, b += ", Dx=" + (p - (p * u + d * a) + S) + ", Dy=" + (d - (p * f + d * l) + x) + ")") : b += ", sizingMethod='auto expand')", -1 !== t.indexOf("DXImageTransform.Microsoft.Matrix(") ? c.filter = t.replace(M, b) : c.filter = b + " " + t, (0 === e || 1 === e) && 1 === u && 0 === a && 0 === f && 1 === l && (y && -1 === b.indexOf("Dx=0, Dy=0") || E.test(t) && 100 !== parseFloat(RegExp.$1) || -1 === t.indexOf(t.indexOf("Alpha")) && c.removeAttribute("filter")), !y) {
                    var T, N, C, k = 8 > v ? 1 : -1;
                    for (p = r.ieOffsetX || 0, d = r.ieOffsetY || 0, r.ieOffsetX = Math.round((m - ((0 > u ? -u: u) * m + (0 > a ? -a: a) * g)) / 2 + S), r.ieOffsetY = Math.round((g - ((0 > l ? -l: l) * g + (0 > f ? -f: f) * m)) / 2 + x), yt = 0; 4 > yt; yt++) N = tt[yt],
                    T = h[N],
                    n = -1 !== T.indexOf("px") ? parseFloat(T) : Q(this.t, N, parseFloat(T), T.replace(w, "")) || 0,
                    C = n !== r[N] ? 2 > yt ? -r.ieOffsetX: -r.ieOffsetY: 2 > yt ? p - r.ieOffsetX: d - r.ieOffsetY,
                    c[N] = (r[N] = Math.round(n - C * (0 === yt || 2 === yt ? 1 : k))) + "px"
                }
            }
        },
        It = q.set3DTransformRatio = q.setTransformRatio = function(e) {
            var t, n, r, i, s, o, u, a, f, l, c, h, d, v, m, g, y, b, w, E, S, x, T, N = this.data,
            C = this.t.style,
            k = N.rotation,
            L = N.rotationX,
            A = N.rotationY,
            O = N.scaleX,
            M = N.scaleY,
            _ = N.scaleZ,
            P = N.x,
            H = N.y,
            B = N.z,
            j = N.svg,
            F = N.perspective,
            I = N.force3D;
            if (((1 === e || 0 === e) && "auto" === I && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !I) && !B && !F && !A && !L && 1 === _ || St && j || !kt) return void(k || N.skewX || j ? (k *= D, x = N.skewX * D, T = 1e5, t = Math.cos(k) * O, i = Math.sin(k) * O, n = Math.sin(k - x) * -M, s = Math.cos(k - x) * M, x && "simple" === N.skewType && (y = Math.tan(x), y = Math.sqrt(1 + y * y), n *= y, s *= y, N.skewY && (t *= y, i *= y)), j && (P += N.xOrigin - (N.xOrigin * t + N.yOrigin * n) + N.xOffset, H += N.yOrigin - (N.xOrigin * i + N.yOrigin * s) + N.yOffset, St && (N.xPercent || N.yPercent) && (v = this.t.getBBox(), P += .01 * N.xPercent * v.width, H += .01 * N.yPercent * v.height), v = 1e-6, v > P && P > -v && (P = 0), v > H && H > -v && (H = 0)), w = (t * T | 0) / T + "," + (i * T | 0) / T + "," + (n * T | 0) / T + "," + (s * T | 0) / T + "," + P + "," + H + ")", j && St ? this.t.setAttribute("transform", "matrix(" + w) : C[Tt] = (N.xPercent || N.yPercent ? "translate(" + N.xPercent + "%," + N.yPercent + "%) matrix(": "matrix(") + w) : C[Tt] = (N.xPercent || N.yPercent ? "translate(" + N.xPercent + "%," + N.yPercent + "%) matrix(": "matrix(") + O + ",0,0," + M + "," + P + "," + H + ")");
            if (p && (v = 1e-4, v > O && O > -v && (O = _ = 2e-5), v > M && M > -v && (M = _ = 2e-5), !F || N.z || N.rotationX || N.rotationY || (F = 0)), k || N.skewX) k *= D,
            m = t = Math.cos(k),
            g = i = Math.sin(k),
            N.skewX && (k -= N.skewX * D, m = Math.cos(k), g = Math.sin(k), "simple" === N.skewType && (y = Math.tan(N.skewX * D), y = Math.sqrt(1 + y * y), m *= y, g *= y, N.skewY && (t *= y, i *= y))),
            n = -g,
            s = m;
            else {
                if (! (A || L || 1 !== _ || F || j)) return void(C[Tt] = (N.xPercent || N.yPercent ? "translate(" + N.xPercent + "%," + N.yPercent + "%) translate3d(": "translate3d(") + P + "px," + H + "px," + B + "px)" + (1 !== O || 1 !== M ? " scale(" + O + "," + M + ")": ""));
                t = s = 1,
                n = i = 0
            }
            f = 1,
            r = o = u = a = l = c = 0,
            h = F ? -1 / F: 0,
            d = N.zOrigin,
            v = 1e-6,
            E = ",",
            S = "0",
            k = A * D,
            k && (m = Math.cos(k), g = Math.sin(k), u = -g, l = h * -g, r = t * g, o = i * g, f = m, h *= m, t *= m, i *= m),
            k = L * D,
            k && (m = Math.cos(k), g = Math.sin(k), y = n * m + r * g, b = s * m + o * g, a = f * g, c = h * g, r = n * -g + r * m, o = s * -g + o * m, f *= m, h *= m, n = y, s = b),
            1 !== _ && (r *= _, o *= _, f *= _, h *= _),
            1 !== M && (n *= M, s *= M, a *= M, c *= M),
            1 !== O && (t *= O, i *= O, u *= O, l *= O),
            (d || j) && (d && (P += r * -d, H += o * -d, B += f * -d + d), j && (P += N.xOrigin - (N.xOrigin * t + N.yOrigin * n) + N.xOffset, H += N.yOrigin - (N.xOrigin * i + N.yOrigin * s) + N.yOffset), v > P && P > -v && (P = S), v > H && H > -v && (H = S), v > B && B > -v && (B = 0)),
            w = N.xPercent || N.yPercent ? "translate(" + N.xPercent + "%," + N.yPercent + "%) matrix3d(": "matrix3d(",
            w += (v > t && t > -v ? S: t) + E + (v > i && i > -v ? S: i) + E + (v > u && u > -v ? S: u),
            w += E + (v > l && l > -v ? S: l) + E + (v > n && n > -v ? S: n) + E + (v > s && s > -v ? S: s),
            L || A || 1 !== _ ? (w += E + (v > a && a > -v ? S: a) + E + (v > c && c > -v ? S: c) + E + (v > r && r > -v ? S: r), w += E + (v > o && o > -v ? S: o) + E + (v > f && f > -v ? S: f) + E + (v > h && h > -v ? S: h) + E) : w += ",0,0,0,0,1,0,",
            w += P + E + H + E + B + E + (F ? 1 + -B / F: 1) + ")",
            C[Tt] = w
        };
        f = Lt.prototype,
        f.x = f.y = f.z = f.skewX = f.skewY = f.rotation = f.rotationX = f.rotationY = f.zOrigin = f.xPercent = f.yPercent = f.xOffset = f.yOffset = 0,
        f.scaleX = f.scaleY = f.scaleZ = 1,
        wt("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
            parser: function(e, t, n, r, s, u, a) {
                if (r._lastParsedTransform === a) return s;
                r._lastParsedTransform = a;
                var f, l, c, h, p, d, v, m, g, y, b = e._gsTransform,
                w = e.style,
                E = 1e-6,
                S = xt.length,
                x = a,
                T = {},
                N = "transformOrigin";
                if (a.display ? (h = K(e, "display"), w.display = "block", f = jt(e, i, !0, a.parseTransform), w.display = h) : f = jt(e, i, !0, a.parseTransform), r._transform = f, "string" == typeof x.transform && Tt) h = F.style,
                h[Tt] = x.transform,
                h.display = "block",
                h.position = "absolute",
                B.body.appendChild(F),
                l = jt(F, null, !1),
                B.body.removeChild(F),
                l.perspective || (l.perspective = f.perspective),
                null != x.xPercent && (l.xPercent = st(x.xPercent, f.xPercent)),
                null != x.yPercent && (l.yPercent = st(x.yPercent, f.yPercent));
                else if ("object" == typeof x) {
                    if (l = {
                        scaleX: st(null != x.scaleX ? x.scaleX: x.scale, f.scaleX),
                        scaleY: st(null != x.scaleY ? x.scaleY: x.scale, f.scaleY),
                        scaleZ: st(x.scaleZ, f.scaleZ),
                        x: st(x.x, f.x),
                        y: st(x.y, f.y),
                        z: st(x.z, f.z),
                        xPercent: st(x.xPercent, f.xPercent),
                        yPercent: st(x.yPercent, f.yPercent),
                        perspective: st(x.transformPerspective, f.perspective)
                    },
                    m = x.directionalRotation, null != m) if ("object" == typeof m) for (h in m) x[h] = m[h];
                    else x.rotation = m;
                    "string" == typeof x.x && -1 !== x.x.indexOf("%") && (l.x = 0, l.xPercent = st(x.x, f.xPercent)),
                    "string" == typeof x.y && -1 !== x.y.indexOf("%") && (l.y = 0, l.yPercent = st(x.y, f.yPercent)),
                    l.rotation = ot("rotation" in x ? x.rotation: "shortRotation" in x ? x.shortRotation + "_short": "rotationZ" in x ? x.rotationZ: f.rotation, f.rotation, "rotation", T),
                    kt && (l.rotationX = ot("rotationX" in x ? x.rotationX: "shortRotationX" in x ? x.shortRotationX + "_short": f.rotationX || 0, f.rotationX, "rotationX", T), l.rotationY = ot("rotationY" in x ? x.rotationY: "shortRotationY" in x ? x.shortRotationY + "_short": f.rotationY || 0, f.rotationY, "rotationY", T)),
                    l.skewX = null == x.skewX ? f.skewX: ot(x.skewX, f.skewX),
                    l.skewY = null == x.skewY ? f.skewY: ot(x.skewY, f.skewY),
                    (c = l.skewY - f.skewY) && (l.skewX += c, l.rotation += c)
                }
                for (kt && null != x.force3D && (f.force3D = x.force3D, v = !0), f.skewType = x.skewType || f.skewType || o.defaultSkewType, d = f.force3D || f.z || f.rotationX || f.rotationY || l.z || l.rotationX || l.rotationY || l.perspective, d || null == x.scale || (l.scaleZ = 1); --S > -1;) n = xt[S],
                p = l[n] - f[n],
                (p > E || -E > p || null != x[n] || null != H[n]) && (v = !0, s = new vt(f, n, f[n], p, s), n in T && (s.e = T[n]), s.xs0 = 0, s.plugin = u, r._overwriteProps.push(s.n));
                return p = x.transformOrigin,
                f.svg && (p || x.svgOrigin) && (g = f.xOffset, y = f.yOffset, Dt(e, rt(p), l, x.svgOrigin, x.smoothOrigin), s = mt(f, "xOrigin", (b ? f: l).xOrigin, l.xOrigin, s, N), s = mt(f, "yOrigin", (b ? f: l).yOrigin, l.yOrigin, s, N), (g !== f.xOffset || y !== f.yOffset) && (s = mt(f, "xOffset", b ? g: f.xOffset, f.xOffset, s, N), s = mt(f, "yOffset", b ? y: f.yOffset, f.yOffset, s, N)), p = St ? null: "0px 0px"),
                (p || kt && d && f.zOrigin) && (Tt ? (v = !0, n = Ct, p = (p || K(e, n, i, !1, "50% 50%")) + "", s = new vt(w, n, 0, 0, s, -1, N), s.b = w[n], s.plugin = u, kt ? (h = f.zOrigin, p = p.split(" "), f.zOrigin = (p.length > 2 && (0 === h || "0px" !== p[2]) ? parseFloat(p[2]) : h) || 0, s.xs0 = s.e = p[0] + " " + (p[1] || "50%") + " 0px", s = new vt(f, "zOrigin", 0, 0, s, -1, s.n), s.b = h, s.xs0 = s.e = f.zOrigin) : s.xs0 = s.e = p) : rt(p + "", f)),
                v && (r._transformType = f.svg && St || !d && 3 !== this._transformType ? 2 : 3),
                s
            },
            prefix: !0
        }),
        wt("boxShadow", {
            defaultValue: "0px 0px 0px 0px #999",
            prefix: !0,
            color: !0,
            multi: !0,
            keyword: "inset"
        }),
        wt("borderRadius", {
            defaultValue: "0px",
            parser: function(e, t, n, s, o, u) {
                t = this.format(t);
                var a, f, l, c, h, p, d, v, m, g, y, b, w, E, S, x, T = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                N = e.style;
                for (m = parseFloat(e.offsetWidth), g = parseFloat(e.offsetHeight), a = t.split(" "), f = 0; f < T.length; f++) this.p.indexOf("border") && (T[f] = $(T[f])),
                h = c = K(e, T[f], i, !1, "0px"),
                -1 !== h.indexOf(" ") && (c = h.split(" "), h = c[0], c = c[1]),
                p = l = a[f],
                d = parseFloat(h),
                b = h.substr((d + "").length),
                w = "=" === p.charAt(1),
                w ? (v = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), v *= parseFloat(p), y = p.substr((v + "").length - (0 > v ? 1 : 0)) || "") : (v = parseFloat(p), y = p.substr((v + "").length)),
                "" === y && (y = r[n] || b),
                y !== b && (E = Q(e, "borderLeft", d, b), S = Q(e, "borderTop", d, b), "%" === y ? (h = E / m * 100 + "%", c = S / g * 100 + "%") : "em" === y ? (x = Q(e, "borderLeft", 1, "em"), h = E / x + "em", c = S / x + "em") : (h = E + "px", c = S + "px"), w && (p = parseFloat(h) + v + y, l = parseFloat(c) + v + y)),
                o = gt(N, T[f], h + " " + c, p + " " + l, !1, "0px", o);
                return o
            },
            prefix: !0,
            formatter: ht("0px 0px 0px 0px", !1, !0)
        }),
        wt("backgroundPosition", {
            defaultValue: "0 0",
            parser: function(e, t, n, r, s, o) {
                var u, a, f, l, c, h, p = "background-position",
                d = i || J(e, null),
                m = this.format((d ? v ? d.getPropertyValue(p + "-x") + " " + d.getPropertyValue(p + "-y") : d.getPropertyValue(p) : e.currentStyle.backgroundPositionX + " " + e.currentStyle.backgroundPositionY) || "0 0"),
                g = this.format(t);
                if ( - 1 !== m.indexOf("%") != ( - 1 !== g.indexOf("%")) && (h = K(e, "backgroundImage").replace(k, ""), h && "none" !== h)) {
                    for (u = m.split(" "), a = g.split(" "), I.setAttribute("src", h), f = 2; --f > -1;) m = u[f],
                    l = -1 !== m.indexOf("%"),
                    l !== ( - 1 !== a[f].indexOf("%")) && (c = 0 === f ? e.offsetWidth - I.width: e.offsetHeight - I.height, u[f] = l ? parseFloat(m) / 100 * c + "px": parseFloat(m) / c * 100 + "%");
                    m = u.join(" ")
                }
                return this.parseComplex(e.style, m, g, s, o)
            },
            formatter: rt
        }),
        wt("backgroundSize", {
            defaultValue: "0 0",
            formatter: rt
        }),
        wt("perspective", {
            defaultValue: "0px",
            prefix: !0
        }),
        wt("perspectiveOrigin", {
            defaultValue: "50% 50%",
            prefix: !0
        }),
        wt("transformStyle", {
            prefix: !0
        }),
        wt("backfaceVisibility", {
            prefix: !0
        }),
        wt("userSelect", {
            prefix: !0
        }),
        wt("margin", {
            parser: pt("marginTop,marginRight,marginBottom,marginLeft")
        }),
        wt("padding", {
            parser: pt("paddingTop,paddingRight,paddingBottom,paddingLeft")
        }),
        wt("clip", {
            defaultValue: "rect(0px,0px,0px,0px)",
            parser: function(e, t, n, r, s, o) {
                var u, a, f;
                return 9 > v ? (a = e.currentStyle, f = 8 > v ? " ": ",", u = "rect(" + a.clipTop + f + a.clipRight + f + a.clipBottom + f + a.clipLeft + ")", t = this.format(t).split(",").join(f)) : (u = this.format(K(e, this.p, i, !1, this.dflt)), t = this.format(t)),
                this.parseComplex(e.style, u, t, s, o)
            }
        }),
        wt("textShadow", {
            defaultValue: "0px 0px 0px #999",
            color: !0,
            multi: !0
        }),
        wt("autoRound,strictUnits", {
            parser: function(e, t, n, r, i) {
                return i
            }
        }),
        wt("border", {
            defaultValue: "0px solid #000",
            parser: function(e, t, n, r, s, o) {
                return this.parseComplex(e.style, this.format(K(e, "borderTopWidth", i, !1, "0px") + " " + K(e, "borderTopStyle", i, !1, "solid") + " " + K(e, "borderTopColor", i, !1, "#000")), this.format(t), s, o)
            },
            color: !0,
            formatter: function(e) {
                var t = e.split(" ");
                return t[0] + " " + (t[1] || "solid") + " " + (e.match(ct) || ["#000"])[0]
            }
        }),
        wt("borderWidth", {
            parser: pt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")
        }),
        wt("float,cssFloat,styleFloat", {
            parser: function(e, t, n, r, i, s) {
                var o = e.style,
                u = "cssFloat" in o ? "cssFloat": "styleFloat";
                return new vt(o, u, 0, 0, i, -1, n, !1, 0, o[u], t)
            }
        });
        var qt = function(e) {
            var t, n = this.t,
            r = n.filter || K(this.data, "filter") || "",
            i = this.s + this.c * e | 0;
            100 === i && ( - 1 === r.indexOf("atrix(") && -1 === r.indexOf("radient(") && -1 === r.indexOf("oader(") ? (n.removeAttribute("filter"), t = !K(this.data, "filter")) : (n.filter = r.replace(x, ""), t = !0)),
            t || (this.xn1 && (n.filter = r = r || "alpha(opacity=" + i + ")"), -1 === r.indexOf("pacity") ? 0 === i && this.xn1 || (n.filter = r + " alpha(opacity=" + i + ")") : n.filter = r.replace(E, "opacity=" + i))
        };
        wt("opacity,alpha,autoAlpha", {
            defaultValue: "1",
            parser: function(e, t, n, r, s, o) {
                var u = parseFloat(K(e, "opacity", i, !1, "1")),
                a = e.style,
                f = "autoAlpha" === n;
                return "string" == typeof t && "=" === t.charAt(1) && (t = ("-" === t.charAt(0) ? -1 : 1) * parseFloat(t.substr(2)) + u),
                f && 1 === u && "hidden" === K(e, "visibility", i) && 0 !== t && (u = 0),
                U ? s = new vt(a, "opacity", u, t - u, s) : (s = new vt(a, "opacity", 100 * u, 100 * (t - u), s), s.xn1 = f ? 1 : 0, a.zoom = 1, s.type = 2, s.b = "alpha(opacity=" + s.s + ")", s.e = "alpha(opacity=" + (s.s + s.c) + ")", s.data = e, s.plugin = o, s.setRatio = qt),
                f && (s = new vt(a, "visibility", 0, 0, s, -1, null, !1, 0, 0 !== u ? "inherit": "hidden", 0 === t ? "hidden": "inherit"), s.xs0 = "inherit", r._overwriteProps.push(s.n), r._overwriteProps.push(n)),
                s
            }
        });
        var Rt = function(e, t) {
            t && (e.removeProperty ? (("ms" === t.substr(0, 2) || "webkit" === t.substr(0, 6)) && (t = "-" + t), e.removeProperty(t.replace(N, "-$1").toLowerCase())) : e.removeAttribute(t))
        },
        Ut = function(e) {
            if (this.t._gsClassPT = this, 1 === e || 0 === e) {
                this.t.setAttribute("class", 0 === e ? this.b: this.e);
                for (var t = this.data,
                n = this.t.style; t;) t.v ? n[t.p] = t.v: Rt(n, t.p),
                t = t._next;
                1 === e && this.t._gsClassPT === this && (this.t._gsClassPT = null)
            } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
        };
        wt("className", {
            parser: function(e, t, r, s, o, u, a) {
                var f, l, c, h, p, d = e.getAttribute("class") || "",
                v = e.style.cssText;
                if (o = s._classNamePT = new vt(e, r, 0, 0, o, 2), o.setRatio = Ut, o.pr = -11, n = !0, o.b = d, l = Y(e, i), c = e._gsClassPT) {
                    for (h = {},
                    p = c.data; p;) h[p.p] = 1,
                    p = p._next;
                    c.setRatio(1)
                }
                return e._gsClassPT = o,
                o.e = "=" !== t.charAt(1) ? t: d.replace(new RegExp("\\s*\\b" + t.substr(2) + "\\b"), "") + ("+" === t.charAt(0) ? " " + t.substr(2) : ""),
                e.setAttribute("class", o.e),
                f = Z(e, l, Y(e), a, h),
                e.setAttribute("class", d),
                o.data = f.firstMPT,
                e.style.cssText = v,
                o = o.xfirst = s.parse(e, f.difs, o, u)
            }
        });
        var zt = function(e) {
            if ((1 === e || 0 === e) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                var t, n, r, i, s, o = this.t.style,
                u = a.transform.parse;
                if ("all" === this.e) o.cssText = "",
                i = !0;
                else for (t = this.e.split(" ").join("").split(","), r = t.length; --r > -1;) n = t[r],
                a[n] && (a[n].parse === u ? i = !0 : n = "transformOrigin" === n ? Ct: a[n].p),
                Rt(o, n);
                i && (Rt(o, Tt), s = this.t._gsTransform, s && (s.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
            }
        };
        for (wt("clearProps", {
            parser: function(e, t, r, i, s) {
                return s = new vt(e, r, 0, 0, s, 2),
                s.setRatio = zt,
                s.e = t,
                s.pr = -10,
                s.data = i._tween,
                n = !0,
                s
            }
        }), f = "bezier,throwProps,physicsProps,physics2D".split(","), yt = f.length; yt--;) Et(f[yt]);
        f = o.prototype,
        f._firstPT = f._lastParsedTransform = f._transform = null,
        f._onInitTween = function(e, t, u) {
            if (!e.nodeType) return ! 1;
            this._target = e,
            this._tween = u,
            this._vars = t,
            l = t.autoRound,
            n = !1,
            r = t.suffixMap || o.suffixMap,
            i = J(e, ""),
            s = this._overwriteProps;
            var f, p, v, m, g, y, b, w, E, x = e.style;
            if (c && "" === x.zIndex && (f = K(e, "zIndex", i), ("auto" === f || "" === f) && this._addLazySet(x, "zIndex", 0)), "string" == typeof t && (m = x.cssText, f = Y(e, i), x.cssText = m + ";" + t, f = Z(e, f, Y(e)).difs, !U && S.test(t) && (f.opacity = parseFloat(RegExp.$1)), t = f, x.cssText = m), t.className ? this._firstPT = p = a.className.parse(e, t.className, "className", this, null, null, t) : this._firstPT = p = this.parse(e, t, null), this._transformType) {
                for (E = 3 === this._transformType, Tt ? h && (c = !0, "" === x.zIndex && (b = K(e, "zIndex", i), ("auto" === b || "" === b) && this._addLazySet(x, "zIndex", 0)), d && this._addLazySet(x, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (E ? "visible": "hidden"))) : x.zoom = 1, v = p; v && v._next;) v = v._next;
                w = new vt(e, "transform", 0, 0, null, 2),
                this._linkCSSP(w, null, v),
                w.setRatio = Tt ? It: Ft,
                w.data = this._transform || jt(e, i, !0),
                w.tween = u,
                w.pr = -1,
                s.pop()
            }
            if (n) {
                for (; p;) {
                    for (y = p._next, v = m; v && v.pr > p.pr;) v = v._next; (p._prev = v ? v._prev: g) ? p._prev._next = p: m = p,
                    (p._next = v) ? v._prev = p: g = p,
                    p = y
                }
                this._firstPT = m
            }
            return ! 0
        },
        f.parse = function(e, t, n, s) {
            var o, u, f, c, h, p, d, v, m, g, y = e.style;
            for (o in t) p = t[o],
            u = a[o],
            u ? n = u.parse(e, p, o, this, n, s, t) : (h = K(e, o, i) + "", m = "string" == typeof p, "color" === o || "fill" === o || "stroke" === o || -1 !== o.indexOf("Color") || m && T.test(p) ? (m || (p = ft(p), p = (p.length > 3 ? "rgba(": "rgb(") + p.join(",") + ")"), n = gt(y, o, h, p, !0, "transparent", n, 0, s)) : !m || -1 === p.indexOf(" ") && -1 === p.indexOf(",") ? (f = parseFloat(h), d = f || 0 === f ? h.substr((f + "").length) : "", ("" === h || "auto" === h) && ("width" === o || "height" === o ? (f = nt(e, o, i), d = "px") : "left" === o || "top" === o ? (f = G(e, o, i), d = "px") : (f = "opacity" !== o ? 0 : 1, d = "")), g = m && "=" === p.charAt(1), g ? (c = parseInt(p.charAt(0) + "1", 10), p = p.substr(2), c *= parseFloat(p), v = p.replace(w, "")) : (c = parseFloat(p), v = m ? p.replace(w, "") : ""), "" === v && (v = o in r ? r[o] : d), p = c || 0 === c ? (g ? c + f: c) + v: t[o], d !== v && "" !== v && (c || 0 === c) && f && (f = Q(e, o, f, d), "%" === v ? (f /= Q(e, o, 100, "%") / 100, t.strictUnits !== !0 && (h = f + "%")) : "em" === v || "rem" === v || "vw" === v || "vh" === v ? f /= Q(e, o, 1, v) : "px" !== v && (c = Q(e, o, c, v), v = "px"), g && (c || 0 === c) && (p = c + f + v)), g && (c += f), !f && 0 !== f || !c && 0 !== c ? void 0 !== y[o] && (p || p + "" != "NaN" && null != p) ? (n = new vt(y, o, c || f || 0, 0, n, -1, o, !1, 0, h, p), n.xs0 = "none" !== p || "display" !== o && -1 === o.indexOf("Style") ? p: h) : W("invalid " + o + " tween value: " + t[o]) : (n = new vt(y, o, f, c - f, n, 0, o, l !== !1 && ("px" === v || "zIndex" === o), 0, h, p), n.xs0 = v)) : n = gt(y, o, h, p, !0, null, n, 0, s)),
            s && n && !n.plugin && (n.plugin = s);
            return n
        },
        f.setRatio = function(e) {
            var t, n, r, i = this._firstPT,
            s = 1e-6;
            if (1 !== e || this._tween._time !== this._tween._duration && 0 !== this._tween._time) if (e || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -0.000001) for (; i;) {
                if (t = i.c * e + i.s, i.r ? t = Math.round(t) : s > t && t > -s && (t = 0), i.type) if (1 === i.type) if (r = i.l, 2 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2;
                else if (3 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2 + i.xn2 + i.xs3;
                else if (4 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2 + i.xn2 + i.xs3 + i.xn3 + i.xs4;
                else if (5 === r) i.t[i.p] = i.xs0 + t + i.xs1 + i.xn1 + i.xs2 + i.xn2 + i.xs3 + i.xn3 + i.xs4 + i.xn4 + i.xs5;
                else {
                    for (n = i.xs0 + t + i.xs1, r = 1; r < i.l; r++) n += i["xn" + r] + i["xs" + (r + 1)];
                    i.t[i.p] = n
                } else - 1 === i.type ? i.t[i.p] = i.xs0: i.setRatio && i.setRatio(e);
                else i.t[i.p] = t + i.xs0;
                i = i._next
            } else for (; i;) 2 !== i.type ? i.t[i.p] = i.b: i.setRatio(e),
            i = i._next;
            else for (; i;) {
                if (2 !== i.type) if (i.r && -1 !== i.type) if (t = Math.round(i.s + i.c), i.type) {
                    if (1 === i.type) {
                        for (r = i.l, n = i.xs0 + t + i.xs1, r = 1; r < i.l; r++) n += i["xn" + r] + i["xs" + (r + 1)];
                        i.t[i.p] = n
                    }
                } else i.t[i.p] = t + i.xs0;
                else i.t[i.p] = i.e;
                else i.setRatio(e);
                i = i._next
            }
        },
        f._enableTransforms = function(e) {
            this._transform = this._transform || jt(this._target, i, !0),
            this._transformType = this._transform.svg && St || !e && 3 !== this._transformType ? 2 : 3
        };
        var Wt = function(e) {
            this.t[this.p] = this.e,
            this.data._linkCSSP(this, this._next, null, !0)
        };
        f._addLazySet = function(e, t, n) {
            var r = this._firstPT = new vt(e, t, 0, 0, this._firstPT, 2);
            r.e = n,
            r.setRatio = Wt,
            r.data = this
        },
        f._linkCSSP = function(e, t, n, r) {
            return e && (t && (t._prev = e), e._next && (e._next._prev = e._prev), e._prev ? e._prev._next = e._next: this._firstPT === e && (this._firstPT = e._next, r = !0), n ? n._next = e: r || null !== this._firstPT || (this._firstPT = e), e._next = t, e._prev = n),
            e
        },
        f._kill = function(t) {
            var n, r, i, s = t;
            if (t.autoAlpha || t.alpha) {
                s = {};
                for (r in t) s[r] = t[r];
                s.opacity = 1,
                s.autoAlpha && (s.visibility = 1)
            }
            return t.className && (n = this._classNamePT) && (i = n.xfirst, i && i._prev ? this._linkCSSP(i._prev, n._next, i._prev._prev) : i === this._firstPT && (this._firstPT = n._next), n._next && this._linkCSSP(n._next, n._next._next, i._prev), this._classNamePT = null),
            e.prototype._kill.call(this, s)
        };
        var Xt = function(e, t, n) {
            var r, i, s, o;
            if (e.slice) for (i = e.length; --i > -1;) Xt(e[i], t, n);
            else for (r = e.childNodes, i = r.length; --i > -1;) s = r[i],
            o = s.type,
            s.style && (t.push(Y(s)), n && n.push(s)),
            1 !== o && 9 !== o && 11 !== o || !s.childNodes.length || Xt(s, t, n)
        };
        return o.cascadeTo = function(e, n, r) {
            var i, s, o, u, a = t.to(e, n, r),
            f = [a],
            l = [],
            c = [],
            h = [],
            p = t._internals.reservedProps;
            for (e = a._targets || a.target, Xt(e, l, h), a.render(n, !0, !0), Xt(e, c), a.render(0, !0, !0), a._enabled(!0), i = h.length; --i > -1;) if (s = Z(h[i], l[i], c[i]), s.firstMPT) {
                s = s.difs;
                for (o in r) p[o] && (s[o] = r[o]);
                u = {};
                for (o in s) u[o] = l[i][o];
                f.push(t.fromTo(h[i], n, u, s))
            }
            return f
        },
        e.activate([o]),
        o
    },
    !0),
    function() {
        var e = _gsScope._gsDefine.plugin({
            propName: "roundProps",
            version: "1.5",
            priority: -1,
            API: 2,
            init: function(e, t, n) {
                return this._tween = n,
                !0
            }
        }),
        t = function(e) {
            for (; e;) e.f || e.blob || (e.r = 1),
            e = e._next
        },
        n = e.prototype;
        n._onInitAllProps = function() {
            for (var e, n, r, i = this._tween,
            s = i.vars.roundProps.join ? i.vars.roundProps: i.vars.roundProps.split(","), o = s.length, u = {},
            a = i._propLookup.roundProps; --o > -1;) u[s[o]] = 1;
            for (o = s.length; --o > -1;) for (e = s[o], n = i._firstPT; n;) r = n._next,
            n.pg ? n.t._roundProps(u, !0) : n.n === e && (2 === n.f && n.t ? t(n.t._firstPT) : (this._add(n.t, e, n.s, n.c), r && (r._prev = n._prev), n._prev ? n._prev._next = r: i._firstPT === n && (i._firstPT = r), n._next = n._prev = null, i._propLookup[e] = a)),
            n = r;
            return ! 1
        },
        n._add = function(e, t, n, r) {
            this._addTween(e, t, n, n + r, t, !0),
            this._overwriteProps.push(t)
        }
    } (),
    function() {
        _gsScope._gsDefine.plugin({
            propName: "attr",
            API: 2,
            version: "0.5.0",
            init: function(e, t, n) {
                var r;
                if ("function" != typeof e.setAttribute) return ! 1;
                for (r in t) this._addTween(e, "setAttribute", e.getAttribute(r) + "", t[r] + "", r, !1, r),
                this._overwriteProps.push(r);
                return ! 0
            }
        })
    } (),
    _gsScope._gsDefine.plugin({
        propName: "directionalRotation",
        version: "0.2.1",
        API: 2,
        init: function(e, t, n) {
            "object" != typeof t && (t = {
                rotation: t
            }),
            this.finals = {};
            var r, i, s, o, u, a, f = t.useRadians === !0 ? 2 * Math.PI: 360,
            l = 1e-6;
            for (r in t)"useRadians" !== r && (a = (t[r] + "").split("_"), i = a[0], s = parseFloat("function" != typeof e[r] ? e[r] : e[r.indexOf("set") || "function" != typeof e["get" + r.substr(3)] ? r: "get" + r.substr(3)]()), o = this.finals[r] = "string" == typeof i && "=" === i.charAt(1) ? s + parseInt(i.charAt(0) + "1", 10) * Number(i.substr(2)) : Number(i) || 0, u = o - s, a.length && (i = a.join("_"), -1 !== i.indexOf("short") && (u %= f, u !== u % (f / 2) && (u = 0 > u ? u + f: u - f)), -1 !== i.indexOf("_cw") && 0 > u ? u = (u + 9999999999 * f) % f - (u / f | 0) * f: -1 !== i.indexOf("ccw") && u > 0 && (u = (u - 9999999999 * f) % f - (u / f | 0) * f)), (u > l || -l > u) && (this._addTween(e, r, s, s + u, r), this._overwriteProps.push(r)));
            return ! 0
        },
        set: function(e) {
            var t;
            if (1 !== e) this._super.setRatio.call(this, e);
            else for (t = this._firstPT; t;) t.f ? t.t[t.p](this.finals[t.p]) : t.t[t.p] = this.finals[t.p],
            t = t._next
        }
    })._autoCSS = !0,
    _gsScope._gsDefine("easing.Back", ["easing.Ease"],
    function(e) {
        var t, n, r, i = _gsScope.GreenSockGlobals || _gsScope,
        s = i.com.greensock,
        o = 2 * Math.PI,
        u = Math.PI / 2,
        a = s._class,
        f = function(t, n) {
            var r = a("easing." + t,
            function() {},
            !0),
            i = r.prototype = new e;
            return i.constructor = r,
            i.getRatio = n,
            r
        },
        l = e.register ||
        function() {},
        c = function(e, t, n, r, i) {
            var s = a("easing." + e, {
                easeOut: new t,
                easeIn: new n,
                easeInOut: new r
            },
            !0);
            return l(s, e),
            s
        },
        h = function(e, t, n) {
            this.t = e,
            this.v = t,
            n && (this.next = n, n.prev = this, this.c = n.v - t, this.gap = n.t - e)
        },
        p = function(t, n) {
            var r = a("easing." + t,
            function(e) {
                this._p1 = e || 0 === e ? e: 1.70158,
                this._p2 = 1.525 * this._p1
            },
            !0),
            i = r.prototype = new e;
            return i.constructor = r,
            i.getRatio = n,
            i.config = function(e) {
                return new r(e)
            },
            r
        },
        d = c("Back", p("BackOut",
        function(e) {
            return (e -= 1) * e * ((this._p1 + 1) * e + this._p1) + 1
        }), p("BackIn",
        function(e) {
            return e * e * ((this._p1 + 1) * e - this._p1)
        }), p("BackInOut",
        function(e) {
            return (e *= 2) < 1 ? .5 * e * e * ((this._p2 + 1) * e - this._p2) : .5 * ((e -= 2) * e * ((this._p2 + 1) * e + this._p2) + 2)
        })),
        v = a("easing.SlowMo",
        function(e, t, n) {
            t = t || 0 === t ? t: .7,
            null == e ? e = .7 : e > 1 && (e = 1),
            this._p = 1 !== e ? t: 0,
            this._p1 = (1 - e) / 2,
            this._p2 = e,
            this._p3 = this._p1 + this._p2,
            this._calcEnd = n === !0
        },
        !0),
        m = v.prototype = new e;
        return m.constructor = v,
        m.getRatio = function(e) {
            var t = e + (.5 - e) * this._p;
            return e < this._p1 ? this._calcEnd ? 1 - (e = 1 - e / this._p1) * e: t - (e = 1 - e / this._p1) * e * e * e * t: e > this._p3 ? this._calcEnd ? 1 - (e = (e - this._p3) / this._p1) * e: t + (e - t) * (e = (e - this._p3) / this._p1) * e * e * e: this._calcEnd ? 1 : t
        },
        v.ease = new v(.7, .7),
        m.config = v.config = function(e, t, n) {
            return new v(e, t, n)
        },
        t = a("easing.SteppedEase",
        function(e) {
            e = e || 1,
            this._p1 = 1 / e,
            this._p2 = e + 1
        },
        !0),
        m = t.prototype = new e,
        m.constructor = t,
        m.getRatio = function(e) {
            return 0 > e ? e = 0 : e >= 1 && (e = .999999999),
            (this._p2 * e >> 0) * this._p1
        },
        m.config = t.config = function(e) {
            return new t(e)
        },
        n = a("easing.RoughEase",
        function(t) {
            t = t || {};
            for (var n, r, i, s, o, u, a = t.taper || "none",
            f = [], l = 0, c = 0 | (t.points || 20), p = c, d = t.randomize !== !1, v = t.clamp === !0, m = t.template instanceof e ? t.template: null, g = "number" == typeof t.strength ? .4 * t.strength: .4; --p > -1;) n = d ? Math.random() : 1 / c * p,
            r = m ? m.getRatio(n) : n,
            "none" === a ? i = g: "out" === a ? (s = 1 - n, i = s * s * g) : "in" === a ? i = n * n * g: .5 > n ? (s = 2 * n, i = s * s * .5 * g) : (s = 2 * (1 - n), i = s * s * .5 * g),
            d ? r += Math.random() * i - .5 * i: p % 2 ? r += .5 * i: r -= .5 * i,
            v && (r > 1 ? r = 1 : 0 > r && (r = 0)),
            f[l++] = {
                x: n,
                y: r
            };
            for (f.sort(function(e, t) {
                return e.x - t.x
            }), u = new h(1, 1, null), p = c; --p > -1;) o = f[p],
            u = new h(o.x, o.y, u);
            this._prev = new h(0, 0, 0 !== u.t ? u: u.next)
        },
        !0),
        m = n.prototype = new e,
        m.constructor = n,
        m.getRatio = function(e) {
            var t = this._prev;
            if (e > t.t) {
                for (; t.next && e >= t.t;) t = t.next;
                t = t.prev
            } else for (; t.prev && e <= t.t;) t = t.prev;
            return this._prev = t,
            t.v + (e - t.t) / t.gap * t.c
        },
        m.config = function(e) {
            return new n(e)
        },
        n.ease = new n,
        c("Bounce", f("BounceOut",
        function(e) {
            return 1 / 2.75 > e ? 7.5625 * e * e: 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375
        }), f("BounceIn",
        function(e) {
            return (e = 1 - e) < 1 / 2.75 ? 1 - 7.5625 * e * e: 2 / 2.75 > e ? 1 - (7.5625 * (e -= 1.5 / 2.75) * e + .75) : 2.5 / 2.75 > e ? 1 - (7.5625 * (e -= 2.25 / 2.75) * e + .9375) : 1 - (7.5625 * (e -= 2.625 / 2.75) * e + .984375)
        }), f("BounceInOut",
        function(e) {
            var t = .5 > e;
            return e = t ? 1 - 2 * e: 2 * e - 1,
            e = 1 / 2.75 > e ? 7.5625 * e * e: 2 / 2.75 > e ? 7.5625 * (e -= 1.5 / 2.75) * e + .75 : 2.5 / 2.75 > e ? 7.5625 * (e -= 2.25 / 2.75) * e + .9375 : 7.5625 * (e -= 2.625 / 2.75) * e + .984375,
            t ? .5 * (1 - e) : .5 * e + .5
        })),
        c("Circ", f("CircOut",
        function(e) {
            return Math.sqrt(1 - (e -= 1) * e)
        }), f("CircIn",
        function(e) {
            return - (Math.sqrt(1 - e * e) - 1)
        }), f("CircInOut",
        function(e) {
            return (e *= 2) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : .5 * (Math.sqrt(1 - (e -= 2) * e) + 1)
        })),
        r = function(t, n, r) {
            var i = a("easing." + t,
            function(e, t) {
                this._p1 = e >= 1 ? e: 1,
                this._p2 = (t || r) / (1 > e ? e: 1),
                this._p3 = this._p2 / o * (Math.asin(1 / this._p1) || 0),
                this._p2 = o / this._p2
            },
            !0),
            s = i.prototype = new e;
            return s.constructor = i,
            s.getRatio = n,
            s.config = function(e, t) {
                return new i(e, t)
            },
            i
        },
        c("Elastic", r("ElasticOut",
        function(e) {
            return this._p1 * Math.pow(2, -10 * e) * Math.sin((e - this._p3) * this._p2) + 1
        },
        .3), r("ElasticIn",
        function(e) {
            return - (this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2))
        },
        .3), r("ElasticInOut",
        function(e) {
            return (e *= 2) < 1 ? -0.5 * this._p1 * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) : this._p1 * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - this._p3) * this._p2) * .5 + 1
        },
        .45)),
        c("Expo", f("ExpoOut",
        function(e) {
            return 1 - Math.pow(2, -10 * e)
        }), f("ExpoIn",
        function(e) {
            return Math.pow(2, 10 * (e - 1)) - .001
        }), f("ExpoInOut",
        function(e) {
            return (e *= 2) < 1 ? .5 * Math.pow(2, 10 * (e - 1)) : .5 * (2 - Math.pow(2, -10 * (e - 1)))
        })),
        c("Sine", f("SineOut",
        function(e) {
            return Math.sin(e * u)
        }), f("SineIn",
        function(e) {
            return - Math.cos(e * u) + 1
        }), f("SineInOut",
        function(e) {
            return - 0.5 * (Math.cos(Math.PI * e) - 1)
        })),
        a("easing.EaseLookup", {
            find: function(t) {
                return e.map[t]
            }
        },
        !0),
        l(i.SlowMo, "SlowMo", "ease,"),
        l(n, "RoughEase", "ease,"),
        l(t, "SteppedEase", "ease,"),
        d
    },
    !0)
}),
_gsScope._gsDefine && _gsScope._gsQueue.pop()(),
function(e, t) {
    var n = e.GreenSockGlobals = e.GreenSockGlobals || e;
    if (!n.TweenLite) {
        var r, i, s, o, u, a = function(e) {
            var t, r = e.split("."),
            i = n;
            for (t = 0; t < r.length; t++) i[r[t]] = i = i[r[t]] || {};
            return i
        },
        f = a("com.greensock"),
        l = 1e-10,
        c = function(e) {
            var t, n = [],
            r = e.length;
            for (t = 0; t !== r; n.push(e[t++]));
            return n
        },
        h = function() {},
        p = function() {
            var e = Object.prototype.toString,
            t = e.call([]);
            return function(n) {
                return null != n && (n instanceof Array || "object" == typeof n && !!n.push && e.call(n) === t)
            }
        } (),
        d = {},
        v = function(r, i, s, o) {
            this.sc = d[r] ? d[r].sc: [],
            d[r] = this,
            this.gsClass = null,
            this.func = s;
            var u = [];
            this.check = function(f) {
                for (var l, c, h, p, m, g = i.length,
                y = g; --g > -1;)(l = d[i[g]] || new v(i[g], [])).gsClass ? (u[g] = l.gsClass, y--) : f && l.sc.push(this);
                if (0 === y && s) for (c = ("com.greensock." + r).split("."), h = c.pop(), p = a(c.join("."))[h] = this.gsClass = s.apply(s, u), o && (n[h] = p, m = "undefined" != typeof module && module.exports, !m && "function" == typeof define && define.amd ? define((e.GreenSockAMDPath ? e.GreenSockAMDPath + "/": "") + r.split(".").pop(), [],
                function() {
                    return p
                }) : r === t && m && (module.exports = p)), g = 0; g < this.sc.length; g++) this.sc[g].check()
            },
            this.check(!0)
        },
        m = e._gsDefine = function(e, t, n, r) {
            return new v(e, t, n, r)
        },
        g = f._class = function(e, t, n) {
            return t = t ||
            function() {},
            m(e, [],
            function() {
                return t
            },
            n),
            t
        };
        m.globals = n;
        var y = [0, 0, 1, 1],
        b = [],
        w = g("easing.Ease",
        function(e, t, n, r) {
            this._func = e,
            this._type = n || 0,
            this._power = r || 0,
            this._params = t ? y.concat(t) : y
        },
        !0),
        E = w.map = {},
        S = w.register = function(e, t, n, r) {
            for (var i, s, o, u, a = t.split(","), l = a.length, c = (n || "easeIn,easeOut,easeInOut").split(","); --l > -1;) for (s = a[l], i = r ? g("easing." + s, null, !0) : f.easing[s] || {},
            o = c.length; --o > -1;) u = c[o],
            E[s + "." + u] = E[u + s] = i[u] = e.getRatio ? e: e[u] || new e
        };
        for (s = w.prototype, s._calcEnd = !1, s.getRatio = function(e) {
            if (this._func) return this._params[0] = e,
            this._func.apply(null, this._params);
            var t = this._type,
            n = this._power,
            r = 1 === t ? 1 - e: 2 === t ? e: .5 > e ? 2 * e: 2 * (1 - e);
            return 1 === n ? r *= r: 2 === n ? r *= r * r: 3 === n ? r *= r * r * r: 4 === n && (r *= r * r * r * r),
            1 === t ? 1 - r: 2 === t ? r: .5 > e ? r / 2 : 1 - r / 2
        },
        r = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], i = r.length; --i > -1;) s = r[i] + ",Power" + i,
        S(new w(null, null, 1, i), s, "easeOut", !0),
        S(new w(null, null, 2, i), s, "easeIn" + (0 === i ? ",easeNone": "")),
        S(new w(null, null, 3, i), s, "easeInOut");
        E.linear = f.easing.Linear.easeIn,
        E.swing = f.easing.Quad.easeInOut;
        var x = g("events.EventDispatcher",
        function(e) {
            this._listeners = {},
            this._eventTarget = e || this
        });
        s = x.prototype,
        s.addEventListener = function(e, t, n, r, i) {
            i = i || 0;
            var s, a, f = this._listeners[e],
            l = 0;
            for (null == f && (this._listeners[e] = f = []), a = f.length; --a > -1;) s = f[a],
            s.c === t && s.s === n ? f.splice(a, 1) : 0 === l && s.pr < i && (l = a + 1);
            f.splice(l, 0, {
                c: t,
                s: n,
                up: r,
                pr: i
            }),
            this !== o || u || o.wake()
        },
        s.removeEventListener = function(e, t) {
            var n, r = this._listeners[e];
            if (r) for (n = r.length; --n > -1;) if (r[n].c === t) return void r.splice(n, 1)
        },
        s.dispatchEvent = function(e) {
            var t, n, r, i = this._listeners[e];
            if (i) for (t = i.length, n = this._eventTarget; --t > -1;) r = i[t],
            r && (r.up ? r.c.call(r.s || n, {
                type: e,
                target: n
            }) : r.c.call(r.s || n))
        };
        var T = e.requestAnimationFrame,
        N = e.cancelAnimationFrame,
        C = Date.now ||
        function() {
            return (new Date).getTime()
        },
        k = C();
        for (r = ["ms", "moz", "webkit", "o"], i = r.length; --i > -1 && !T;) T = e[r[i] + "RequestAnimationFrame"],
        N = e[r[i] + "CancelAnimationFrame"] || e[r[i] + "CancelRequestAnimationFrame"];
        g("Ticker",
        function(e, t) {
            var n, r, i, s, a, f = this,
            c = C(),
            p = t !== !1 && T ? "auto": !1,
            d = 500,
            v = 33,
            m = "tick",
            g = function(e) {
                var t, o, u = C() - k;
                u > d && (c += u - v),
                k += u,
                f.time = (k - c) / 1e3,
                t = f.time - a,
                (!n || t > 0 || e === !0) && (f.frame++, a += t + (t >= s ? .004 : s - t), o = !0),
                e !== !0 && (i = r(g)),
                o && f.dispatchEvent(m)
            };
            x.call(f),
            f.time = f.frame = 0,
            f.tick = function() {
                g(!0)
            },
            f.lagSmoothing = function(e, t) {
                d = e || 1 / l,
                v = Math.min(t, d, 0)
            },
            f.sleep = function() {
                null != i && (p && N ? N(i) : clearTimeout(i), r = h, i = null, f === o && (u = !1))
            },
            f.wake = function(e) {
                null !== i ? f.sleep() : e ? c += -k + (k = C()) : f.frame > 10 && (k = C() - d + 5),
                r = 0 === n ? h: p && T ? T: function(e) {
                    return setTimeout(e, 1e3 * (a - f.time) + 1 | 0)
                },
                f === o && (u = !0),
                g(2)
            },
            f.fps = function(e) {
                return arguments.length ? (n = e, s = 1 / (n || 60), a = this.time + s, void f.wake()) : n
            },
            f.useRAF = function(e) {
                return arguments.length ? (f.sleep(), p = e, void f.fps(n)) : p
            },
            f.fps(e),
            setTimeout(function() {
                "auto" === p && f.frame < 5 && "hidden" !== document.visibilityState && f.useRAF(!1)
            },
            1500)
        }),
        s = f.Ticker.prototype = new f.events.EventDispatcher,
        s.constructor = f.Ticker;
        var L = g("core.Animation",
        function(e, t) {
            if (this.vars = t = t || {},
            this._duration = this._totalDuration = e || 0, this._delay = Number(t.delay) || 0, this._timeScale = 1, this._active = t.immediateRender === !0, this.data = t.data, this._reversed = t.reversed === !0, $) {
                u || o.wake();
                var n = this.vars.useFrames ? V: $;
                n.add(this, n._time),
                this.vars.paused && this.paused(!0)
            }
        });
        o = L.ticker = new f.Ticker,
        s = L.prototype,
        s._dirty = s._gc = s._initted = s._paused = !1,
        s._totalTime = s._time = 0,
        s._rawPrevTime = -1,
        s._next = s._last = s._onUpdate = s._timeline = s.timeline = null,
        s._paused = !1;
        var A = function() {
            u && C() - k > 2e3 && o.wake(),
            setTimeout(A, 2e3)
        };
        A(),
        s.play = function(e, t) {
            return null != e && this.seek(e, t),
            this.reversed(!1).paused(!1)
        },
        s.pause = function(e, t) {
            return null != e && this.seek(e, t),
            this.paused(!0)
        },
        s.resume = function(e, t) {
            return null != e && this.seek(e, t),
            this.paused(!1)
        },
        s.seek = function(e, t) {
            return this.totalTime(Number(e), t !== !1)
        },
        s.restart = function(e, t) {
            return this.reversed(!1).paused(!1).totalTime(e ? -this._delay: 0, t !== !1, !0)
        },
        s.reverse = function(e, t) {
            return null != e && this.seek(e || this.totalDuration(), t),
            this.reversed(!0).paused(!1)
        },
        s.render = function(e, t, n) {},
        s.invalidate = function() {
            return this._time = this._totalTime = 0,
            this._initted = this._gc = !1,
            this._rawPrevTime = -1,
            (this._gc || !this.timeline) && this._enabled(!0),
            this
        },
        s.isActive = function() {
            var e, t = this._timeline,
            n = this._startTime;
            return ! t || !this._gc && !this._paused && t.isActive() && (e = t.rawTime()) >= n && e < n + this.totalDuration() / this._timeScale
        },
        s._enabled = function(e, t) {
            return u || o.wake(),
            this._gc = !e,
            this._active = this.isActive(),
            t !== !0 && (e && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !e && this.timeline && this._timeline._remove(this, !0)),
            !1
        },
        s._kill = function(e, t) {
            return this._enabled(!1, !1)
        },
        s.kill = function(e, t) {
            return this._kill(e, t),
            this
        },
        s._uncache = function(e) {
            for (var t = e ? this: this.timeline; t;) t._dirty = !0,
            t = t.timeline;
            return this
        },
        s._swapSelfInParams = function(e) {
            for (var t = e.length,
            n = e.concat(); --t > -1;)"{self}" === e[t] && (n[t] = this);
            return n
        },
        s._callback = function(e) {
            var t = this.vars;
            t[e].apply(t[e + "Scope"] || t.callbackScope || this, t[e + "Params"] || b)
        },
        s.eventCallback = function(e, t, n, r) {
            if ("on" === (e || "").substr(0, 2)) {
                var i = this.vars;
                if (1 === arguments.length) return i[e];
                null == t ? delete i[e] : (i[e] = t, i[e + "Params"] = p(n) && -1 !== n.join("").indexOf("{self}") ? this._swapSelfInParams(n) : n, i[e + "Scope"] = r),
                "onUpdate" === e && (this._onUpdate = t)
            }
            return this
        },
        s.delay = function(e) {
            return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + e - this._delay), this._delay = e, this) : this._delay
        },
        s.duration = function(e) {
            return arguments.length ? (this._duration = this._totalDuration = e, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== e && this.totalTime(this._totalTime * (e / this._duration), !0), this) : (this._dirty = !1, this._duration)
        },
        s.totalDuration = function(e) {
            return this._dirty = !1,
            arguments.length ? this.duration(e) : this._totalDuration
        },
        s.time = function(e, t) {
            return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(e > this._duration ? this._duration: e, t)) : this._time
        },
        s.totalTime = function(e, t, n) {
            if (u || o.wake(), !arguments.length) return this._totalTime;
            if (this._timeline) {
                if (0 > e && !n && (e += this.totalDuration()), this._timeline.smoothChildTiming) {
                    this._dirty && this.totalDuration();
                    var r = this._totalDuration,
                    i = this._timeline;
                    if (e > r && !n && (e = r), this._startTime = (this._paused ? this._pauseTime: i._time) - (this._reversed ? r - e: e) / this._timeScale, i._dirty || this._uncache(!1), i._timeline) for (; i._timeline;) i._timeline._time !== (i._startTime + i._totalTime) / i._timeScale && i.totalTime(i._totalTime, !0),
                    i = i._timeline
                }
                this._gc && this._enabled(!0, !1),
                (this._totalTime !== e || 0 === this._duration) && (P.length && K(), this.render(e, t, !1), P.length && K())
            }
            return this
        },
        s.progress = s.totalProgress = function(e, t) {
            var n = this.duration();
            return arguments.length ? this.totalTime(n * e, t) : n ? this._time / n: this.ratio
        },
        s.startTime = function(e) {
            return arguments.length ? (e !== this._startTime && (this._startTime = e, this.timeline && this.timeline._sortChildren && this.timeline.add(this, e - this._delay)), this) : this._startTime
        },
        s.endTime = function(e) {
            return this._startTime + (0 != e ? this.totalDuration() : this.duration()) / this._timeScale
        },
        s.timeScale = function(e) {
            if (!arguments.length) return this._timeScale;
            if (e = e || l, this._timeline && this._timeline.smoothChildTiming) {
                var t = this._pauseTime,
                n = t || 0 === t ? t: this._timeline.totalTime();
                this._startTime = n - (n - this._startTime) * this._timeScale / e
            }
            return this._timeScale = e,
            this._uncache(!1)
        },
        s.reversed = function(e) {
            return arguments.length ? (e != this._reversed && (this._reversed = e, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime: this._totalTime, !0)), this) : this._reversed
        },
        s.paused = function(e) {
            if (!arguments.length) return this._paused;
            var t, n, r = this._timeline;
            return e != this._paused && r && (u || e || o.wake(), t = r.rawTime(), n = t - this._pauseTime, !e && r.smoothChildTiming && (this._startTime += n, this._uncache(!1)), this._pauseTime = e ? t: null, this._paused = e, this._active = this.isActive(), !e && 0 !== n && this._initted && this.duration() && (t = r.smoothChildTiming ? this._totalTime: (t - this._startTime) / this._timeScale, this.render(t, t === this._totalTime, !0))),
            this._gc && !e && this._enabled(!0, !1),
            this
        };
        var O = g("core.SimpleTimeline",
        function(e) {
            L.call(this, 0, e),
            this.autoRemoveChildren = this.smoothChildTiming = !0
        });
        s = O.prototype = new L,
        s.constructor = O,
        s.kill()._gc = !1,
        s._first = s._last = s._recent = null,
        s._sortChildren = !1,
        s.add = s.insert = function(e, t, n, r) {
            var i, s;
            if (e._startTime = Number(t || 0) + e._delay, e._paused && this !== e._timeline && (e._pauseTime = e._startTime + (this.rawTime() - e._startTime) / e._timeScale), e.timeline && e.timeline._remove(e, !0), e.timeline = e._timeline = this, e._gc && e._enabled(!0, !0), i = this._last, this._sortChildren) for (s = e._startTime; i && i._startTime > s;) i = i._prev;
            return i ? (e._next = i._next, i._next = e) : (e._next = this._first, this._first = e),
            e._next ? e._next._prev = e: this._last = e,
            e._prev = i,
            this._recent = e,
            this._timeline && this._uncache(!0),
            this
        },
        s._remove = function(e, t) {
            return e.timeline === this && (t || e._enabled(!1, !0), e._prev ? e._prev._next = e._next: this._first === e && (this._first = e._next), e._next ? e._next._prev = e._prev: this._last === e && (this._last = e._prev), e._next = e._prev = e.timeline = null, e === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)),
            this
        },
        s.render = function(e, t, n) {
            var r, i = this._first;
            for (this._totalTime = this._time = this._rawPrevTime = e; i;) r = i._next,
            (i._active || e >= i._startTime && !i._paused) && (i._reversed ? i.render((i._dirty ? i.totalDuration() : i._totalDuration) - (e - i._startTime) * i._timeScale, t, n) : i.render((e - i._startTime) * i._timeScale, t, n)),
            i = r
        },
        s.rawTime = function() {
            return u || o.wake(),
            this._totalTime
        };
        var M = g("TweenLite",
        function(t, n, r) {
            if (L.call(this, n, r), this.render = M.prototype.render, null == t) throw "Cannot tween a null target.";
            this.target = t = "string" != typeof t ? t: M.selector(t) || t;
            var i, s, o, u = t.jquery || t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType),
            a = this.vars.overwrite;
            if (this._overwrite = a = null == a ? X[M.defaultOverwrite] : "number" == typeof a ? a >> 0 : X[a], (u || t instanceof Array || t.push && p(t)) && "number" != typeof t[0]) for (this._targets = o = c(t), this._propLookup = [], this._siblings = [], i = 0; i < o.length; i++) s = o[i],
            s ? "string" != typeof s ? s.length && s !== e && s[0] && (s[0] === e || s[0].nodeType && s[0].style && !s.nodeType) ? (o.splice(i--, 1), this._targets = o = o.concat(c(s))) : (this._siblings[i] = Q(s, this, !1), 1 === a && this._siblings[i].length > 1 && Y(s, this, null, 1, this._siblings[i])) : (s = o[i--] = M.selector(s), "string" == typeof s && o.splice(i + 1, 1)) : o.splice(i--, 1);
            else this._propLookup = {},
            this._siblings = Q(t, this, !1),
            1 === a && this._siblings.length > 1 && Y(t, this, null, 1, this._siblings); (this.vars.immediateRender || 0 === n && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -l, this.render( - this._delay))
        },
        !0),
        _ = function(t) {
            return t && t.length && t !== e && t[0] && (t[0] === e || t[0].nodeType && t[0].style && !t.nodeType)
        },
        D = function(e, t) {
            var n, r = {};
            for (n in e) W[n] || n in t && "transform" !== n && "x" !== n && "y" !== n && "width" !== n && "height" !== n && "className" !== n && "border" !== n || !(!R[n] || R[n] && R[n]._autoCSS) || (r[n] = e[n], delete e[n]);
            e.css = r
        };
        s = M.prototype = new L,
        s.constructor = M,
        s.kill()._gc = !1,
        s.ratio = 0,
        s._firstPT = s._targets = s._overwrittenProps = s._startAt = null,
        s._notifyPluginsOfEnabled = s._lazy = !1,
        M.version = "1.18.2",
        M.defaultEase = s._ease = new w(null, null, 1, 1),
        M.defaultOverwrite = "auto",
        M.ticker = o,
        M.autoSleep = 120,
        M.lagSmoothing = function(e, t) {
            o.lagSmoothing(e, t)
        },
        M.selector = e.$ || e.jQuery ||
        function(t) {
            var n = e.$ || e.jQuery;
            return n ? (M.selector = n, n(t)) : "undefined" == typeof document ? t: document.querySelectorAll ? document.querySelectorAll(t) : document.getElementById("#" === t.charAt(0) ? t.substr(1) : t)
        };
        var P = [],
        H = {},
        B = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi,
        j = function(e) {
            for (var t, n = this._firstPT,
            r = 1e-6; n;) t = n.blob ? e ? this.join("") : this.start: n.c * e + n.s,
            n.r ? t = Math.round(t) : r > t && t > -r && (t = 0),
            n.f ? n.fp ? n.t[n.p](n.fp, t) : n.t[n.p](t) : n.t[n.p] = t,
            n = n._next
        },
        F = function(e, t, n, r) {
            var i, s, o, u, a, f, l, c = [e, t],
            h = 0,
            p = "",
            d = 0;
            for (c.start = e, n && (n(c), e = c[0], t = c[1]), c.length = 0, i = e.match(B) || [], s = t.match(B) || [], r && (r._next = null, r.blob = 1, c._firstPT = r), a = s.length, u = 0; a > u; u++) l = s[u],
            f = t.substr(h, t.indexOf(l, h) - h),
            p += f || !u ? f: ",",
            h += f.length,
            d ? d = (d + 1) % 5 : "rgba(" === f.substr( - 5) && (d = 1),
            l === i[u] || i.length <= u ? p += l: (p && (c.push(p), p = ""), o = parseFloat(i[u]), c.push(o), c._firstPT = {
                _next: c._firstPT,
                t: c,
                p: c.length - 1,
                s: o,
                c: ("=" === l.charAt(1) ? parseInt(l.charAt(0) + "1", 10) * parseFloat(l.substr(2)) : parseFloat(l) - o) || 0,
                f: 0,
                r: d && 4 > d
            }),
            h += l.length;
            return p += t.substr(h),
            p && c.push(p),
            c.setRatio = j,
            c
        },
        I = function(e, t, n, r, i, s, o, u) {
            var a, f, l = "get" === n ? e[t] : n,
            c = typeof e[t],
            h = "string" == typeof r && "=" === r.charAt(1),
            p = {
                t: e,
                p: t,
                s: l,
                f: "function" === c,
                pg: 0,
                n: i || t,
                r: s,
                pr: 0,
                c: h ? parseInt(r.charAt(0) + "1", 10) * parseFloat(r.substr(2)) : parseFloat(r) - l || 0
            };
            return "number" !== c && ("function" === c && "get" === n && (f = t.indexOf("set") || "function" != typeof e["get" + t.substr(3)] ? t: "get" + t.substr(3), p.s = l = o ? e[f](o) : e[f]()), "string" == typeof l && (o || isNaN(l)) ? (p.fp = o, a = F(l, r, u || M.defaultStringFilter, p), p = {
                t: a,
                p: "setRatio",
                s: 0,
                c: 1,
                f: 2,
                pg: 0,
                n: i || t,
                pr: 0
            }) : h || (p.s = parseFloat(l), p.c = parseFloat(r) - p.s || 0)),
            p.c ? ((p._next = this._firstPT) && (p._next._prev = p), this._firstPT = p, p) : void 0
        },
        q = M._internals = {
            isArray: p,
            isSelector: _,
            lazyTweens: P,
            blobDif: F
        },
        R = M._plugins = {},
        U = q.tweenLookup = {},
        z = 0,
        W = q.reservedProps = {
            ease: 1,
            delay: 1,
            overwrite: 1,
            onComplete: 1,
            onCompleteParams: 1,
            onCompleteScope: 1,
            useFrames: 1,
            runBackwards: 1,
            startAt: 1,
            onUpdate: 1,
            onUpdateParams: 1,
            onUpdateScope: 1,
            onStart: 1,
            onStartParams: 1,
            onStartScope: 1,
            onReverseComplete: 1,
            onReverseCompleteParams: 1,
            onReverseCompleteScope: 1,
            onRepeat: 1,
            onRepeatParams: 1,
            onRepeatScope: 1,
            easeParams: 1,
            yoyo: 1,
            immediateRender: 1,
            repeat: 1,
            repeatDelay: 1,
            data: 1,
            paused: 1,
            reversed: 1,
            autoCSS: 1,
            lazy: 1,
            onOverwrite: 1,
            callbackScope: 1,
            stringFilter: 1
        },
        X = {
            none: 0,
            all: 1,
            auto: 2,
            concurrent: 3,
            allOnStart: 4,
            preexisting: 5,
            "true": 1,
            "false": 0
        },
        V = L._rootFramesTimeline = new O,
        $ = L._rootTimeline = new O,
        J = 30,
        K = q.lazyRender = function() {
            var e, t = P.length;
            for (H = {}; --t > -1;) e = P[t],
            e && e._lazy !== !1 && (e.render(e._lazy[0], e._lazy[1], !0), e._lazy = !1);
            P.length = 0
        };
        $._startTime = o.time,
        V._startTime = o.frame,
        $._active = V._active = !0,
        setTimeout(K, 1),
        L._updateRoot = M.render = function() {
            var e, t, n;
            if (P.length && K(), $.render((o.time - $._startTime) * $._timeScale, !1, !1), V.render((o.frame - V._startTime) * V._timeScale, !1, !1), P.length && K(), o.frame >= J) {
                J = o.frame + (parseInt(M.autoSleep, 10) || 120);
                for (n in U) {
                    for (t = U[n].tweens, e = t.length; --e > -1;) t[e]._gc && t.splice(e, 1);
                    0 === t.length && delete U[n]
                }
                if (n = $._first, (!n || n._paused) && M.autoSleep && !V._first && 1 === o._listeners.tick.length) {
                    for (; n && n._paused;) n = n._next;
                    n || o.sleep()
                }
            }
        },
        o.addEventListener("tick", L._updateRoot);
        var Q = function(e, t, n) {
            var r, i, s = e._gsTweenID;
            if (U[s || (e._gsTweenID = s = "t" + z++)] || (U[s] = {
                target: e,
                tweens: []
            }), t && (r = U[s].tweens, r[i = r.length] = t, n)) for (; --i > -1;) r[i] === t && r.splice(i, 1);
            return U[s].tweens
        },
        G = function(e, t, n, r) {
            var i, s, o = e.vars.onOverwrite;
            return o && (i = o(e, t, n, r)),
            o = M.onOverwrite,
            o && (s = o(e, t, n, r)),
            i !== !1 && s !== !1
        },
        Y = function(e, t, n, r, i) {
            var s, o, u, a;
            if (1 === r || r >= 4) {
                for (a = i.length, s = 0; a > s; s++) if ((u = i[s]) !== t) u._gc || u._kill(null, e, t) && (o = !0);
                else if (5 === r) break;
                return o
            }
            var f, c = t._startTime + l,
            h = [],
            p = 0,
            d = 0 === t._duration;
            for (s = i.length; --s > -1;)(u = i[s]) === t || u._gc || u._paused || (u._timeline !== t._timeline ? (f = f || Z(t, 0, d), 0 === Z(u, f, d) && (h[p++] = u)) : u._startTime <= c && u._startTime + u.totalDuration() / u._timeScale > c && ((d || !u._initted) && c - u._startTime <= 2e-10 || (h[p++] = u)));
            for (s = p; --s > -1;) if (u = h[s], 2 === r && u._kill(n, e, t) && (o = !0), 2 !== r || !u._firstPT && u._initted) {
                if (2 !== r && !G(u, t)) continue;
                u._enabled(!1, !1) && (o = !0)
            }
            return o
        },
        Z = function(e, t, n) {
            for (var r = e._timeline,
            i = r._timeScale,
            s = e._startTime; r._timeline;) {
                if (s += r._startTime, i *= r._timeScale, r._paused) return - 100;
                r = r._timeline
            }
            return s /= i,
            s > t ? s - t: n && s === t || !e._initted && 2 * l > s - t ? l: (s += e.totalDuration() / e._timeScale / i) > t + l ? 0 : s - t - l
        };
        s._init = function() {
            var e, t, n, r, i, s = this.vars,
            o = this._overwrittenProps,
            u = this._duration,
            a = !!s.immediateRender,
            f = s.ease;
            if (s.startAt) {
                this._startAt && (this._startAt.render( - 1, !0), this._startAt.kill()),
                i = {};
                for (r in s.startAt) i[r] = s.startAt[r];
                if (i.overwrite = !1, i.immediateRender = !0, i.lazy = a && s.lazy !== !1, i.startAt = i.delay = null, this._startAt = M.to(this.target, 0, i), a) if (this._time > 0) this._startAt = null;
                else if (0 !== u) return
            } else if (s.runBackwards && 0 !== u) if (this._startAt) this._startAt.render( - 1, !0),
            this._startAt.kill(),
            this._startAt = null;
            else {
                0 !== this._time && (a = !1),
                n = {};
                for (r in s) W[r] && "autoCSS" !== r || (n[r] = s[r]);
                if (n.overwrite = 0, n.data = "isFromStart", n.lazy = a && s.lazy !== !1, n.immediateRender = a, this._startAt = M.to(this.target, 0, n), a) {
                    if (0 === this._time) return
                } else this._startAt._init(),
                this._startAt._enabled(!1),
                this.vars.immediateRender && (this._startAt = null)
            }
            if (this._ease = f = f ? f instanceof w ? f: "function" == typeof f ? new w(f, s.easeParams) : E[f] || M.defaultEase: M.defaultEase, s.easeParams instanceof Array && f.config && (this._ease = f.config.apply(f, s.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets) for (e = this._targets.length; --e > -1;) this._initProps(this._targets[e], this._propLookup[e] = {},
            this._siblings[e], o ? o[e] : null) && (t = !0);
            else t = this._initProps(this.target, this._propLookup, this._siblings, o);
            if (t && M._onPluginEvent("_onInitAllProps", this), o && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), s.runBackwards) for (n = this._firstPT; n;) n.s += n.c,
            n.c = -n.c,
            n = n._next;
            this._onUpdate = s.onUpdate,
            this._initted = !0
        },
        s._initProps = function(t, n, r, i) {
            var s, o, u, a, f, l;
            if (null == t) return ! 1;
            H[t._gsTweenID] && K(),
            this.vars.css || t.style && t !== e && t.nodeType && R.css && this.vars.autoCSS !== !1 && D(this.vars, t);
            for (s in this.vars) if (l = this.vars[s], W[s]) l && (l instanceof Array || l.push && p(l)) && -1 !== l.join("").indexOf("{self}") && (this.vars[s] = l = this._swapSelfInParams(l, this));
            else if (R[s] && (a = new R[s])._onInitTween(t, this.vars[s], this)) {
                for (this._firstPT = f = {
                    _next: this._firstPT,
                    t: a,
                    p: "setRatio",
                    s: 0,
                    c: 1,
                    f: 1,
                    n: s,
                    pg: 1,
                    pr: a._priority
                },
                o = a._overwriteProps.length; --o > -1;) n[a._overwriteProps[o]] = this._firstPT; (a._priority || a._onInitAllProps) && (u = !0),
                (a._onDisable || a._onEnable) && (this._notifyPluginsOfEnabled = !0),
                f._next && (f._next._prev = f)
            } else n[s] = I.call(this, t, s, "get", l, s, 0, null, this.vars.stringFilter);
            return i && this._kill(i, t) ? this._initProps(t, n, r, i) : this._overwrite > 1 && this._firstPT && r.length > 1 && Y(t, this, n, this._overwrite, r) ? (this._kill(n, t), this._initProps(t, n, r, i)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (H[t._gsTweenID] = !0), u)
        },
        s.render = function(e, t, n) {
            var r, i, s, o, u = this._time,
            a = this._duration,
            f = this._rawPrevTime;
            if (e >= a - 1e-7) this._totalTime = this._time = a,
            this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1,
            this._reversed || (r = !0, i = "onComplete", n = n || this._timeline.autoRemoveChildren),
            0 === a && (this._initted || !this.vars.lazy || n) && (this._startTime === this._timeline._duration && (e = 0), (0 > f || 0 >= e && e >= -1e-7 || f === l && "isPause" !== this.data) && f !== e && (n = !0, f > l && (i = "onReverseComplete")), this._rawPrevTime = o = !t || e || f === e ? e: l);
            else if (1e-7 > e) this._totalTime = this._time = 0,
            this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0,
            (0 !== u || 0 === a && f > 0) && (i = "onReverseComplete", r = this._reversed),
            0 > e && (this._active = !1, 0 === a && (this._initted || !this.vars.lazy || n) && (f >= 0 && (f !== l || "isPause" !== this.data) && (n = !0), this._rawPrevTime = o = !t || e || f === e ? e: l)),
            this._initted || (n = !0);
            else if (this._totalTime = this._time = e, this._easeType) {
                var c = e / a,
                h = this._easeType,
                p = this._easePower; (1 === h || 3 === h && c >= .5) && (c = 1 - c),
                3 === h && (c *= 2),
                1 === p ? c *= c: 2 === p ? c *= c * c: 3 === p ? c *= c * c * c: 4 === p && (c *= c * c * c * c),
                1 === h ? this.ratio = 1 - c: 2 === h ? this.ratio = c: .5 > e / a ? this.ratio = c / 2 : this.ratio = 1 - c / 2
            } else this.ratio = this._ease.getRatio(e / a);
            if (this._time !== u || n) {
                if (!this._initted) {
                    if (this._init(), !this._initted || this._gc) return;
                    if (!n && this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration)) return this._time = this._totalTime = u,
                    this._rawPrevTime = f,
                    P.push(this),
                    void(this._lazy = [e, t]);
                    this._time && !r ? this.ratio = this._ease.getRatio(this._time / a) : r && this._ease._calcEnd && (this.ratio = this._ease.getRatio(0 === this._time ? 0 : 1))
                }
                for (this._lazy !== !1 && (this._lazy = !1), this._active || !this._paused && this._time !== u && e >= 0 && (this._active = !0), 0 === u && (this._startAt && (e >= 0 ? this._startAt.render(e, t, n) : i || (i = "_dummyGS")), this.vars.onStart && (0 !== this._time || 0 === a) && (t || this._callback("onStart"))), s = this._firstPT; s;) s.f ? s.t[s.p](s.c * this.ratio + s.s) : s.t[s.p] = s.c * this.ratio + s.s,
                s = s._next;
                this._onUpdate && (0 > e && this._startAt && e !== -0.0001 && this._startAt.render(e, t, n), t || (this._time !== u || r) && this._callback("onUpdate")),
                i && (!this._gc || n) && (0 > e && this._startAt && !this._onUpdate && e !== -0.0001 && this._startAt.render(e, t, n), r && (this._timeline.autoRemoveChildren && this._enabled(!1, !1), this._active = !1), !t && this.vars[i] && this._callback(i), 0 === a && this._rawPrevTime === l && o !== l && (this._rawPrevTime = 0))
            }
        },
        s._kill = function(e, t, n) {
            if ("all" === e && (e = null), null != e || null != t && t !== this.target) {
                t = "string" != typeof t ? t || this._targets || this.target: M.selector(t) || t;
                var r, i, s, o, u, a, f, l, c, h = n && this._time && n._startTime === this._startTime && this._timeline === n._timeline;
                if ((p(t) || _(t)) && "number" != typeof t[0]) for (r = t.length; --r > -1;) this._kill(e, t[r], n) && (a = !0);
                else {
                    if (this._targets) {
                        for (r = this._targets.length; --r > -1;) if (t === this._targets[r]) {
                            u = this._propLookup[r] || {},
                            this._overwrittenProps = this._overwrittenProps || [],
                            i = this._overwrittenProps[r] = e ? this._overwrittenProps[r] || {}: "all";
                            break
                        }
                    } else {
                        if (t !== this.target) return ! 1;
                        u = this._propLookup,
                        i = this._overwrittenProps = e ? this._overwrittenProps || {}: "all"
                    }
                    if (u) {
                        if (f = e || u, l = e !== i && "all" !== i && e !== u && ("object" != typeof e || !e._tempKill), n && (M.onOverwrite || this.vars.onOverwrite)) {
                            for (s in f) u[s] && (c || (c = []), c.push(s));
                            if ((c || !e) && !G(this, n, t, c)) return ! 1
                        }
                        for (s in f)(o = u[s]) && (h && (o.f ? o.t[o.p](o.s) : o.t[o.p] = o.s, a = !0), o.pg && o.t._kill(f) && (a = !0), o.pg && 0 !== o.t._overwriteProps.length || (o._prev ? o._prev._next = o._next: o === this._firstPT && (this._firstPT = o._next), o._next && (o._next._prev = o._prev), o._next = o._prev = null), delete u[s]),
                        l && (i[s] = 1); ! this._firstPT && this._initted && this._enabled(!1, !1)
                    }
                }
                return a
            }
            return this._lazy = !1,
            this._enabled(!1, !1)
        },
        s.invalidate = function() {
            return this._notifyPluginsOfEnabled && M._onPluginEvent("_onDisable", this),
            this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null,
            this._notifyPluginsOfEnabled = this._active = this._lazy = !1,
            this._propLookup = this._targets ? {}: [],
            L.prototype.invalidate.call(this),
            this.vars.immediateRender && (this._time = -l, this.render( - this._delay)),
            this
        },
        s._enabled = function(e, t) {
            if (u || o.wake(), e && this._gc) {
                var n, r = this._targets;
                if (r) for (n = r.length; --n > -1;) this._siblings[n] = Q(r[n], this, !0);
                else this._siblings = Q(this.target, this, !0)
            }
            return L.prototype._enabled.call(this, e, t),
            this._notifyPluginsOfEnabled && this._firstPT ? M._onPluginEvent(e ? "_onEnable": "_onDisable", this) : !1
        },
        M.to = function(e, t, n) {
            return new M(e, t, n)
        },
        M.from = function(e, t, n) {
            return n.runBackwards = !0,
            n.immediateRender = 0 != n.immediateRender,
            new M(e, t, n)
        },
        M.fromTo = function(e, t, n, r) {
            return r.startAt = n,
            r.immediateRender = 0 != r.immediateRender && 0 != n.immediateRender,
            new M(e, t, r)
        },
        M.delayedCall = function(e, t, n, r, i) {
            return new M(t, 0, {
                delay: e,
                onComplete: t,
                onCompleteParams: n,
                callbackScope: r,
                onReverseComplete: t,
                onReverseCompleteParams: n,
                immediateRender: !1,
                lazy: !1,
                useFrames: i,
                overwrite: 0
            })
        },
        M.set = function(e, t) {
            return new M(e, 0, t)
        },
        M.getTweensOf = function(e, t) {
            if (null == e) return [];
            e = "string" != typeof e ? e: M.selector(e) || e;
            var n, r, i, s;
            if ((p(e) || _(e)) && "number" != typeof e[0]) {
                for (n = e.length, r = []; --n > -1;) r = r.concat(M.getTweensOf(e[n], t));
                for (n = r.length; --n > -1;) for (s = r[n], i = n; --i > -1;) s === r[i] && r.splice(n, 1)
            } else for (r = Q(e).concat(), n = r.length; --n > -1;)(r[n]._gc || t && !r[n].isActive()) && r.splice(n, 1);
            return r
        },
        M.killTweensOf = M.killDelayedCallsTo = function(e, t, n) {
            "object" == typeof t && (n = t, t = !1);
            for (var r = M.getTweensOf(e, t), i = r.length; --i > -1;) r[i]._kill(n, e)
        };
        var et = g("plugins.TweenPlugin",
        function(e, t) {
            this._overwriteProps = (e || "").split(","),
            this._propName = this._overwriteProps[0],
            this._priority = t || 0,
            this._super = et.prototype
        },
        !0);
        if (s = et.prototype, et.version = "1.18.0", et.API = 2, s._firstPT = null, s._addTween = I, s.setRatio = j, s._kill = function(e) {
            var t, n = this._overwriteProps,
            r = this._firstPT;
            if (null != e[this._propName]) this._overwriteProps = [];
            else for (t = n.length; --t > -1;) null != e[n[t]] && n.splice(t, 1);
            for (; r;) null != e[r.n] && (r._next && (r._next._prev = r._prev), r._prev ? (r._prev._next = r._next, r._prev = null) : this._firstPT === r && (this._firstPT = r._next)),
            r = r._next;
            return ! 1
        },
        s._roundProps = function(e, t) {
            for (var n = this._firstPT; n;)(e[this._propName] || null != n.n && e[n.n.split(this._propName + "_").join("")]) && (n.r = t),
            n = n._next
        },
        M._onPluginEvent = function(e, t) {
            var n, r, i, s, o, u = t._firstPT;
            if ("_onInitAllProps" === e) {
                for (; u;) {
                    for (o = u._next, r = i; r && r.pr > u.pr;) r = r._next; (u._prev = r ? r._prev: s) ? u._prev._next = u: i = u,
                    (u._next = r) ? r._prev = u: s = u,
                    u = o
                }
                u = t._firstPT = i
            }
            for (; u;) u.pg && "function" == typeof u.t[e] && u.t[e]() && (n = !0),
            u = u._next;
            return n
        },
        et.activate = function(e) {
            for (var t = e.length; --t > -1;) e[t].API === et.API && (R[(new e[t])._propName] = e[t]);
            return ! 0
        },
        m.plugin = function(e) {
            if (! (e && e.propName && e.init && e.API)) throw "illegal plugin definition.";
            var t, n = e.propName,
            r = e.priority || 0,
            i = e.overwriteProps,
            s = {
                init: "_onInitTween",
                set: "setRatio",
                kill: "_kill",
                round: "_roundProps",
                initAll: "_onInitAllProps"
            },
            o = g("plugins." + n.charAt(0).toUpperCase() + n.substr(1) + "Plugin",
            function() {
                et.call(this, n, r),
                this._overwriteProps = i || []
            },
            e.global === !0),
            u = o.prototype = new et(n);
            u.constructor = o,
            o.API = e.API;
            for (t in s)"function" == typeof e[t] && (u[s[t]] = e[t]);
            return o.version = e.version,
            et.activate([o]),
            o
        },
        r = e._gsQueue) {
            for (i = 0; i < r.length; i++) r[i]();
            for (s in d) d[s].func || e.console.log("GSAP encountered missing dependency: com.greensock." + s)
        }
        u = !1
    }
} ("undefined" != typeof module && module.exports && "undefined" != typeof global ? global: this || window, "TweenMax"),
define("TweenMax",
function() {}),
define("app/birds/Boid", [],
function() {
    var e = function() {
        var e = new THREE.Vector3,
        t, n = 500,
        r = 500,
        i = 200,
        s, o = 100,
        u = 4,
        a = .1,
        f = !1;
        this.position = new THREE.Vector3,
        this.velocity = new THREE.Vector3,
        t = new THREE.Vector3,
        this.setGoal = function(e) {
            s = e
        },
        this.setAvoidWalls = function(e) {
            f = e
        },
        this.setWorldSize = function(e, t, s) {
            n = e,
            r = t,
            i = s
        },
        this.run = function(s) {
            f && (e.set( - n, this.position.y, this.position.z), e = this.avoid(e), e.multiplyScalar(5), t.add(e), e.set(n, this.position.y, this.position.z), e = this.avoid(e), e.multiplyScalar(5), t.add(e), e.set(this.position.x, -r, this.position.z), e = this.avoid(e), e.multiplyScalar(5), t.add(e), e.set(this.position.x, r, this.position.z), e = this.avoid(e), e.multiplyScalar(5), t.add(e), e.set(this.position.x, this.position.y, -i), e = this.avoid(e), e.multiplyScalar(5), t.add(e), e.set(this.position.x, this.position.y, i), e = this.avoid(e), e.multiplyScalar(5), t.add(e)),
            Math.random() > .5 && this.flock(s),
            this.move()
        },
        this.flock = function(e) {
            s && t.add(this.reach(s, .005)),
            t.add(this.alignment(e)),
            t.add(this.cohesion(e)),
            t.add(this.separation(e))
        },
        this.move = function() {
            this.velocity.add(t);
            var e = this.velocity.length();
            e > u && this.velocity.divideScalar(e / u),
            this.position.add(this.velocity),
            t.set(0, 0, 0)
        },
        this.checkBounds = function() {
            this.position.x > n && (this.position.x = -n),
            this.position.x < -n && (this.position.x = n),
            this.position.y > r && (this.position.y = -r),
            this.position.y < -r && (this.position.y = r),
            this.position.z > i && (this.position.z = -i),
            this.position.z < -i && (this.position.z = i)
        },
        this.avoid = function(e) {
            var t = new THREE.Vector3;
            return t.copy(this.position),
            t.sub(e),
            t.multiplyScalar(1 / this.position.distanceToSquared(e)),
            t
        },
        this.repulse = function(e) {
            var n = this.position.distanceTo(e);
            if (n < 150) {
                var r = new THREE.Vector3;
                r.subVectors(this.position, e),
                r.multiplyScalar(.5 / n),
                t.add(r)
            }
        },
        this.reach = function(e, t) {
            var n = new THREE.Vector3;
            return n.subVectors(e, this.position),
            n.multiplyScalar(t),
            n
        },
        this.alignment = function(e) {
            var t, n = new THREE.Vector3,
            r = 0;
            for (var i = 0,
            s = e.length; i < s; i++) {
                if (Math.random() > .6) continue;
                t = e[i],
                distance = t.position.distanceTo(this.position),
                distance > 0 && distance <= o && (n.add(t.velocity), r++)
            }
            if (r > 0) {
                n.divideScalar(r);
                var u = n.length();
                u > a && n.divideScalar(u / a)
            }
            return n
        },
        this.cohesion = function(e) {
            var t, n, r = new THREE.Vector3,
            i = new THREE.Vector3,
            s = 0;
            for (var u = 0,
            f = e.length; u < f; u++) {
                if (Math.random() > .6) continue;
                t = e[u],
                n = t.position.distanceTo(this.position),
                n > 0 && n <= o && (r.add(t.position), s++)
            }
            s > 0 && r.divideScalar(s),
            i.subVectors(r, this.position);
            var l = i.length();
            return l > a && i.divideScalar(l / a),
            i
        },
        this.separation = function(e) {
            var t, n, r = new THREE.Vector3,
            i = new THREE.Vector3;
            for (var s = 0,
            u = e.length; s < u; s++) {
                if (Math.random() > .6) continue;
                t = e[s],
                n = t.position.distanceTo(this.position),
                n > 0 && n <= o && (i.subVectors(this.position, t.position), i.normalize(), i.divideScalar(n), r.add(i))
            }
            return r
        }
    };
    return e
}),
define("app/birds/Birds", ["app/birds/Boid"],
function(e) {
    var t = function() {
        var t = window.innerWidth,
        n = window.innerHeight,
        r = t / 2,
        i = n / 2,
        s = this,
        o = !1,
        u, a, f, l, c, h, p, d;
        this.init = function(e) {
            s._init(),
            s._animate()
        },
        this.play = function() {
            o = !0
        },
        this.pause = function() {
            o = !1
        },
        this.startMouseMove = function() {
            document.addEventListener("mousemove", s._onDocumentMouseMove, !1)
        },
        this.stopMouseMove = function() {
            document.removeEventListener("mousemove", s._onDocumentMouseMove, !1)
        },
        this._init = function() {
            _container = document.getElementById("birds-canvas-holder"),
            u = new THREE.PerspectiveCamera(75, t / n, 1, 1e4),
            u.position.z = 450,
            a = new THREE.Scene,
            l = [],
            p = [];
            for (var r = 0; r < 200; r++) h = p[r] = new e,
            h.position.x = Math.random() * 400 - 200,
            h.position.y = Math.random() * 400 - 200,
            h.position.z = Math.random() * 400 - 200,
            h.velocity.x = Math.random() * 2 - 1,
            h.velocity.y = Math.random() * 2 - 1,
            h.velocity.z = Math.random() * 2 - 1,
            h.setAvoidWalls(!0),
            h.setWorldSize(500, 500, 400),
            c = l[r] = new THREE.Mesh(new Bird, new THREE.MeshBasicMaterial({
                color: Math.random() * 16777215,
                side: THREE.DoubleSide
            })),
            c.phase = Math.floor(Math.random() * 62.83),
            a.add(c);
            f = new THREE.CanvasRenderer({
                alpha: !0
            }),
            f.setPixelRatio(window.devicePixelRatio),
            f.setSize(t, n),
            _container.appendChild(f.domElement),
            window.addEventListener("resize", s._onWindowResize, !1)
        },
        this._onWindowResize = function() {
            u.aspect = window.innerWidth / window.innerHeight,
            u.updateProjectionMatrix(),
            f.setSize(window.innerWidth, window.innerHeight)
        },
        this._onDocumentMouseMove = function(e) {
            var t = new THREE.Vector3(e.clientX - r, -e.clientY + i, 0);
            for (var n = 0,
            s = p.length; n < s; n++) h = p[n],
            t.z = h.position.z,
            h.repulse(t)
        },
        this._animate = function() {
            requestAnimationFrame(s._animate),
            o && s._render()
        },
        this._render = function() {
            for (var e = 0,
            t = l.length; e < t; e++) h = p[e],
            h.run(p),
            c = l[e],
            c.position.copy(p[e].position),
            color = c.material.color,
            color.r = color.g = color.b = (500 - c.position.z) / 1e3,
            c.rotation.y = Math.atan2( - h.velocity.z, h.velocity.x),
            c.rotation.z = Math.asin(h.velocity.y / h.velocity.length()),
            c.phase = (c.phase + (Math.max(0, c.rotation.z) + .1)) % 62.83,
            c.geometry.vertices[5].y = c.geometry.vertices[4].y = Math.sin(c.phase) * 5;
            f.render(a, u)
        },
        this._initOnScroll = function() {
            $(window).scroll(function() {
                s._scroll()
            })
        },
        this._scroll = function() {},
        this._initOnResize = function() {
            $(window).resize(function() {
                s._resize()
            })
        },
        this._resize = function() {}
    };
    return t
}),
define("app/assetsProvider/General", [],
function() {
    var e = function() {
        var e = this,
        t = [],
        n = [],
        r = [];
        this.init = function() {
            e._init()
        },
        this.provideImages = function() {
            return t
        },
        this.provideSounds = function() {
            return n
        },
        this.provideVideos = function() {
            return r
        },
        this._init = function() {
            e._findImages()
        },
        this._findImages = function() {
            t = [App.BASEURL + "/assets/imgs/general/intro/lake/0.jpg", App.BASEURL + "/assets/imgs/general/intro/lake/1.jpg", App.BASEURL + "/assets/imgs/general/intro/lake/2.jpg", App.BASEURL + "/assets/imgs/general/intro/lake/3.jpg", App.BASEURL + "/assets/imgs/general/intro/lake/12.jpg", App.BASEURL + "/assets/imgs/general/intro/lake/timbro.jpg", App.BASEURL + "/assets/imgs/general/intro/garden/0.jpg", App.BASEURL + "/assets/imgs/general/intro/garden/1.jpg", App.BASEURL + "/assets/imgs/general/intro/garden/2.jpg", App.BASEURL + "/assets/imgs/general/intro/garden/3.jpg", App.BASEURL + "/assets/imgs/general/intro/garden/12.jpg", App.BASEURL + "/assets/imgs/general/intro/garden/timbro.jpg", App.BASEURL + "/assets/imgs/general/intro/eyes/0.jpg", App.BASEURL + "/assets/imgs/general/intro/eyes/1.jpg", App.BASEURL + "/assets/imgs/general/intro/eyes/2.jpg", App.BASEURL + "/assets/imgs/general/intro/eyes/3.jpg", App.BASEURL + "/assets/imgs/general/intro/eyes/12.jpg", App.BASEURL + "/assets/imgs/general/intro/eyes/timbro.jpg", App.BASEURL + "/assets/imgs/general/fluid-footer.png", App.BASEURL + "/assets/imgs/general/monkey-footer.jpg"]
        },
        this._findSounds = function() {
            n = []
        },
        this._findVideos = function() {
            r = []
        }
    };
    return e
}),
define("app/assetsProvider/Lake", [],
function() {
    var e = function() {
        var e = this,
        t = [],
        n = [],
        r = [];
        this.init = function() {
            e._init()
        },
        this.provideImages = function() {
            return t
        },
        this.provideSounds = function() {
            return n
        },
        this.provideVideos = function() {
            return r
        },
        this._init = function() {
            e._findImages(),
            e._findSounds()
        },
        this._findImages = function() {
            t = [App.BASEURL + "/assets/imgs/lake/image-strip-1.jpg", App.BASEURL + "/assets/imgs/lake/image-strip-2.jpg", App.BASEURL + "/assets/imgs/lake/image-strip-3.jpg", App.BASEURL + "/assets/imgs/lake/image-strip-4.jpg", App.BASEURL + "/assets/imgs/lake/image-strip-5.jpg", App.BASEURL + "/assets/imgs/lake/image-strip-6.jpg", App.BASEURL + "/assets/imgs/lake/image-strip-7.jpg", App.BASEURL + "/assets/imgs/lake/image-strip-8.jpg", App.BASEURL + "/assets/imgs/lake/image-strip-9.jpg", App.BASEURL + "/assets/imgs/lake/image-strip-10.jpg", App.BASEURL + "/assets/imgs/lake/image-strip-11.jpg", App.BASEURL + "/assets/imgs/lake/image-strip-12.jpg", App.BASEURL + "/assets/imgs/lake/main.jpg", App.BASEURL + "/assets/imgs/lake/main-1.jpg", App.BASEURL + "/assets/imgs/lake/main-2.jpg", App.BASEURL + "/assets/imgs/lake/main-3.jpg", App.BASEURL + "/assets/imgs/lake/main-4.jpg", App.BASEURL + "/assets/imgs/lake/main-5.jpg", App.BASEURL + "/assets/imgs/lake/main-6.jpg", App.BASEURL + "/assets/imgs/lake/main-7.jpg", App.BASEURL + "/assets/imgs/lake/alberto.png", App.BASEURL + "/assets/imgs/lake/alessia.png", App.BASEURL + "/assets/imgs/lake/anita-maxi.png", App.BASEURL + "/assets/imgs/lake/cr-428.png", App.BASEURL + "/assets/imgs/lake/francy.png", App.BASEURL + "/assets/imgs/lake/funghetto.png", App.BASEURL + "/assets/imgs/lake/giulia.png", App.BASEURL + "/assets/imgs/lake/lisa.png", App.BASEURL + "/assets/imgs/lake/paolo.png", App.BASEURL + "/assets/imgs/lake/peppino.png", App.BASEURL + "/assets/imgs/lake/sansone.png", App.BASEURL + "/assets/imgs/lake/tommy.png", App.BASEURL + "/assets/imgs/lake/gioconda.png", App.BASEURL + "/assets/imgs/lake/manuela.png", App.BASEURL + "/assets/imgs/lake/egidio.png", App.BASEURL + "/assets/imgs/lake/disegni/alberto-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/alessia-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/anitamaxi-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/aurora-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/cr428-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/sansone-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/egidio-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/francy-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/funghetto-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/gioconda-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/giulia-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/lisa-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/manuela-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/paolo-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/peppino-tech.png", App.BASEURL + "/assets/imgs/lake/disegni/tommy-tech.png", App.BASEURL + "/assets/imgs/lake/bianconiglio.jpg", App.BASEURL + "/assets/imgs/lake/buddha.png", App.BASEURL + "/assets/imgs/lake/gabbia.png", App.BASEURL + "/assets/imgs/lake/fish/01.jpg", App.BASEURL + "/assets/imgs/lake/fish/02.jpg", App.BASEURL + "/assets/imgs/lake/fish/03.jpg", App.BASEURL + "/assets/imgs/lake/fish/04.jpg"]
        },
        this._findSounds = function() {
            n = [App.BASEURL + "/assets/audio/lake-loop.mp3", App.BASEURL + "/assets/audio/monkey.mp3"]
        },
        this._findVideos = function() {
            r = []
        }
    };
    return e
}),
define("app/assetsProvider/Garden", [],
function() {
    var e = function() {
        var e = this,
        t = [],
        n = [],
        r = [];
        this.init = function() {
            e._init()
        },
        this.provideImages = function() {
            return t
        },
        this.provideSounds = function() {
            return n
        },
        this.provideVideos = function() {
            return r
        },
        this._init = function() {
            e._findImages(),
            e._findSounds()
        },
        this._findImages = function() {
            t = [App.BASEURL + "/assets/imgs/garden/image-strip-1.jpg", App.BASEURL + "/assets/imgs/garden/image-strip-2.jpg", App.BASEURL + "/assets/imgs/garden/image-strip-3.jpg", App.BASEURL + "/assets/imgs/garden/image-strip-4.jpg", App.BASEURL + "/assets/imgs/garden/image-strip-5.jpg", App.BASEURL + "/assets/imgs/garden/image-strip-6.jpg", App.BASEURL + "/assets/imgs/garden/image-strip-7.jpg", App.BASEURL + "/assets/imgs/garden/image-strip-8.jpg", App.BASEURL + "/assets/imgs/garden/image-strip-9.jpg", App.BASEURL + "/assets/imgs/garden/image-strip-10.jpg", App.BASEURL + "/assets/imgs/garden/image-strip-11.jpg", App.BASEURL + "/assets/imgs/garden/image-strip-12.jpg", App.BASEURL + "/assets/imgs/garden/main.jpg", App.BASEURL + "/assets/imgs/garden/main-1.jpg", App.BASEURL + "/assets/imgs/garden/main-2.jpg", App.BASEURL + "/assets/imgs/garden/main-3.jpg", App.BASEURL + "/assets/imgs/garden/products-1.jpg", App.BASEURL + "/assets/imgs/garden/products-2.jpg", App.BASEURL + "/assets/imgs/garden/products-3.jpg", App.BASEURL + "/assets/imgs/garden/products-4.jpg", App.BASEURL + "/assets/imgs/garden/products-5.jpg", App.BASEURL + "/assets/imgs/garden/products-6.jpg", App.BASEURL + "/assets/imgs/garden/products-7.jpg", App.BASEURL + "/assets/imgs/garden/products-8.jpg", App.BASEURL + "/assets/imgs/garden/products-9.jpg", App.BASEURL + "/assets/imgs/garden/disegni/anitamaxi-tech.png", App.BASEURL + "/assets/imgs/garden/disegni/gnomo-tech.png", App.BASEURL + "/assets/imgs/garden/disegni/gnoma-tech.png", App.BASEURL + "/assets/imgs/garden/disegni/gnomino-tech.png", App.BASEURL + "/assets/imgs/garden/disegni/anita-tech.png", App.BASEURL + "/assets/imgs/garden/disegni/ercole-tech.png", App.BASEURL + "/assets/imgs/garden/disegni/gioconda-tech.png", App.BASEURL + "/assets/imgs/garden/disegni/lola-tech.png", App.BASEURL + "/assets/imgs/garden/disegni/lampada-flo-tech.png", App.BASEURL + "/assets/imgs/garden/disegni/manuela-tech.png", App.BASEURL + "/assets/imgs/garden/disegni/sansotto-tech.png", App.BASEURL + "/assets/imgs/garden/disegni/pio-tech.png", App.BASEURL + "/assets/imgs/garden/disegni/sedia-tech.png", App.BASEURL + "/assets/imgs/garden/disegni/pony-tech.png", App.BASEURL + "/assets/imgs/garden/metamorfosi-1.jpg", App.BASEURL + "/assets/imgs/garden/metamorfosi-2.jpg", App.BASEURL + "/assets/imgs/garden/metamorfosi-3.jpg", App.BASEURL + "/assets/imgs/garden/principessa.png", App.BASEURL + "/assets/imgs/garden/principessa-braccio.png", App.BASEURL + "/assets/imgs/garden/principessa-busto.png", App.BASEURL + "/assets/imgs/garden/principessa-rana.png", App.BASEURL + "/assets/imgs/garden/principessa-testa.png", App.BASEURL + "/assets/imgs/garden/canvas-tree.png"]
        },
        this._findSounds = function() {
            n = [App.BASEURL + "/assets/audio/frog-loop.mp3", App.BASEURL + "/assets/audio/monkey.mp3"]
        },
        this._findVideos = function() {
            r = []
        }
    };
    return e
}),
define("app/assetsProvider/Eyes", [],
function() {
    var e = function() {
        var e = this,
        t = [],
        n = [],
        r = [];
        this.init = function() {
            e._init()
        },
        this.provideImages = function() {
            return t
        },
        this.provideSounds = function() {
            return n
        },
        this.provideVideos = function() {
            return r
        },
        this._init = function() {
            e._findImages(),
            e._findSounds()
        },
        this._findImages = function() {
            t = [App.BASEURL + "/assets/imgs/eyes/image-strip-1.jpg", App.BASEURL + "/assets/imgs/eyes/image-strip-2.jpg", App.BASEURL + "/assets/imgs/eyes/image-strip-3.jpg", App.BASEURL + "/assets/imgs/eyes/image-strip-4.jpg", App.BASEURL + "/assets/imgs/eyes/image-strip-5.jpg", App.BASEURL + "/assets/imgs/eyes/image-strip-6.jpg", App.BASEURL + "/assets/imgs/eyes/image-strip-7.jpg", App.BASEURL + "/assets/imgs/eyes/image-strip-8.jpg", App.BASEURL + "/assets/imgs/eyes/image-strip-9.jpg", App.BASEURL + "/assets/imgs/eyes/image-strip-10.jpg", App.BASEURL + "/assets/imgs/eyes/image-strip-11.jpg", App.BASEURL + "/assets/imgs/eyes/image-strip-12.jpg", App.BASEURL + "/assets/imgs/eyes/main.jpg", App.BASEURL + "/assets/imgs/eyes/products-1.jpg", App.BASEURL + "/assets/imgs/eyes/products-2.jpg", App.BASEURL + "/assets/imgs/eyes/products-3.jpg", App.BASEURL + "/assets/imgs/eyes/products-4.jpg", App.BASEURL + "/assets/imgs/eyes/products-5.jpg", App.BASEURL + "/assets/imgs/eyes/products-6.jpg", App.BASEURL + "/assets/imgs/eyes/products-7.jpg", App.BASEURL + "/assets/imgs/eyes/products-8.jpg", App.BASEURL + "/assets/imgs/eyes/disegni/ares-8881-tech.png", App.BASEURL + "/assets/imgs/eyes/disegni/ares-8883-tech.png", App.BASEURL + "/assets/imgs/eyes/disegni/ares-8885-tech.png", App.BASEURL + "/assets/imgs/eyes/disegni/ares-8887-tech.png", App.BASEURL + "/assets/imgs/eyes/disegni/dafne-904-tech.png", App.BASEURL + "/assets/imgs/eyes/disegni/dafne-941-b-tech.png", App.BASEURL + "/assets/imgs/eyes/disegni/dafne-948-tech.png", App.BASEURL + "/assets/imgs/eyes/disegni/dafne-948-tech-left.png", App.BASEURL + "/assets/imgs/eyes/disegni/dafne-948-tech-right.png", App.BASEURL + "/assets/imgs/eyes/disegni/poltrona-tech.png", App.BASEURL + "/assets/imgs/eyes/gufo.png"]
        },
        this._findSounds = function() {
            n = [App.BASEURL + "/assets/audio/owl-loop.mp3", App.BASEURL + "/assets/audio/monkey.mp3"]
        },
        this._findVideos = function() {
            r = []
        }
    };
    return e
}),
define("app/canvas/Lake", [],
function() {
    var e = function() {
        var e = this,
        t = null,
        n = null,
        r = [],
        i = 0;
        this.init = function(n) {
            t = n,
            e._init()
        },
        this.play = function() {
            e._play()
        },
        this.pause = function() {
            e._pause()
        },
        this.destroy = function() {
            e._destroy()
        },
        this._init = function() {
            e._generateData(),
            e._doLoop(),
            n.pause()
        },
        this._play = function() {
            n.resume()
        },
        this._pause = function() {
            n.pause()
        },
        this._destroy = function() {
            n.kill(),
            t.find(".fish").remove()
        },
        this._doLoop = function() {
            e._generateFish();
            var r = 2 + Math.random() * 4;
            n = TweenMax.to(t.find(".fish"), r, {
                className: "+=finish",
                ease: Circ.EaseInOut,
                onComplete: function() {
                    t.find(".fish").remove(),
                    e._doLoop()
                }
            })
        },
        this._generateFish = function() {
            var e = r[Math.floor(Math.random() * i)],
            n = e.src,
            s = e.minW,
            o = e.maxW,
            u = Math.floor(Math.random() * (o - s + 1)) + s,
            a = Math.floor(Math.random() * 55),
            f = Math.random() <= .5 ? "from-left": "from-right",
            l = '<div class="fish start ' + f + '" style="width: ' + u + "vw; top: " + a + 'vw;"><img src="' + n + '"/></div>';
            t.append(l)
        },
        this._generateData = function() {
            r = [{
                src: App.BASEURL + "/assets/imgs/lake/fish/01.jpg",
                minW: 30,
                maxW: 70
            },
            {
                src: App.BASEURL + "/assets/imgs/lake/fish/02.jpg",
                minW: 30,
                maxW: 70
            },
            {
                src: App.BASEURL + "/assets/imgs/lake/fish/03.jpg",
                minW: 30,
                maxW: 70
            },
            {
                src: App.BASEURL + "/assets/imgs/lake/fish/04.jpg",
                minW: 30,
                maxW: 70
            }],
            i = r.length
        }
    };
    return e
}),
define("app/utils/ScrollSlide", [],
function() {
    var e = function() {
        var e = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame ||
        function(e) {
            return setTimeout(e, 1e3 / 60)
        },
        t = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || window.clearInterval,
        n = this,
        r,
        i,
        s,
        o,
        u,
        a,
        f,
        l,
        c = 0,
        h = !1,
        p = !1;
        this.init = function(e, t) {
            f = e,
            r = t || {},
            n._init()
        },
        this.start = function() {
            h = !0
        },
        this.stop = function() {
            h = !1
        },
        this.update = function() {
            n._update()
        },
        this.destroy = function() {
            h = !1,
            p = !0,
            t(l),
            n._destroyResize()
        },
        this._init = function() {
            s = (new Date).valueOf().toString() + Math.random().toString(),
            n._initSettings(),
            n._findStaticValues(),
            n._initRaf(),
            n._initOnResize()
        },
        this._initSettings = function() {
            i = {},
            i.latencyRate = r.latencyRate || 0,
            i.smoothRate = r.smoothRate || 8
        },
        this._update = function() {
            n._updateStaticValues()
        },
        this._findStaticValues = function() {
            i.latencyRate == 1 && (i.latencyRate = 0),
            n._findStaticPageValues(),
            n._findStaticElemValues()
        },
        this._findStaticPageValues = function() {
            u = $(window),
            a = u.height()
        },
        this._findStaticElemValues = function() {},
        this._updateStaticValues = function() {
            n._findStaticPageValues(),
            n._findStaticElemValues()
        },
        this._initRaf = function() {
            l = e(n._doRaf)
        },
        this._doRaf = function() {
            if (p) return;
            if (!h) {
                l = e(n._doRaf);
                return
            }
            c++;
            if (i.latencyRate && c % i.latencyRate) {
                l = e(n._doRaf);
                return
            }
            n._slideElem(),
            l = e(n._doRaf)
        },
        this._slideElem = function() {
            var e = f.length;
            for (var t = 0; t < e; t++) {
                var r = f[t],
                i = n._findFinalTrans(r),
                s = n._findSmoothTrans(r, i),
                o = "translateY(" + s + "px)";
                r.$elem.css({
                    "-webkit-transform": o,
                    "-moz-transform": o,
                    "-ms-transform": o,
                    "-o-transform": o,
                    transform: o
                })
            }
        },
        n._findFinalTrans = function(e) {
            var t = e,
            n = t.$elem,
            r = t.height,
            i = r * .5,
            s = t.offTopY,
            o = t.delta,
            f = u.scrollTop(),
            l = s + i,
            c = f - i,
            h = f + a + i,
            p = (l - c) / Math.abs(h - c) - .5;
            return t.finalTransY = o * p,
            t.finalTransY
        },
        n._findSmoothTrans = function(e, t) {
            var n = e,
            r = t;
            return n.actualTransY = n.actualTransY || 0,
            n.actualTransY = n.actualTransY + (r - n.actualTransY) / 8,
            n.actualTransY
        },
        this._initOnResize = function() {
            o = "resize." + s,
            u.on(o,
            function() {
                n._resize()
            })
        },
        this._resize = function() {
            n._update()
        },
        this._destroyResize = function() {
            u.off(o)
        }
    };
    return e
}),
define("app/novel/LakeView", ["app/canvas/Lake", "app/utils/ScrollSlide"],
function(e, t) {
    var n = function() {
        var n = this,
        r = [],
        i,
        s,
        o,
        u;
        this.init = function(e) {
            n._init()
        },
        this.show = function() {},
        this.destroy = function() {
            n._destroy()
        },
        this._init = function() {
            n._initLake(),
            n._initCroppedImg()
        },
        this._show = function() {},
        this._destroy = function() {
            n._destroyCroppedImg(),
            n._destroyLake()
        },
        this._initLake = function() {
            for (var t = 0; t < 12; t++) {
                var n = $(".laghetto-strip-" + t),
                i = new e;
                i.init(n),
                i.play(),
                r.push(i)
            }
        },
        this._playLake = function() {
            for (var e = 0; e < r.length; e++) r[e].play()
        },
        this._pauseLake = function() {
            for (var e = 0; e < r.length; e++) r[e].pause()
        },
        this._destroyLake = function() {
            for (var e = 0; e < r.length; e++) r[e].destroy()
        },
        this._initCroppedImg = function() {
            i = $(".product .cropped-img"),
            s = i.inViewport({
                onChangeInView: n._onChangeInviewCroppedImg
            }),
            s.start(),
            n._updateCroppedImgInview()
        },
        this._updateCroppedImgInview = function() {
            s.update()
        },
        this._onChangeInviewCroppedImg = function(e) {
            n._updateCroppedImgInViewArray(e);
            var t = e.inView,
            r = e.$elem;
            switch (t) {
            case ! 0 : var i = r.attr("data-scroll-slide");
                e.delta = i * .01 * window.innerWidth;
                break;
            case ! 1 :
            }
            n._initScrollParallaxCroppedImg()
        },
        this._initScrollParallaxCroppedImg = function() {
            if (u) return;
            u = new t,
            u.init(o),
            u.start()
        },
        this._updateCroppedImgInViewArray = function(e) {
            var t = e,
            n = t.inView;
            o = o || [];
            switch (n) {
            case ! 0 : o.push(t);
                break;
            case ! 1 : var r = o.length;
                for (var i = r - 1; i >= 0; i--) o[i].$elem === t.$elem && o.splice(i, 1)
            }
        },
        this._destroyCroppedImg = function() {
            u && u.stop(),
            u && u.destroy(),
            s && s.destroy()
        },
        this._initOnScroll = function() {
            $(window).scroll(function() {
                n._scroll()
            })
        },
        this._scroll = function() {},
        this._initOnResize = function() {
            $(window).resize(function() {
                n._resize()
            })
        },
        this._resize = function() {}
    };
    return n
});
var Color = function(e) {
    if (e.parse) return e;
    var t = {
        aliceblue: "#f0f8ff",
        antiquewhite: "#faebd7",
        aqua: "#00ffff",
        aquamarine: "#7fffd4",
        azure: "#f0ffff",
        beige: "#f5f5dc",
        bisque: "#ffe4c4",
        black: "#000000",
        blanchedalmond: "#ffebcd",
        blue: "#0000ff",
        blueviolet: "#8a2be2",
        brown: "#a52a2a",
        burlywood: "#deb887",
        cadetblue: "#5f9ea0",
        chartreuse: "#7fff00",
        chocolate: "#d2691e",
        coral: "#ff7f50",
        cornflowerblue: "#6495ed",
        cornsilk: "#fff8dc",
        crimson: "#dc143c",
        cyan: "#00ffff",
        darkblue: "#00008b",
        darkcyan: "#008b8b",
        darkgoldenrod: "#b8860b",
        darkgray: "#a9a9a9",
        darkgreen: "#006400",
        darkkhaki: "#bdb76b",
        darkmagenta: "#8b008b",
        darkolivegreen: "#556b2f",
        darkorange: "#ff8c00",
        darkorchid: "#9932cc",
        darkred: "#8b0000",
        darksalmon: "#e9967a",
        darkseagreen: "#8fbc8f",
        darkslateblue: "#483d8b",
        darkslategray: "#2f4f4f",
        darkturquoise: "#00ced1",
        darkviolet: "#9400d3",
        deeppink: "#ff1493",
        deepskyblue: "#00bfff",
        dimgray: "#696969",
        dodgerblue: "#1e90ff",
        firebrick: "#b22222",
        floralwhite: "#fffaf0",
        forestgreen: "#228b22",
        fuchsia: "#ff00ff",
        gainsboro: "#dcdcdc",
        ghostwhite: "#f8f8ff",
        gold: "#ffd700",
        goldenrod: "#daa520",
        gray: "#808080",
        green: "#008000",
        greenyellow: "#adff2f",
        honeydew: "#f0fff0",
        hotpink: "#ff69b4",
        indianred: "#cd5c5c",
        indigo: "#4b0082",
        ivory: "#fffff0",
        khaki: "#f0e68c",
        lavender: "#e6e6fa",
        lavenderblush: "#fff0f5",
        lawngreen: "#7cfc00",
        lemonchiffon: "#fffacd",
        lightblue: "#add8e6",
        lightcoral: "#f08080",
        lightcyan: "#e0ffff",
        lightgoldenrodyellow: "#fafad2",
        lightgray: "#d3d3d3",
        lightgreen: "#90ee90",
        lightpink: "#ffb6c1",
        lightsalmon: "#ffa07a",
        lightseagreen: "#20b2aa",
        lightskyblue: "#87cefa",
        lightslategray: "#778899",
        lightsteelblue: "#b0c4de",
        lightyellow: "#ffffe0",
        lime: "#00ff00",
        limegreen: "#32cd32",
        linen: "#faf0e6",
        magenta: "#ff00ff",
        maroon: "#800000",
        mediumaquamarine: "#66cdaa",
        mediumblue: "#0000cd",
        mediumorchid: "#ba55d3",
        mediumpurple: "#9370db",
        mediumseagreen: "#3cb371",
        mediumslateblue: "#7b68ee",
        mediumspringgreen: "#00fa9a",
        mediumturquoise: "#48d1cc",
        mediumvioletred: "#c71585",
        midnightblue: "#191970",
        mintcream: "#f5fffa",
        mistyrose: "#ffe4e1",
        moccasin: "#ffe4b5",
        navajowhite: "#ffdead",
        navy: "#000080",
        oldlace: "#fdf5e6",
        olive: "#808000",
        olivedrab: "#6b8e23",
        orange: "#ffa500",
        orangered: "#ff4500",
        orchid: "#da70d6",
        alegoldenrod: "#eee8aa",
        palegreen: "#98fb98",
        paleturquoise: "#afeeee",
        palevioletred: "#db7093",
        papayawhip: "#ffefd5",
        peachpuff: "#ffdab9",
        peru: "#cd853f",
        pink: "#ffc0cb",
        plum: "#dda0dd",
        powderblue: "#b0e0e6",
        purple: "#800080",
        red: "#ff0000",
        rosybrown: "#bc8f8f",
        royalblue: "#4169e1",
        saddlebrown: "#8b4513",
        salmon: "#fa8072",
        sandybrown: "#f4a460",
        seagreen: "#2e8b57",
        seashell: "#fff5ee",
        sienna: "#a0522d",
        silver: "#c0c0c0",
        skyblue: "#87ceeb",
        slateblue: "#6a5acd",
        slategray: "#708090",
        snow: "#fffafa",
        springgreen: "#00ff7f",
        steelblue: "#4682b4",
        tan: "#d2b48c",
        teal: "#008080",
        thistle: "#d8bfd8",
        tomato: "#ff6347",
        turquoise: "#40e0d0",
        violet: "#ee82ee",
        wheat: "#f5deb3",
        white: "#ffffff",
        whitesmoke: "#f5f5f5",
        yellow: "#ffff00",
        yellowgreen: "#9acd32"
    };
    return e.parse = function(e) {
        if (toString.call(e) === "[object Array]") return e;
        e = e.toLowerCase(),
        e = t[e] || e;
        var n = e.match(/^#([0-9a-f]{6})$/i);
        return n ? (n = n[1], [parseInt(n.substr(0, 2), 16), parseInt(n.substr(2, 2), 16), parseInt(n.substr(4, 2), 16), 1]) : (n = e.match(/^rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)$/i), n ? [parseInt(n[1], 10), parseInt(n[2], 10), parseInt(n[3], 10), 1] : (n = e.match(/^rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+\.?\d*)\s*\)$/i), n ? [parseInt(n[1], 10), parseInt(n[2], 10), parseInt(n[3], 10), Math.max(0, Math.min(1, parseFloat(n[4])))] : [0, 0, 0, 1]))
    },
    e.gradient = function(t, n, r, i) {
        var s = e.parse(t),
        o = e.parse(n),
        u = (o[0] - s[0]) / r,
        a = (o[1] - s[1]) / r,
        f = (o[2] - s[2]) / r,
        l = (o[3] - s[3]) / r,
        c = [];
        i = !!i && (s[3] !== 1 || o[3] !== 1);
        for (var h = 0; h < r - 1; ++h) i ? c[h] = "rgba(" + Math.round(s[0] + h * u) + "," + Math.round(s[1] + h * a) + "," + Math.round(s[2] + h * f) + "," + Math.round((s[3] + h * l) * 100) / 100 + ")": c[h] = "rgb(" + Math.round(s[0] + h * u) + "," + Math.round(s[1] + h * a) + "," + Math.round(s[2] + h * f) + ")";
        return i ? c[r - 1] = "rgba(" + o[0] + "," + o[1] + "," + o[2] + "," + o[3] + ")": c[r - 1] = "rgb(" + o[0] + "," + o[1] + "," + o[2] + ")",
        c
    },
    e.brightnessGradient = function(t, n, r) {
        var i = [],
        s;
        t = e.RGBtoHSV(t);
        for (var o = 0; o < r; ++o) s = e.HSVtoRGB([t[0], Math.max(0, Math.min(100, Math.round(t[1] + o * -n))), Math.max(0, Math.min(100, Math.round(t[2] + o * n))), t[3]]),
        i[o] = "rgba(" + s[0] + "," + s[1] + "," + s[2] + "," + s[3] + ")";
        return i
    },
    e.RGBtoHSV = function(t) {
        t = e.parse(t);
        var n = t[0] / 255,
        r = t[1] / 255,
        i = t[2] / 255,
        s = Math.min(n, r, i),
        o = Math.max(n, r, i),
        u = o - s,
        a = o,
        f,
        l;
        return o === 0 ? (f = 0, l = 0, [l, f, a, t[3]]) : (f = u / o, n == o ? l = (r - i) / u: r == o ? l = 2 + (i - n) / u: l = 4 + (n - r) / u, l *= 60, l < 0 && (l += 360), [Math.round(l), Math.round(f * 100), Math.round(a * 100), t[3]])
    },
    e.HSVtoRGB = function(e) {
        var t, n, r, i, s = e[0] / 60,
        o = e[1] / 100,
        u = e[2] / 100;
        if (o === 0) return [u * 255, u * 255, u * 255, e[3]];
        t = Math.floor(s),
        n = Math.round(u * (1 - o) * 255),
        r = Math.round(u * (1 - o * (s - t)) * 255),
        i = Math.round(u * (1 - o * (1 - (s - t))) * 255),
        u = Math.round(u * 255);
        switch (t) {
        case 0:
            return [u, i, n, e[3]];
        case 1:
            return [r, u, n, e[3]];
        case 2:
            return [n, u, i, e[3]];
        case 3:
            return [n, r, u, e[3]];
        case 4:
            return [i, n, u, e[3]];
        default:
            return [u, n, r, e[3]]
        }
    },
    e
} (Color || {});
define("color",
function() {});
var Fractal = function(e) {
    function t(e, n) {
        if (! (this instanceof t)) return new t(e, n);
        this.width = e.width,
        this.height = e.height,
        this.ctx = e.getContext("2d"),
        t.prototype.update.call(this, n)
    }
    return e.Fractal ? e: (t.prototype = {
        clear: function() {
            this.ctx.clearRect(0, 0, this.width, this.height)
        },
        update: function(e) {
            var t = e && e.x || 0,
            n = e && e.y || 0;
            this.pos = this.pos || {
                x: 0,
                y: 0
            },
            this.pos.x = t,
            this.pos.y = n
        },
        getCanvas: function() {
            return this.ctx.canvas
        }
    },
    e.Fractal = t, e)
} (Fractal || {});
define("fractal", ["color"],
function() {});
var Fractal = function(e) {
    function t(e, t, n) {
        var r = e.getBoundingClientRect();
        return n = n || {},
        n.x = t.clientX / window.innerWidth * 500 + 750,
        n.y = t.clientY / window.innerHeight * 1e3 + 1e3,
        n
    }
    function r(e, i, s, o, u, a) {
        if (! (this instanceof r)) return new r(e, i, s, o, u, a);
        i = i || {
            x: 0,
            y: 0
        },
        s = s || {
            x: 0,
            y: 0
        },
        o = o || 32,
        u = u || 5,
        this.fractal = e,
        this.startPos = i,
        this.target = s,
        this.interval = o,
        this.step = u,
        this.frameId = 0,
        this.timeoutId = 0,
        this.autoDisableAnim = !!a;
        var f = e.getCanvas(),
        l = {
            x: 0,
            y: 0
        },
        c = 0,
        h = function() {
            e.update(l),
            this.skip(2e3),
            c = 0
        }.bind(this);
        this.moveListener = function(e) {
            if (n && this.autoDisableAnim) {
                window.removeEventListener("mousemove", this);
                return
            }
            l = t(f, e, l),
            c && window.cancelAnimationFrame(c),
            c = window.requestAnimationFrame(h)
        }.bind(this),
        window.addEventListener("mousemove", this.moveListener, !1),
        e.update(i)
    }
    if (e.Animation) return e;
    var n = document.cookie.replace(/(?:(?:^|.*;\s*)slowAnimations\s*\=\s*([^;]*).*$)|^.*$/, "$1") === "true";
    return r.prototype = {
        start: function() {
            this.stop();
            var e = 0,
            t = this.step / this.interval,
            r = 0,
            i = 0,
            s = function(o) {
                var u = o - (e || o); ! n && this.autoDisableAnim && (r += (u - r) / ++i, r > 350 && (n = !0, document.cookie = "slowAnimations=true; path=/;")),
                this.frameId = window.requestAnimationFrame(s),
                this.approachTarget(u * t),
                e = o
            }.bind(this);
            this.frameId = window.requestAnimationFrame(s)
        },
        destroy: function() {
            this.stop(),
            this.fractal.getCanvas().removeEventListener("mousemove", this.moveListener),
            this.moveListener = null,
            this.fractal = null
        },
        stop: function() {
            this.frameId && (window.cancelAnimationFrame(this.frameId), this.frameId = 0),
            this.timeoutId && (clearTimeout(this.timeoutId), this.timeoutId = 0)
        },
        skip: function(e) {
            this.stop()
        },
        approachTarget: function(e) {
            var t = this.fractal.pos,
            r = this.target,
            i = t.x - r.x;
            e = e || this.step;
            if (t.x == r.x && t.y == r.y) {
                this.stop();
                return
            }
            i < e && -i < e ? t.x = r.x: i > 0 ? t.x -= e: t.x += e,
            i = t.y - r.y,
            i < e && -i < e ? t.y = r.y: i > 0 ? t.y -= e: t.y += e,
            n && this.autoDisableAnim && (t = r),
            this.fractal.update(t)
        }
    },
    e.Animation = r,
    e
} (Fractal || {});
define("animation", ["fractal"],
function() {});
var Fractal = function(e, t) {
    function n(r, i, s, o, u, a) {
        if (! (this instanceof n)) return new n(r, i, s, o, u, a);
        e.Fractal.call(this, r, i),
        this.maxorder = s || 10,
        o = o || "black",
        u = u || o,
        this.colors = t && t.gradient && t.gradient(o, u, s + 2, a) || [];
        if (this.colors.length !== s + 2) for (var f = 0,
        l = s + 2; f < l; ++f) this.colors[f] = "black";
        this.base_width = this.width / 8,
        this.update(i)
    }
    return e.Pythagoras ? e: (n.prototype = Object.create(e.Fractal.prototype), n.prototype.update = function(e) {
        var t = e && e.x || 0,
        n = e && e.y || 0,
        r = Math.max(.35, Math.min(.65, t / this.width)),
        i = Math.max(0, Math.min(this.maxorder, Math.floor(2 * this.maxorder * (1 - n / this.height)))),
        s = Math.PI / 2 * r,
        o = Math.PI / 2 - s,
        u = this.ctx;
        this.pos = this.pos || {
            x: 0,
            y: 0
        },
        this.pos.x = t,
        this.pos.y = n;
        if (this.order === i && this.langle === s) return;
        this.order = i,
        this.langle = s,
        this.rangle = o,
        this.lratio = Math.sin(o),
        this.rratio = Math.sin(s),
        this.clear(),
        u.save(),
        u.translate(this.width / 2 - this.base_width / 2, this.height - this.base_width),
        u.fillStyle = this.colors[0],
        u.fillRect(0, 0, this.base_width, this.base_width),
        this.draw(1, this.base_width),
        u.restore()
    },
    n.prototype.draw = function(e, t) {
        var n = this.ctx,
        r = this.lratio * t,
        i = this.rratio * t;
        if (e > this.order) return; ++e,
        n.save(),
        n.rotate( - this.langle),
        n.translate(0, -r),
        n.fillStyle = this.colors[e],
        n.fillRect(0, 0, r, r),
        this.draw(e, r),
        n.restore(),
        n.save(),
        n.translate(t, 0),
        n.rotate(this.rangle),
        n.translate( - i, -i),
        n.fillStyle = this.colors[e],
        n.fillRect(0, 0, i, i),
        this.draw(e, i),
        n.restore()
    },
    e.Pythagoras = n, e)
} (Fractal || {},
Color);
define("pythagoras", ["fractal"],
function() {});
var Fractal = function(e) {
    function t(n, r, i, s) {
        if (! (this instanceof t)) return new t(n, r, i, s);
        e.Fractal.call(this, n, r),
        this.ctx.strokeStyle = s || "black",
        this.maxorder = i || 10,
        this.base_height = this.height / 2,
        this.update(r)
    }
    return e.Koch ? e: (t.prototype = Object.create(e.Fractal.prototype), t.prototype.update = function(e) {
        var t = e && e.x || 0,
        n = e && e.y || 0,
        r = Math.max(.35, Math.min(.65, t / this.width)),
        i = Math.PI / 2 * r,
        s = Math.max(0, Math.min(this.maxorder, Math.floor(2 * this.maxorder * (1 - n / this.height)))),
        o = (Math.PI - i) / 2,
        u = this.ctx;
        this.pos = this.pos || {
            x: 0,
            y: 0
        },
        this.pos.x = t,
        this.pos.y = n;
        if (this.order === s && this.angle === o) return;
        this.order = s,
        this.angle = o,
        this.ratio = Math.sin(o) / (3 * Math.sin(i));
        var a = this.base_height / Math.tan(o) * 2,
        f = this.base_height / Math.sin(o);
        this.clear(),
        u.save(),
        u.translate(this.width / 2 - a / 2, this.height / 3),
        this.draw(1, a, 1),
        u.save(),
        u.rotate(o),
        this.draw(1, f, -1),
        u.restore(),
        u.translate(a, 0),
        u.rotate(Math.PI - o),
        this.draw(1, f, 1),
        u.restore()
    },
    t.prototype.draw = function(e, t, n) {
        var r = this.ctx,
        i = t / 3,
        s = t * this.ratio;
        if (e > this.order) {
            r.beginPath(),
            r.moveTo(0, 0),
            r.lineTo(t, 0),
            r.lineWidth = 1,
            r.stroke();
            return
        }++e,
        this.draw(e, i, n),
        r.save(),
        r.translate(i * 2, 0),
        this.draw(e, i, n),
        r.restore(),
        r.save(),
        r.translate(i, 0),
        r.rotate(n * -this.angle),
        this.draw(e, s, n),
        r.restore(),
        r.save(),
        r.translate(2 * i, 0),
        r.rotate(n * -(Math.PI - this.angle)),
        this.draw(e, s, -n),
        r.restore()
    },
    e.Koch = t, e)
} (Fractal || {});
define("koch", ["fractal"],
function() {}),
define("app/canvas/PythagorasTree", ["color", "fractal", "animation", "pythagoras", "koch"],
function() {
    var e = function() {
        var e = this;
        this.init = function() {
            e._init()
        },
        this._init = function() {
            var e = document.getElementById("pythagoras"),
            t = new Fractal.Pythagoras(e, {
                x: 0,
                y: 0
            },
            15, "#D4E576", "#126845"),
            n = new Fractal.Animation(t, {
                x: 0,
                y: 0
            },
            {
                x: 0,
                y: 0
            });
            n.skip(6e3)
        }
    };
    return e
}),
define("app/canvas/Flower", [],
function() {
    var e = function(e) {
        var t = this,
        n = Sketch.create({
            container: document.getElementById(e),
            fullscreen: !1,
            width: 500,
            height: 500
        }),
        r,
        i = [],
        s = ["69, 80,48", "165, 182, 133", "149, 169, 112", "178, 193, 151", "132, 154, 92", "127, 147, 88"];
        this.init = function(e) {
            t._init(e)
        },
        this.update = function(e) {
            t._update(e)
        },
        this._init = function(e) {
            r = {
                wave: function(e, t) {
                    e.fillStyle = t.colorPrimary;
                    var n = abs(t.x_0);
                    e.beginPath();
                    var r = TWO_PI / 140;
                    e.moveTo(n * cos(0), n * sin(0));
                    for (var i = 0; i < TWO_PI; i += r) {
                        var s = n + t.params[0] * sin(i * t.params[1]);
                        e.lineTo(s * cos(i), s * sin(i))
                    }
                    e.lineTo(n * cos(0), n * sin(0)),
                    e.fill()
                }
            },
            t._initFlower()
        },
        this._randomi = function(e, t) {
            return Math.floor(random(e, t))
        },
        this._generateFlower = function() {
            var e = [],
            n = 0;
            while (n <= 1) {
                n += random(.1, .2);
                if (n > 1) break;
                var r = "rgb(" + s[Math.floor(Math.random() * (s.length - 1))] + ")",
                i = [random(0, .07), t._randomi(5, 20), random(5, 10), random(.5, 2)];
                e.unshift({
                    radius: n,
                    colorPrimary: r,
                    type: random(["wave", "wave"]),
                    params: i,
                    x_0: random(0, .1),
                    x_1: 0
                })
            }
            return e
        },
        t._initFlower = function() {
            i.push(t._generateFlower());
            var e = 1,
            s = 1;
            n.draw = function() {
                var t = e < s ? e: s,
                o = Math.ceil(i.length / t),
                u = min(n.width / (t + 1), n.height / (o + 1)) / 2;
                for (k = 0; k < i.length; ++k) {
                    var a = i[k];
                    n.save();
                    var f = k % t + 1,
                    l = (k - k % t) / t + 1;
                    n.translate(f * n.width / (t + 1), l * n.height / (o + 1)),
                    n.scale(u * .9, u * .9);
                    for (var c = 0; c < a.length; ++c) r[a[c].type](n, a[c]);
                    n.restore()
                }
            },
            n.update = function() {
                for (k = 0; k < i.length; ++k) {
                    var e = i[k];
                    for (var t = 0; t < e.length; ++t) {
                        var n = .05,
                        r = e[t],
                        s = (r.x_0 - r.x_1) / n,
                        o = 0,
                        u = abs(r.x_0);
                        u !== 0 && (o += r.params[2] * (r.radius - u) * r.x_0 / u + r.params[3] * -s);
                        var a = 2 * r.x_0 - r.x_1 + o * n * n;
                        r.x_1 = r.x_0,
                        r.x_0 = a
                    }
                }
            }
        },
        t._update = function(e) {
            var n = e || 0;
            setTimeout(function() {
                i = [],
                t._initFlower()
            },
            n)
        },
        this._initOnScroll = function() {
            $(window).scroll(function() {
                t._scroll()
            })
        },
        this._scroll = function() {},
        this._initOnResize = function() {
            $(window).resize(function() {
                t._resize()
            })
        },
        this._resize = function() {}
    };
    return e
}),
define("app/novel/GardenView", ["app/canvas/PythagorasTree", "app/canvas/Flower"],
function(e, t) {
    var n = function() {
        var n = this,
        r = [],
        i,
        s;
        this.init = function(e) {
            n._init()
        },
        this.show = function() {},
        this.destroy = function() {
            n._destroy()
        },
        this._init = function() {
            n._initPythagorasTree(),
            n._initGiardino()
        };
        var o;
        this._initPythagorasTree = function() {
            if (App.BROWSER != "ie" && App.DEVICETYPE != "mobile") {
                var t = new e;
                t.init()
            } else $("#pythagoras-img").css({
                display: "block"
            });
            n._initInviewPythagoras()
        },
        this._initInviewPythagoras = function() {
            o = $(".pythagoras-check").inViewport({
                onChangeInView: n._onChangeInviewPythagoras
            }),
            o.start()
        },
        this._onChangeInviewPythagoras = function(e) {
            var t = e.inView;
            t ? $(".pythagoras-wrapper").addClass("inview") : $(".pythagoras-wrapper").removeClass("inview")
        },
        this._initGiardino = function() {
            i = $(".interlude-giardino");
            for (var e = 0; e < 8; e++) {
                var s, o = e + 1;
                s = new t("fiore-" + o + "-canvas"),
                s.init(),
                r.push(s)
            }
            n._onClickGiardino(),
            n._initInviewGiardino()
        },
        this._updateFlowers = function() {
            for (var e = 0; e < r.length; e++) {
                var t = e * 100;
                r[e].update(t)
            }
        },
        this._onClickGiardino = function() {
            i.on("click",
            function() {
                n._updateFlowers()
            })
        },
        this._offClickGiardino = function() {
            i.off("click")
        },
        this._initInviewGiardino = function() {
            s = i.inViewport({
                onChangeInView: n._onChangeInviewGiardino
            }),
            s.start()
        },
        this._onChangeInviewGiardino = function(e) {
            var t = e.inView;
            switch (t) {
            case ! 0 : n._updateFlowers();
                break;
            case ! 1 :
            }
        },
        this._show = function() {},
        this._destroy = function() {
            n._offClickGiardino(),
            o.destroy()
        },
        this._initOnScroll = function() {
            $(window).scroll(function() {
                n._scroll()
            })
        },
        this._scroll = function() {},
        this._initOnResize = function() {
            $(window).resize(function() {
                n._resize()
            })
        },
        this._resize = function() {}
    };
    return n
});
var Sketch = function() {
    function c(e) {
        return Object.prototype.toString.call(e) == "[object Array]"
    }
    function h(e) {
        return typeof e == "function"
    }
    function p(e) {
        return typeof e == "number"
    }
    function d(e) {
        return typeof e == "string"
    }
    function v(e) {
        return l[e] || String.fromCharCode(e)
    }
    function m(e, t, n) {
        for (var r in t) if (n || !e.hasOwnProperty(r)) e[r] = t[r];
        return e
    }
    function g(e, t) {
        return function() {
            e.apply(t, arguments)
        }
    }
    function y(e) {
        var t = {};
        for (var n in e) h(e[n]) ? t[n] = g(e[n], e) : t[n] = e[n];
        return t
    }
    function b(e) {
        function F(t) {
            h(t) && t.apply(e, [].splice.call(arguments, 1))
        }
        function I(e) {
            for (p = 0; p < B.length; p++) w = B[p],
            d(w) ? i[(e ? "add": "remove") + "EventListener"].call(i, w, n, !1) : h(w) ? n = w: i = w
        }
        function q() {
            O(t),
            t = A(q),
            M || (F(e.setup), M = h(e.setup), F(e.resize)),
            e.running && !k && (e.dt = (b = +(new Date)) - e.now, e.millis += e.dt, e.now = b, F(e.update), e.autoclear && P && e.clear(), F(e.draw)),
            k = ++k % e.interval
        }
        function R() {
            i = D ? e.style: e.canvas,
            g = D ? "px": "",
            e.fullscreen && (e.height = u.innerHeight, e.width = u.innerWidth),
            i.height = e.height + g,
            i.width = e.width + g,
            e.retina && P && _ && (i.height = e.height * _, i.width = e.width * _, i.style.height = e.height + "px", i.style.width = e.width + "px", e.scale(_, _)),
            M && F(e.resize)
        }
        function U(e, t) {
            return c = t.getBoundingClientRect(),
            e.x = e.pageX - c.left - u.scrollX,
            e.y = e.pageY - c.top - u.scrollY,
            e
        }
        function z(t, n) {
            return U(t, e.element),
            n = n || {},
            n.ox = n.x || t.x,
            n.oy = n.y || t.y,
            n.x = t.x,
            n.y = t.y,
            n.dx = n.x - n.ox,
            n.dy = n.y - n.oy,
            n
        }
        function W(e) {
            e.preventDefault(),
            E = y(e),
            E.originalEvent = e;
            if (E.touches) {
                L.length = E.touches.length;
                for (p = 0; p < E.touches.length; p++) L[p] = z(E.touches[p], L[p])
            } else L.length = 0,
            L[0] = z(E, H);
            return m(H, L[0], !0),
            E
        }
        function X(t) {
            t = W(t),
            N = (C = B.indexOf(S = t.type)) - 1,
            e.dragging = /down|start/.test(S) ? !0 : /up|end/.test(S) ? !1 : e.dragging;
            while (N) d(B[N]) ? F(e[B[N--]], t) : d(B[C]) ? F(e[B[C++]], t) : N = 0
        }
        function V(t) {
            x = t.keyCode,
            T = t.type == "keyup",
            j[x] = j[v(x)] = !T,
            F(e[t.type], t)
        }
        function $(t) {
            e.autopause && (t.type == "blur" ? K: J)(),
            F(e[t.type], t)
        }
        function J() {
            e.now = +(new Date),
            e.running = !0
        }
        function K() {
            e.running = !1
        }
        function Q() { (e.running ? K: J)()
        }
        function G() {
            P && e.clearRect(0, 0, e.width, e.height)
        }
        function Y() {
            f = e.element.parentNode,
            p = a.indexOf(e),
            f && f.removeChild(e.element),
            ~p && a.splice(p, 1),
            I(!1),
            K()
        }
        var t, n, i, f, c, p, g, b, w, E, S, x, T, N, C, k = 0,
        L = [],
        M = !1,
        _ = u.devicePixelRatio,
        D = e.type == s,
        P = e.type == r,
        H = {
            x: 0,
            y: 0,
            ox: 0,
            oy: 0,
            dx: 0,
            dy: 0
        },
        B = [e.element, X, "mousedown", "touchstart", X, "mousemove", "touchmove", X, "mouseup", "touchend", X, "click", o, V, "keydown", "keyup", u, $, "focus", "blur", R, "resize"],
        j = {};
        for (x in l) j[l[x]] = !1;
        return m(e, {
            touches: L,
            mouse: H,
            keys: j,
            dragging: !1,
            running: !1,
            millis: 0,
            now: NaN,
            dt: NaN,
            destroy: Y,
            toggle: Q,
            clear: G,
            start: J,
            stop: K
        }),
        a.push(e),
        e.autostart && J(),
        I(!0),
        R(),
        q(),
        e
    }
    var e = "E LN10 LN2 LOG2E LOG10E PI SQRT1_2 SQRT2 abs acos asin atan ceil cos exp floor log round sin sqrt tan atan2 pow max min".split(" "),
    t = "__hasSketch",
    n = Math,
    r = "canvas",
    i = "webgl",
    s = "dom",
    o = document,
    u = window,
    a = [],
    f = {
        fullscreen: !0,
        autostart: !0,
        autoclear: !0,
        autopause: !0,
        container: o.body,
        interval: 1,
        globals: !0,
        retina: !1,
        type: r
    },
    l = {
        8 : "BACKSPACE",
        9 : "TAB",
        13 : "ENTER",
        16 : "SHIFT",
        27 : "ESCAPE",
        32 : "SPACE",
        37 : "LEFT",
        38 : "UP",
        39 : "RIGHT",
        40 : "DOWN"
    },
    w,
    E,
    S = {
        CANVAS: r,
        WEB_GL: i,
        WEBGL: i,
        DOM: s,
        instances: a,
        install: function(r) {
            if (!r[t]) {
                for (var i = 0; i < e.length; i++) r[e[i]] = n[e[i]];
                m(r, {
                    TWO_PI: n.PI * 2,
                    HALF_PI: n.PI / 2,
                    QUATER_PI: n.PI / 4,
                    random: function(e, t) {
                        return c(e) ? e[~~ (n.random() * e.length)] : (p(t) || (t = e || 1, e = 0), e + n.random() * (t - e))
                    },
                    lerp: function(e, t, n) {
                        return e + n * (t - e)
                    },
                    map: function(e, t, n, r, i) {
                        return (e - t) / (n - t) * (i - r) + r
                    }
                }),
                r[t] = !0
            }
        },
        create: function(e) {
            return e = m(e || {},
            f),
            e.globals && S.install(self),
            w = e.element = e.element || o.createElement(e.type === s ? "div": "canvas"),
            E = e.context = e.context ||
            function() {
                switch (e.type) {
                case r:
                    return w.getContext("2d", e);
                case i:
                    return w.getContext("webgl", e) || w.getContext("experimental-webgl", e);
                case s:
                    return w.canvas = w
                }
            } (),
            e.container.appendChild(w),
            S.augment(E, e)
        },
        augment: function(e, t) {
            return t = m(t || {},
            f),
            t.element = e.canvas || e,
            t.element.className += " sketch",
            m(e, t, !0),
            b(e)
        }
    },
    x = ["ms", "moz", "webkit", "o"],
    T = self,
    N = 0,
    C = "AnimationFrame",
    k = "request" + C,
    L = "cancel" + C,
    A = T[k],
    O = T[L];
    for (var M = 0; M < x.length && !A; M++) A = T[x[M] + "Request" + C],
    O = T[x[M] + "Cancel" + k];
    return T[k] = A = A ||
    function(e) {
        var t = +(new Date),
        r = n.max(0, 16 - (t - N)),
        i = setTimeout(function() {
            e(t + r)
        },
        r);
        return N = t + r,
        i
    },
    T[L] = O = O ||
    function(e) {
        clearTimeout(e)
    },
    S
} ();
define("sketch", ["jquery"],
function(e) {
    return function() {
        var t, n;
        return t || e.Sketch
    }
} (this)),
define("app/canvas/Particles", ["sketch"],
function(e) {
    var t = function() {
        var t = 350,
        n = ["#989898", "#D8D8D8", "#E6E6E6", "#D7D7D7", "#DBDBDB", "#D0D0D0", "#C2C2C2"],
        r = this,
        i,
        s,
        o = [],
        u = [];
        this.init = function(e) {
            r._init()
        },
        this.reSpawn = function() {
            r._reSpawn()
        },
        this._init = function() {
            i = function(e, t, n) {
                this.init(e, t, n)
            },
            i.prototype = {
                init: function(e, t, n) {
                    this.alive = !0,
                    this.radius = n || 10,
                    this.wander = .15,
                    this.theta = random(TWO_PI),
                    this.drag = .92,
                    this.color = "#989898",
                    this.x = e || 0,
                    this.y = t || 0,
                    this.vx = 0,
                    this.vy = 0
                },
                move: function() {
                    this.x += this.vx,
                    this.y += this.vy,
                    this.vx *= this.drag,
                    this.vy *= this.drag,
                    this.theta += random( - 0.5, .5) * this.wander,
                    this.vx += sin(this.theta) * .1,
                    this.vy += cos(this.theta) * .1,
                    this.radius *= .96,
                    this.alive = this.radius > .5
                },
                draw: function(e) {
                    e.beginPath(),
                    e.arc(this.x, this.y, this.radius, 0, TWO_PI),
                    e.fillStyle = this.color,
                    e.fill()
                }
            },
            s = e.create({
                container: document.getElementById("particles")
            }),
            this._start()
        },
        this._reSpawn = function() {
            var e = [];
            for (var t = 0; t < 50; t++) {
                var n = Math.ceil(window.innerWidth * Math.random()),
                r = Math.ceil(window.innerHeight * Math.random());
                e.push({
                    x: n,
                    y: r
                })
            }
            var i, o, u, a, f, l, t, c;
            for (l = 0, c = e.length; l < c; l++) {
                a = e[l],
                f = random(1, 4);
                for (t = 0; t < f; t++) s.spawn(a.x, a.y)
            }
        },
        this._start = function() {
            s.setup = function() {
                var e, t, n;
                for (e = 0; e < 20; e++) t = s.width * .5 + random( - 100, 100),
                n = s.height * .5 + random( - 100, 100),
                s.spawn(t, n)
            },
            s.spawn = function(e, r) {
                o.length >= t && u.push(o.shift()),
                particle = u.length ? u.pop() : new i,
                particle.init(e, r, random(5, 40)),
                particle.wander = random(.5, 2),
                particle.color = random(n),
                particle.drag = random(.9, .99),
                theta = random(TWO_PI),
                force = random(2, 8),
                particle.vx = sin(theta) * force,
                particle.vy = cos(theta) * force,
                o.push(particle)
            },
            s.update = function() {
                var e, t;
                for (e = o.length - 1; e >= 0; e--) t = o[e],
                t.alive ? t.move() : u.push(o.splice(e, 1)[0])
            },
            s.draw = function() {
                s.globalCompositeOperation = "lighter";
                for (var e = o.length - 1; e >= 0; e--) o[e].draw(s)
            },
            s.mousemove = function() {
                var e, t, n, r, i, o, u, a;
                for (o = 0, a = s.touches.length; o < a; o++) {
                    r = s.touches[o],
                    i = random(1, 4);
                    for (u = 0; u < i; u++) if (r.x) s.spawn(r.x, r.y);
                    else {
                        var f = window.event.clientX,
                        l = window.event.clientY + document.documentElement.scrollTop - $("#particles").offset().top + 200;
                        s.spawn(f, l)
                    }
                }
            }
        }
    };
    return t
}),
define("app/novel/EyesView", ["app/canvas/Particles"],
function(e) {
    var t = function() {
        var t = this,
        n, r, i;
        this.init = function(e) {
            t._init()
        },
        this.show = function() {},
        this.destroy = function() {
            _particlesInview.destroy()
        },
        this._init = function() {
            t._initParticles(),
            t._initProductDiscover()
        },
        this._initParticles = function() {
            n = new e,
            n.init(),
            t._inviewParticles()
        },
        this._inviewParticles = function() {
            _particlesInview = $("#particles").inViewport({
                onChangeInView: t._onChangeInviewParticles
            }),
            _particlesInview.start()
        },
        this._onChangeInviewParticles = function(e) {
            var t = e.inView;
            t && n.reSpawn()
        },
        this._initProductDiscover = function() {
            r = $(".products-block-discover"),
            t._onClickDiscoverElems(),
            t._inviewProductDiscover()
        },
        this._inviewProductDiscover = function() {
            i = r.inViewport({
                onChangeInView: t._onChangeInviewDiscoverElems
            }),
            i.start()
        },
        this._onChangeInviewDiscoverElems = function(e) {
            var n = e.inView,
            r = e.$elem;
            switch (n) {
            case ! 0 : t._toggleProductDiscoverClass(r);
                break;
            case ! 1 :
            }
        },
        this._toggleProductDiscoverClass = function(e) {
            var t = e;
            t.hasClass("open") ? t.removeClass("open") : t.addClass("open")
        },
        this._onClickDiscoverElems = function() {
            r.on("click",
            function() {
                t._toggleProductDiscoverClass($(this))
            })
        },
        this._show = function() {},
        this._initOnScroll = function() {
            $(window).scroll(function() {
                t._scroll()
            })
        },
        this._scroll = function() {},
        this._initOnResize = function() {
            $(window).resize(function() {
                t._resize()
            })
        },
        this._resize = function() {}
    };
    return t
}),
define("app/canvas/Typing", [],
function() {
    var e = function() {
        var e = this,
        t, n, r, i = [];
        this.init = function() {
            require(["ext/canvas/two.clean.min"],
            function(n) {
                t = n,
                e._init()
            })
        },
        this.play = function() {
            e._play()
        },
        this.pause = function() {
            e._pause()
        },
        this._init = function() {
            var e = "canvas";
            t = (new Two({
                autostart: !0,
                type: Two.Types[e],
                width: window.innerWidth,
                height: window.innerHeight
            })).appendTo(document.getElementById("typing-canvas")),
            r = new Two.Vector(0, .66),
            n = {
                family: "DidotItalic, sans-serif",
                size: 50,
                leading: 50,
                weight: 900
            };
            var s = t.makeText("", t.width / 2, t.height / 2, n);
            s.fill = "white",
            t.bind("resize",
            function() {
                s.translation.set(t.width / 2, t.height / 2)
            }).bind("update",
            function() {
                for (var e = 0; e < i.length; e++) {
                    var n = i[e];
                    n.translation.addSelf(n.velocity),
                    n.rotation += n.velocity.r,
                    n.velocity.addSelf(r),
                    n.velocity.y > 0 && n.translation.y > t.height && (t.scene.remove(n), i.splice(e, 1))
                }
            })
        },
        this._add = function(e) {
            var r = e,
            s = Math.random() * t.width / 2 + t.width / 4,
            o = t.height * 1.15,
            u = t.makeText(r, s, o, n);
            u.size *= 2,
            u.fill = "#333",
            u.velocity = new Two.Vector,
            u.velocity.x = 10 * (Math.random() - .5),
            u.velocity.y = -(20 * Math.random() + 13),
            u.velocity.r = Math.random() * Math.PI / 8,
            i.push(u)
        },
        this._play = function() {
            $(window).on("keydown",
            function(t) {
                var n = String.fromCharCode(t.which);
                e._add(n)
            })
        },
        this._pause = function() {
            $(window).off("keydown")
        }
    };
    return e
}),
function() {
    var e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g, y, b, w, E, S, x, T, N, C, k, L, A = function(e, t) {
        return function() {
            return e.apply(t, arguments)
        }
    },
    O = [].indexOf ||
    function(e) {
        for (var t = 0,
        n = this.length; n > t; t++) if (t in this && this[t] === e) return t;
        return - 1
    },
    M = [].slice;
    y = "OriDomi",
    m = !0,
    N = function(e) {
        return "undefined" != typeof console && null !== console && console.warn(y + ": Missing support for `" + e + "`."),
        m = !1
    },
    k = function(e) {
        var t, n, r, i;
        for (n = 0, r = w.length; r > n; n++) if (i = w[n], (t = i + u(e)) in C.style) return t;
        return e in C.style ? e: !1
    },
    n = function(e, t) {
        var n, r, i;
        r = "." + e + "{";
        for (n in t) i = t[n],
        n in l && (n = l[n], n.match(/^(webkit|moz|ms)/i) && (n = "-" + n)),
        r += n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase() + ":" + i + ";";
        return T += r + "}"
    },
    d = function(e) {
        return l.gradientProp + "(" + e + ", rgba(0, 0, 0, .5) 0%, rgba(255, 255, 255, .35) 100%)"
    },
    u = function(e) {
        return e[0].toUpperCase() + e.slice(1)
    },
    f = function(e) {
        var t;
        return t = document.createElement("div"),
        t.className = p[e],
        t
    },
    a = function(e, t, n) {
        var r;
        return r = e.cloneNode(t),
        r.classList.add(p[n]),
        r
    },
    v = function(e) {
        return e.style[l.transform] = "translate3d(-99999px, 0, 0)"
    },
    x = function(e) {
        return e.style[l.transform] = "translate3d(0, 0, 0)"
    },
    E = function(e) {
        return function() {
            var t, n, r, i, s, o;
            if (this._touchStarted) return e.apply(this, arguments);
            switch (t = arguments[0], n = arguments[1], r = arguments[2], o = {},
            s = i = null, e.length) {
            case 1:
                o.callback = t;
                break;
            case 2:
                "function" == typeof t ? o.callback = t: (i = t, o.callback = n);
                break;
            case 3:
                s = t,
                2 === arguments.length ? "object" == typeof n ? o = n: "function" == typeof n ? o.callback = n: i = n: 3 === arguments.length && (i = n, "object" == typeof r ? o = r: "function" == typeof r && (o.callback = r))
            }
            return null == s && (s = this._lastOp.angle || 0),
            i || (i = this._lastOp.anchor),
            this._queue.push([e, this._normalizeAngle(s), this._getLonghandAnchor(i), o]),
            this._step(),
            this
        }
    },
    h = function(e) {
        return setTimeout(e, 0)
    },
    b = function() {},
    e = ("undefined" != typeof window && null !== window && null != (S = window.$) ? S.data: void 0) ? window.$: null,
    r = ["left", "right", "top", "bottom"],
    s = r.slice(0, 2),
    i = r.slice(2),
    C = document.createElement("div"),
    T = "",
    w = ["Webkit", "Moz", "ms"],
    o = y.toLowerCase(),
    p = {
        active: "active",
        clone: "clone",
        holder: "holder",
        stage: "stage",
        stageLeft: "stage-left",
        stageRight: "stage-right",
        stageTop: "stage-top",
        stageBottom: "stage-bottom",
        content: "content",
        mask: "mask",
        maskH: "mask-h",
        maskV: "mask-v",
        panel: "panel",
        panelH: "panel-h",
        panelV: "panel-v",
        shader: "shader",
        shaderLeft: "shader-left",
        shaderRight: "shader-right",
        shaderTop: "shader-top",
        shaderBottom: "shader-bottom"
    };
    for (g in p) L = p[g],
    p[g] = o + "-" + L;
    l = new
    function() {
        var e, t, n, r;
        for (r = ["transform", "transformOrigin", "transformStyle", "transitionProperty", "transitionDuration", "transitionDelay", "transitionTimingFunction", "perspective", "perspectiveOrigin", "backfaceVisibility", "boxSizing", "mask"], e = 0, n = r.length; n > e; e++) t = r[e],
        this[t] = t;
        return this
    },
    function() {
        var e, t, i, s, o, a;
        for (e in l) if (a = l[e], l[e] = k(a), !l[e]) return N(a);
        return t = "preserve-3d",
        C.style[l.transformStyle] = t,
        C.style[l.transformStyle] !== t ? N(t) : (l.gradientProp = function() {
            var e, t, n, r;
            for (t = 0, n = w.length; n > t; t++) if (r = w[t], e = "-" + r.toLowerCase() + "-linear-gradient", C.style.backgroundImage = e + "(left, #000, #fff)", -1 !== C.style.backgroundImage.indexOf("gradient")) return e;
            return "linear-gradient"
        } (), s = function() {
            var e, t, n, r, i;
            for (t = 0, n = w.length; n > t; t++) if (i = w[t], r = "grab", C.style.cursor = e = "-" + i.toLowerCase() + "-" + r, C.style.cursor === e) return [e, "-" + i.toLowerCase() + "-grabbing"];
            return C.style.cursor = r,
            C.style.cursor === r ? [r, "grabbing"] : ["move", "move"]
        } (), l.grab = s[0], l.grabbing = s[1], l.transformProp = (i = l.transform.match(/(\w+)Transform/i)) ? "-" + i[1].toLowerCase() + "-transform": "transform", l.transitionEnd = function() {
            switch (l.transitionProperty.toLowerCase()) {
            case "transitionproperty":
                return "transitionEnd";
            case "webkittransitionproperty":
                return "webkitTransitionEnd";
            case "moztransitionproperty":
                return "transitionend";
            case "mstransitionproperty":
                return "msTransitionEnd"
            }
        } (),
        function(e) {
            var i, s, o, a;
            n(p.active, {
                backgroundColor: e("transparent"),
                backgroundImage: e("none"),
                boxSizing: e("border-box"),
                border: e("none"),
                outline: e("none"),
                padding: e("0"),
                transformStyle: e(t),
                mask: e("none"),
                position: "relative"
            }),
            n(p.clone, {
                margin: e("0"),
                boxSizing: e("border-box"),
                overflow: e("hidden"),
                display: e("block")
            }),
            n(p.holder, {
                width: "100%",
                position: "absolute",
                top: "0",
                bottom: "0",
                transformStyle: t
            }),
            n(p.stage, {
                width: "100%",
                height: "100%",
                position: "absolute",
                transform: "translate3d(-9999px, 0, 0)",
                margin: "0",
                padding: "0",
                transformStyle: t
            }),
            a = {
                Left: "0% 50%",
                Right: "100% 50%",
                Top: "50% 0%",
                Bottom: "50% 100%"
            };
            for (g in a) L = a[g],
            n(p["stage" + g], {
                perspectiveOrigin: L
            });
            for (n(p.shader, {
                width: "100%",
                height: "100%",
                position: "absolute",
                opacity: "0",
                top: "0",
                left: "0",
                pointerEvents: "none",
                transitionProperty: "opacity"
            }), s = 0, o = r.length; o > s; s++) i = r[s],
            n(p["shader" + u(i)], {
                background: d(i)
            });
            return n(p.content, {
                margin: e("0"),
                position: e("relative"),
                "float": e("none"),
                boxSizing: e("border-box"),
                overflow: e("hidden")
            }),
            n(p.mask, {
                width: "100%",
                height: "100%",
                position: "absolute",
                overflow: "hidden",
                transform: "translate3d(0, 0, 0)",
                outline: "1px solid transparent"
            }),
            n(p.panel, {
                width: "100%",
                height: "100%",
                padding: "0",
                position: "absolute",
                transitionProperty: l.transformProp,
                transformOrigin: "left",
                transformStyle: t
            }),
            n(p.panelH, {
                transformOrigin: "top"
            }),
            n(p.stageRight + " ." + p.panel, {
                transformOrigin: "right"
            }),
            n(p.stageBottom + " ." + p.panel, {
                transformOrigin: "bottom"
            })
        } (function(e) {
            return e + " !important"
        }), o = document.createElement("style"), o.type = "text/css", o.styleSheet ? o.styleSheet.cssText = T: o.appendChild(document.createTextNode(T)), document.head.appendChild(o))
    } (),
    c = {
        vPanels: 3,
        hPanels: 3,
        perspective: 1e3,
        shading: "hard",
        speed: 700,
        maxAngle: 90,
        ripple: 0,
        oriDomiClass: y.toLowerCase(),
        shadingIntensity: 1,
        easingMethod: "",
        gapNudge: 1.5,
        touchEnabled: !0,
        touchSensitivity: .25,
        touchStartCallback: b,
        touchMoveCallback: b,
        touchEndCallback: b
    },
    t = function() {
        function t(e, n) {
            var o, h, d, b, w, E, S, T, N, C, k, M, D, P, H, B, j, F, I, q, R, U, z, W, X, V, $, J, K, Q, G, Y, Z, et, tt, nt, rt, it, st, ot, ut, at, ft, lt, ct, ht, pt;
            if (this.el = e, null == n && (n = {}), this._onMouseOut = A(this._onMouseOut, this), this._onTouchLeave = A(this._onTouchLeave, this), this._onTouchEnd = A(this._onTouchEnd, this), this._onTouchMove = A(this._onTouchMove, this), this._onTouchStart = A(this._onTouchStart, this), this._stageReset = A(this._stageReset, this), this._conclude = A(this._conclude, this), this._onTransitionEnd = A(this._onTransitionEnd, this), this._step = A(this._step, this), m) {
                if (! (this instanceof t)) return new t(this.el, n);
                if ("string" == typeof this.el && (this.el = document.querySelector(this.el)), !this.el || 1 !== this.el.nodeType) return void("undefined" != typeof console && null !== console && console.warn(y + ": First argument must be a DOM element"));
                this._config = new
                function() {
                    for (g in c) L = c[g],
                    g in n ? this[g] = n[g] : this[g] = L;
                    return this
                },
                this._config.ripple = Number(this._config.ripple),
                this._queue = [],
                this._panels = {},
                this._stages = {},
                this._lastOp = {
                    anchor: r[0]
                },
                this._shading = this._config.shading,
                this._shading === !0 && (this._shading = "hard"),
                this._shading && (this._shaders = {},
                at = {},
                ut = f("shader"), ut.style[l.transitionDuration] = this._config.speed + "ms", ut.style[l.transitionTimingFunction] = this._config.easingMethod),
                lt = f("stage"),
                lt.style[l.perspective] = this._config.perspective + "px";
                for (k = 0, D = r.length; D > k; k++) if (h = r[k], this._panels[h] = [], this._stages[h] = a(lt, !1, "stage" + u(h)), this._shading) {
                    if (this._shaders[h] = {},
                    O.call(s, h) >= 0) for (M = 0, P = s.length; P > M; M++) ft = s[M],
                    this._shaders[h][ft] = [];
                    else for (R = 0, H = i.length; H > R; R++) ft = i[R],
                    this._shaders[h][ft] = [];
                    at[h] = a(ut, !1, "shader" + u(h))
                }
                for (S = a(this.el, !0, "content"), z = f("mask"), z.appendChild(S), G = f("panel"), G.style[l.transitionDuration] = this._config.speed + "ms", G.style[l.transitionTimingFunction] = this._config.easingMethod, V = {
                    left: [],
                    top: []
                },
                rt = ["x", "y"], X = 0, B = rt.length; B > X; X++) {
                    if (b = rt[X], "x" === b ? (d = s, W = "width", w = "V") : (d = i, W = "height", w = "H"), J = this._config[K = w.toLowerCase() + "Panels"], "number" == typeof J) T = Math.abs(parseInt(J, 10)),
                    Y = 100 / T,
                    J = this._config[K] = function() {
                        var e, t, n;
                        for (n = [], e = 0, t = T; t >= 0 ? t > e: e > t; t >= 0 ? e++:e--) n.push(Y);
                        return n
                    } ();
                    else if (T = J.length, !(99 <= (it = J.reduce(function(e, t) {
                        return e + t
                    })) && 100.1 >= it)) throw new Error(y + ": Panel percentages do not sum to 100");
                    if (U = a(z, !0, "mask" + w), this._shading) for (tt = 0, j = d.length; j > tt; tt++) h = d[tt],
                    U.appendChild(at[h]);
                    for (et = a(G, !1, "panel" + w), et.appendChild(U), ot = nt = 0, F = d.length; F > nt; ot = ++nt) {
                        for (h = d[ot], Q = ct = 0, st = T; st >= 0 ? st > ct: ct > st; Q = st >= 0 ? ++ct: --ct) {
                            if ($ = et.cloneNode(!0), E = $.children[0].children[0], E.style.width = E.style.height = "100%", ot ? ($.style[l.origin] = h, C = J.length - Q - 1, Z = C + 1) : (C = Q, Z = C - 1, 0 === Q ? V[h].push(0) : V[h].push((V[h][Z] - 100) * (J[Z] / J[C]))), 0 === Q ? ($.style[h] = "0", $.style[W] = J[C] + "%") : ($.style[h] = "100%", $.style[W] = J[C] / J[Z] * 100 + "%"), this._shading) for (N = ht = 0, I = d.length; I > ht; N = ++ht) o = d[N],
                            this._shaders[h][o][Q] = $.children[0].children[N + 1];
                            E.style[W] = E.style["max" + u(W)] = T / J[C] * 1e4 / T + "%",
                            E.style[d[0]] = V[d[0]][C] + "%",
                            this._transformPanel($, 0, h),
                            this._panels[h][Q] = $,
                            0 !== Q && this._panels[h][Q - 1].appendChild($)
                        }
                        this._stages[h].appendChild(this._panels[h][0])
                    }
                }
                for (this._stageHolder = f("holder"), this._stageHolder.setAttribute("aria-hidden", "true"), pt = 0, q = r.length; q > pt; pt++) h = r[pt],
                this._stageHolder.appendChild(this._stages[h]);
                "absolute" === window.getComputedStyle(this.el).position && (this.el.style.position = "absolute"),
                this.el.classList.add(p.active),
                x(this._stages.left),
                this._cloneEl = a(this.el, !0, "clone"),
                this._cloneEl.classList.remove(p.active),
                v(this._cloneEl),
                this.el.innerHTML = "",
                this.el.appendChild(this._cloneEl),
                this.el.appendChild(this._stageHolder),
                this.el.parentNode.style[l.transformStyle] = "preserve-3d",
                this.accordion(0),
                this._config.ripple && this.setRipple(this._config.ripple),
                this._config.touchEnabled && this.enableTouch()
            }
        }
        return t.prototype._step = function() {
            var e, t, n, r, i, s;
            if (!this._inTrans && this._queue.length) return this._inTrans = !0,
            s = this._queue.shift(),
            n = s[0],
            t = s[1],
            e = s[2],
            i = s[3],
            this.isFrozen && this.unfreeze(),
            r = function(r) {
                return function() {
                    var s;
                    return r._setCallback({
                        angle: t,
                        anchor: e,
                        options: i,
                        fn: n
                    }),
                    s = [t, e, i],
                    n.length < 3 && s.shift(),
                    n.apply(r, s)
                }
            } (this),
            this.isFoldedUp ? 2 === n.length ? r() : this._unfold(r) : e !== this._lastOp.anchor ? this._stageReset(e, r) : r()
        },
        t.prototype._isIdenticalOperation = function(e) {
            var t, n, r, i, s;
            if (!this._lastOp.fn) return ! 0;
            if (this._lastOp.reset) return ! 1;
            for (i = ["angle", "anchor", "fn"], t = 0, r = i.length; r > t; t++) if (n = i[t], this._lastOp[n] !== e[n]) return ! 1;
            s = e.options;
            for (g in s) if (L = s[g], L !== this._lastOp.options[g] && "callback" !== g) return ! 1;
            return ! 0
        },
        t.prototype._setCallback = function(e) {
            return ! this._config.speed || this._isIdenticalOperation(e) ? this._conclude(e.options.callback) : this._panels[this._lastOp.anchor][0].addEventListener(l.transitionEnd, this._onTransitionEnd, !1),
            (this._lastOp = e).reset = !1
        },
        t.prototype._onTransitionEnd = function(e) {
            return e.currentTarget.removeEventListener(l.transitionEnd, this._onTransitionEnd, !1),
            this._conclude(this._lastOp.options.callback, e)
        },
        t.prototype._conclude = function(e, t) {
            return h(function(n) {
                return function() {
                    return n._inTrans = !1,
                    n._step(),
                    "function" == typeof e ? e(t, n) : void 0
                }
            } (this))
        },
        t.prototype._transformPanel = function(e, t, n, r) {
            var i, s, o, u;
            switch (s = o = u = 0, n) {
            case "left":
                o = t,
                i = "X(-";
                break;
            case "right":
                o = -t,
                i = "X(";
                break;
            case "top":
                s = -t,
                i = "Y(-";
                break;
            case "bottom":
                s = t,
                i = "Y("
            }
            return r && (s = o = u = t),
            e.style[l.transform] = "rotateX(" + s + "deg) rotateY(" + o + "deg) rotateZ(" + u + "deg) translate" + i + this._config.gapNudge + "px)"
        },
        t.prototype._normalizeAngle = function(e) {
            var t;
            return e = parseFloat(e, 10),
            t = this._config.maxAngle,
            isNaN(e) ? 0 : e > t ? t: -t > e ? -t: e
        },
        t.prototype._setTrans = function(e, t, n) {
            return null == n && (n = this._lastOp.anchor),
            this._iterate(n,
            function(r) {
                return function(i, s, o) {
                    return r._setPanelTrans.apply(r, [n].concat(M.call(arguments), [e], [t]))
                }
            } (this))
        },
        t.prototype._setPanelTrans = function(e, t, n, r, o, u) {
            var a, f, c, h, p, d;
            if (a = function() {
                switch (u) {
                case 0:
                    return 0;
                case 1:
                    return this._config.speed / r * n;
                case 2:
                    return this._config.speed / r * (r - n - 1)
                }
            }.call(this), t.style[l.transitionDuration] = o + "ms", t.style[l.transitionDelay] = a + "ms", this._shading) for (h = O.call(s, e) >= 0 ? s: i, f = 0, c = h.length; c > f; f++) d = h[f],
            p = this._shaders[e][d][n],
            p.style[l.transitionDuration] = o + "ms",
            p.style[l.transitionDelay] = a + "ms";
            return a
        },
        t.prototype._setShader = function(e, t, n) {
            var r, i, o, u;
            return i = Math.abs(n),
            u = i / 90 * this._config.shadingIntensity,
            "hard" === this._shading ? (u *= .15, n = this._lastOp.angle < 0 ? i: -i) : u *= .4,
            O.call(s, t) >= 0 ? (0 > n ? (r = u, o = 0) : (r = 0, o = u), this._shaders[t].left[e].style.opacity = r, this._shaders[t].right[e].style.opacity = o) : (0 > n ? (r = 0, o = u) : (r = u, o = 0), this._shaders[t].top[e].style.opacity = r, this._shaders[t].bottom[e].style.opacity = o)
        },
        t.prototype._showStage = function(e) {
            return e !== this._lastOp.anchor ? (v(this._stages[this._lastOp.anchor]), this._lastOp.anchor = e, this._lastOp.reset = !0, this._stages[e].style[l.transform] = "translate3d(" +
            function() {
                switch (e) {
                case "left":
                    return "0, 0, 0)";
                case "right":
                    return "-" + this._config.vPanels.length + "px, 0, 0)";
                case "top":
                    return "0, 0, 0)";
                case "bottom":
                    return "0, -" + this._config.hPanels.length + "px, 0)"
                }
            }.call(this)) : void 0
        },
        t.prototype._stageReset = function(e, t) {
            var n;
            return n = function(r) {
                return function(i) {
                    return i && i.currentTarget.removeEventListener(l.transitionEnd, n, !1),
                    r._showStage(e),
                    h(t)
                }
            } (this),
            0 === this._lastOp.angle ? n() : (this._panels[this._lastOp.anchor][0].addEventListener(l.transitionEnd, n, !1), this._iterate(this._lastOp.anchor,
            function(e) {
                return function(t, n) {
                    return e._transformPanel(t, 0, e._lastOp.anchor),
                    e._shading ? e._setShader(n, e._lastOp.anchor, 0) : void 0
                }
            } (this)))
        },
        t.prototype._getLonghandAnchor = function(e) {
            switch (e.toString()) {
            case "left":
            case "l":
            case "4":
                return "left";
            case "right":
            case "r":
            case "2":
                return "right";
            case "top":
            case "t":
            case "1":
                return "top";
            case "bottom":
            case "b":
            case "3":
                return "bottom";
            default:
                return "left"
            }
        },
        t.prototype._setCursor = function(e) {
            return null == e && (e = this._touchEnabled),
            e ? this.el.style.cursor = l.grab: this.el.style.cursor = "default"
        },
        t.prototype._setTouch = function(e) {
            var t, n, r, i, s, o, u, a, f;
            if (e) {
                if (this._touchEnabled) return this;
                a = "addEventListener"
            } else {
                if (!this._touchEnabled) return this;
                a = "removeEventListener"
            }
            this._touchEnabled = e,
            this._setCursor(),
            r = [["TouchStart", "MouseDown"], ["TouchEnd", "MouseUp"], ["TouchMove", "MouseMove"], ["TouchLeave", "MouseLeave"]],
            f = "onmouseleave" in window;
            for (i = 0, o = r.length; o > i; i++) for (n = r[i], s = 0, u = n.length; u > s; s++) {
                if (t = n[s], "TouchLeave" === t && !f) {
                    this.el[a]("mouseout", this._onMouseOut, !1);
                    break
                }
                this.el[a](t.toLowerCase(), this["_on" + n[0]], !1)
            }
            return this
        },
        t.prototype._onTouchStart = function(e) {
            var t, n;
            if (this._touchEnabled && !this.isFoldedUp) return e.preventDefault(),
            this.emptyQueue(),
            this._touchStarted = !0,
            this.el.style.cursor = l.grabbing,
            this._setTrans(0, 0),
            this._touchAxis = (n = this._lastOp.anchor, O.call(s, n) >= 0 ? "x": "y"),
            this["_" + this._touchAxis + "Last"] = this._lastOp.angle,
            t = "_" + this._touchAxis + "1",
            "mousedown" === e.type ? this[t] = e["page" + this._touchAxis.toUpperCase()] : this[t] = e.targetTouches[0]["page" + this._touchAxis.toUpperCase()],
            this._config.touchStartCallback(this[t], e)
        },
        t.prototype._onTouchMove = function(e) {
            var t, n, r;
            if (this._touchEnabled && this._touchStarted) return e.preventDefault(),
            t = "mousemove" === e.type ? e["page" + this._touchAxis.toUpperCase()] : e.targetTouches[0]["page" + this._touchAxis.toUpperCase()],
            r = (t - this["_" + this._touchAxis + "1"]) * this._config.touchSensitivity,
            this._lastOp.angle < 0 ? (n = "right" === this._lastOp.anchor || "bottom" === this._lastOp.anchor ? this["_" + this._touchAxis + "Last"] - r: this["_" + this._touchAxis + "Last"] + r, n > 0 && (n = 0)) : (n = "right" === this._lastOp.anchor || "bottom" === this._lastOp.anchor ? this["_" + this._touchAxis + "Last"] + r: this["_" + this._touchAxis + "Last"] - r, 0 > n && (n = 0)),
            this._lastOp.angle = n = this._normalizeAngle(n),
            this._lastOp.fn.call(this, n, this._lastOp.anchor, this._lastOp.options),
            this._config.touchMoveCallback(n, e)
        },
        t.prototype._onTouchEnd = function(e) {
            return this._touchEnabled ? (this._touchStarted = this._inTrans = !1, this.el.style.cursor = l.grab, this._setTrans(this._config.speed, this._config.ripple), this._config.touchEndCallback(this["_" + this._touchAxis + "Last"], e)) : void 0
        },
        t.prototype._onTouchLeave = function(e) {
            return this._touchEnabled && this._touchStarted ? this._onTouchEnd(e) : void 0
        },
        t.prototype._onMouseOut = function(e) {
            return this._touchEnabled && this._touchStarted && e.toElement && !this.el.contains(e.toElement) ? this._onTouchEnd(e) : void 0
        },
        t.prototype._unfold = function(e) {
            var t;
            return this._inTrans = !0,
            t = this._lastOp.anchor,
            this._iterate(t,
            function(n) {
                return function(r, i, s) {
                    var o;
                    return o = n._setPanelTrans.apply(n, [t].concat(M.call(arguments), [n._config.speed], [1])),
                    function(r, i, o) {
                        return h(function() {
                            return n._transformPanel(r, 0, t),
                            n._shading && n._setShader(i, t, 0),
                            setTimeout(function() {
                                return x(r.children[0]),
                                i === s - 1 && (n._inTrans = n.isFoldedUp = !1, "function" == typeof e && e(), n._lastOp.fn = n.accordion, n._lastOp.angle = 0),
                                h(function() {
                                    return r.style[l.transitionDuration] = n._config.speed
                                })
                            },
                            o + .25 * n._config.speed)
                        })
                    } (r, i, o)
                }
            } (this))
        },
        t.prototype._iterate = function(e, t) {
            var n, r, i, s, o, u, a;
            for (u = o = this._panels[e], a = [], n = r = 0, i = u.length; i > r; n = ++r) s = u[n],
            a.push(t.call(this, s, n, o.length));
            return a
        },
        t.prototype.enableTouch = function() {
            return this._setTouch(!0)
        },
        t.prototype.disableTouch = function() {
            return this._setTouch(!1)
        },
        t.prototype.setSpeed = function(e) {
            var t, n, i;
            for (n = 0, i = r.length; i > n; n++) t = r[n],
            this._setTrans(this._config.speed = e, this._config.ripple, t);
            return this
        },
        t.prototype.freeze = function(e) {
            return this.isFrozen ? "function" == typeof e && e() : this._stageReset(this._lastOp.anchor,
            function(t) {
                return function() {
                    return t.isFrozen = !0,
                    v(t._stageHolder),
                    x(t._cloneEl),
                    t._setCursor(!1),
                    "function" == typeof e ? e() : void 0
                }
            } (this)),
            this
        },
        t.prototype.unfreeze = function() {
            return this.isFrozen && (this.isFrozen = !1, v(this._cloneEl), x(this._stageHolder), this._setCursor(), this._lastOp.angle = 0),
            this
        },
        t.prototype.destroy = function(t) {
            return this.freeze(function(n) {
                return function() {
                    return n._setTouch(!1),
                    e && e.data(n.el, o, null),
                    n.el.innerHTML = n._cloneEl.innerHTML,
                    n.el.classList.remove(p.active),
                    "function" == typeof t ? t() : void 0
                }
            } (this)),
            null
        },
        t.prototype.emptyQueue = function() {
            return this._queue = [],
            h(function(e) {
                return function() {
                    return e._inTrans = !1
                }
            } (this)),
            this
        },
        t.prototype.setRipple = function(e) {
            return null == e && (e = 1),
            this._config.ripple = Number(e),
            this.setSpeed(this._config.speed),
            this
        },
        t.prototype.constrainAngle = function(e) {
            return this._config.maxAngle = parseFloat(e, 10) || c.maxAngle,
            this
        },
        t.prototype.wait = function(e) {
            var t;
            return t = function(t) {
                return function() {
                    return setTimeout(t._conclude, e)
                }
            } (this),
            this._inTrans ? this._queue.push([t, this._lastOp.angle, this._lastOp.anchor, this._lastOp.options]) : t(),
            this
        },
        t.prototype.modifyContent = function(e) {
            var t, n, i, s, o, u, a, f, l, c;
            for ("function" != typeof e && (l = e, c = function(e, t, n) {
                var r, i;
                if (t && (e.innerHTML = t), n) {
                    for (r in n) i = n[r],
                    e.style[r] = i;
                    return null
                }
            },
            e = function(e) {
                var t, n, r, i, s, o, u, a;
                for (o in l) if (a = l[o], t = u = null, "string" == typeof a ? t = a: (t = a.content, u = a.style), "" !== o) for (s = e.querySelectorAll(o), n = 0, r = s.length; r > n; n++) i = s[n],
                c(i, t, u);
                else c(e, t, u);
                return null
            }), i = 0, o = r.length; o > i; i++) for (t = r[i], f = this._panels[t], n = s = 0, u = f.length; u > s; n = ++s) a = f[n],
            e(a.children[0].children[0], n, t);
            return this
        },
        t.prototype.accordion = E(function(e, t, n) {
            return this._iterate(t,
            function(r) {
                return function(i, s) {
                    var o;
                    if (o = s % 2 === 0 || n.twist ? e: -e, n.sticky ? 0 === s ? o = 0 : (s > 1 || n.stairs) && (o *= 2) : 0 !== s && (o *= 2), n.stairs && (o *= -1), r._transformPanel(i, o, t, n.fracture), r._shading) {
                        if (n.twist || n.fracture || 0 === s && n.sticky) return r._setShader(s, t, 0);
                        if (180 !== Math.abs(o)) return r._setShader(s, t, o)
                    }
                }
            } (this))
        }),
        t.prototype.curl = E(function(e, t, n) {
            return e /= O.call(s, t) >= 0 ? this._config.vPanels.length: this._config.hPanels.length,
            this._iterate(t,
            function(n) {
                return function(r, i) {
                    return n._transformPanel(r, e, t),
                    n._shading ? n._setShader(i, t, 0) : void 0
                }
            } (this))
        }),
        t.prototype.ramp = E(function(e, t, n) {
            return this._transformPanel(this._panels[t][1], e, t),
            this._iterate(t,
            function(e) {
                return function(n, r) {
                    return 1 !== r && e._transformPanel(n, 0, t),
                    e._shading ? e._setShader(r, t, 0) : void 0
                }
            } (this))
        }),
        t.prototype.foldUp = E(function(e, t) {
            return this.isFoldedUp ? "function" == typeof t ? t() : void 0 : this._stageReset(e,
            function(n) {
                return function() {
                    return n._inTrans = n.isFoldedUp = !0,
                    n._iterate(e,
                    function(r, i, s) {
                        var o, u;
                        return u = n._config.speed,
                        0 === i && (u /= 2),
                        o = n._setPanelTrans.apply(n, [e].concat(M.call(arguments), [u], [2])),
                        function(r, i, s) {
                            return h(function() {
                                return n._transformPanel(r, 0 === i ? 90 : 170, e),
                                setTimeout(function() {
                                    return 0 === i ? (n._inTrans = !1, "function" == typeof t ? t() : void 0) : v(r.children[0])
                                },
                                s + .25 * n._config.speed)
                            })
                        } (r, i, o)
                    })
                }
            } (this))
        }),
        t.prototype.unfold = E(t.prototype._unfold),
        t.prototype.map = function(e) {
            return E(function(t) {
                return function(n, r, i) {
                    return t._iterate(r,
                    function(s, o, u) {
                        return t._transformPanel(s, e(n, o, u), r, i.fracture)
                    })
                }
            } (this)).bind(this)
        },
        t.prototype.reset = function(e) {
            return this.accordion(0, {
                callback: e
            })
        },
        t.prototype.reveal = function(e, t, n) {
            return null == n && (n = {}),
            n.sticky = !0,
            this.accordion(e, t, n)
        },
        t.prototype.stairs = function(e, t, n) {
            return null == n && (n = {}),
            n.stairs = n.sticky = !0,
            this.accordion(e, t, n)
        },
        t.prototype.fracture = function(e, t, n) {
            return null == n && (n = {}),
            n.fracture = !0,
            this.accordion(e, t, n)
        },
        t.prototype.twist = function(e, t, n) {
            return null == n && (n = {}),
            n.fracture = n.twist = !0,
            this.accordion(e / 10, t, n)
        },
        t.prototype.collapse = function(e, t) {
            return null == t && (t = {}),
            t.sticky = !1,
            this.accordion( - this._config.maxAngle, e, t)
        },
        t.prototype.collapseAlt = function(e, t) {
            return null == t && (t = {}),
            t.sticky = !1,
            this.accordion(this._config.maxAngle, e, t)
        },
        t.VERSION = "1.1.5",
        t.isSupported = m,
        t
    } (),
    ("undefined" != typeof module && null !== module ? module.exports: void 0) ? module.exports = t: ("undefined" != typeof define && null !== define ? define.amd: void 0) ? define("oriDomi", [],
    function() {
        return t
    }) : window.OriDomi = t,
    e && (e.prototype.oriDomi = function(n) {
        var r, i, s, u, a, f, l, c;
        if (!m) return this;
        if (n === !0) return e.data(this[0], o);
        if ("string" == typeof n) {
            if (c = n, "function" != typeof(l = t.prototype[c])) return "undefined" != typeof console && null !== console && console.warn(y + ": No such method `" + c + "`"),
            this;
            for (s = 0, a = this.length; a > s; s++) r = this[s],
            (i = e.data(r, o)) || (i = e.data(r, o, new t(r, n))),
            l.apply(i, Array.prototype.slice.call(arguments).slice(1))
        } else for (u = 0, f = this.length; f > u; u++) r = this[u],
        (i = e.data(r, o)) || e.data(r, o, new t(r, n));
        return this
    })
}.call(this),
define("app/novel/NovelView", ["app/novel/LakeView", "app/novel/GardenView", "app/novel/EyesView", "app/canvas/Typing", "oriDomi"],
function(e, t, n, r, i) {
    var s = function() {
        var s = this,
        o = $(window),
        u = null,
        a = null,
        f = null,
        l = null,
        c = null,
        h = null,
        p = null,
        d = null,
        v = !1,
        m = null,
        g = !0,
        y,
        b,
        w,
        E,
        S,
        x,
        T,
        N,
        C,
        k;
        this.init = function(e) {
            s._init(),
            s._initCustomNovel(e),
            s._initOnScroll()
        },
        this.show = function() {
            s._show()
        },
        this.destroy = function() {
            s._destroy()
        },
        this.afterClose = function(e) {
            u = e || null
        },
        this._init = function() {
            s._initHeader(),
            s._initImgsStrip(),
            s._initScrollDown(),
            s._initFooter(),
            s._initBasicInview(),
            s._initRailInview(),
            s._initInviewTextillate(),
            s._initInviewTriggerAudio()
        },
        this._show = function() {},
        this._close = function() {
            c.destroy(),
            s._dispatchAfterClose()
        },
        this._destroy = function() {
            var e = null,
            t = null,
            n = !1,
            r = null,
            i = !0;
            s._destroyClick(),
            s._destroyScroll(),
            s._destroyResize(),
            s._destroyFooter(),
            h && clearTimeout(h)
        },
        this._initCustomNovel = function(r) {
            var i = r;
            switch (i) {
            case "lake":
                c = new e;
                break;
            case "garden":
                c = new t;
                break;
            case "eyes":
                c = new n
            }
            c.init()
        },
        this._initImgsStrip = function() {
            m = $(".intro-image-strips")
        },
        this._checkImageStrip = function() {
            var e = o.scrollTop();
            g ? e >= 1 && (m.removeClass("open"), g = !1) : e < 1 && (m.addClass("open"), g = !0)
        };
        var L = !0;
        this._checkScrollDown = function() {
            var e = o.scrollTop();
            L && e > 0 && ($(".main-cerchio-arrow").removeClass("visible"), L = !1)
        },
        this._initHeader = function() {
            d = $(".novel-page .header"),
            d.find(".header-left").textillate({
                autoStart: !1,
                "in": {
                    effect: "fadeInRight"
                }
            }),
            s._initClickCloseHeader()
        },
        this._checkHeader = function() {
            var e = o.scrollTop(),
            t = window.innerHeight,
            n = t * .6;
            v ? e < n && (s._closeHeader(), v = !1) : e >= n && (s._openHeader(), v = !0)
        },
        this._openHeader = function() {
            TweenMax.killTweensOf(d.find(".image-strip-container")),
            TweenMax.killTweensOf(d.find(".header-line")),
            TweenMax.killTweensOf(d.find(".header-right")),
            d.css({
                opacity: 1
            }),
            TweenMax.staggerTo(d.find(".image-strip-container"), .08, {
                className: "-=closed",
                ease: Circ.EaseInOut
            },
            .05),
            TweenMax.staggerTo(d.find(".header-line"), .15, {
                delay: .15,
                className: "-=closed",
                ease: Circ.EaseInOut
            },
            .04,
            function() {
                d.find(".header-left").textillate("in"),
                d.find(".header-left").css({
                    opacity: 1
                }),
                TweenMax.to(d.find(".header-right"), .5, {
                    ease: Back.easeOut,
                    width: "2vw",
                    height: "2vw"
                })
            })
        },
        this._closeHeader = function() {
            TweenMax.killTweensOf(d.find(".image-strip-container")),
            TweenMax.killTweensOf(d.find(".header-line")),
            TweenMax.killTweensOf(d.find(".header-right")),
            TweenMax.to(d, .2, {
                opacity: 0,
                ease: Linear.EaseNone,
                onComplete: function() {
                    d.find(".image-strip-container").addClass("closed"),
                    d.find(".header-line").addClass("closed"),
                    d.find(".header-left").css({
                        opacity: 0
                    }),
                    d.find(".header-right").css({
                        width: 0,
                        height: 0
                    })
                }
            })
        },
        this._initClickCloseHeader = function() {
            d.find(".header-right .cerchio-closer").one("click",
            function() {
                s._scrollTopNovel()
            })
        },
        this._scrollTopNovel = function() {
            s._destroyInview();
            var e = o.scrollTop(),
            t = e / 6500;
            TweenMax.to($(window), t, {
                scrollTo: 0,
                ease: Circ.easeInOut,
                onComplete: function() {
                    $("body").trigger("completeScrollTopNovel"),
                    m.removeClass("open"),
                    s._close()
                }
            })
        },
        this._offClickCloseHeader = function() {
            d.find(".header-right .cerchio-closer").off("click")
        },
        this._initScrollDown = function() {
            s._onClickScrollDownArrow(),
            h = setTimeout(function() {
                s._scrollDownArrow()
            },
            5e3)
        },
        this._onClickScrollDownArrow = function() {
            $(".main-cerchio-arrow").on("click",
            function() {
                s._scrollDownArrow()
            })
        },
        this._scrollDownArrow = function() {
            var e = $(".novel-page").offset().top - 150;
            TweenMax.to($(window), 1, {
                scrollTo: e,
                ease: Circ.easeInOut
            })
        },
        this._offClickScrollDownArrow = function() {
            $(".main-cerchio-arrow").off("click")
        },
        this._initBasicInview = function() {
            y = $(".basic-inview"),
            b = y.inViewport({
                onChangeInView: s._onChangeInviewBasicInviewElems
            }),
            b.start()
        },
        this._onChangeInviewBasicInviewElems = function(e) {
            var t = e.inView,
            n = e.$elem;
            switch (t) {
            case ! 0 : n.addClass("inview");
                break;
            case ! 1 : n.removeClass("inview")
            }
        },
        this._initRailInview = function() {
            w = $(".product-rail"),
            E = w.inViewport({
                onChangeInView: s._onChangeInviewRailElems
            }),
            E.start()
        },
        this._onChangeInviewRailElems = function(e) {
            var t = e.inView,
            n = e.$elem;
            switch (t) {
            case ! 0 : n.removeClass("zero");
                break;
            case ! 1 :
            }
        },
        this._initInviewTextillate = function() {
            T = $(".textillate-inview"),
            N = T.inViewport({
                onChangeInView: s._onChangeInviewTextillateElems
            }),
            N.start()
        },
        this._onChangeInviewTextillateElems = function(e) {
            var t = e.inView,
            n = e.$elem;
            switch (t) {
            case ! 0 : s._staggerTextillateLines(n.find(".textillate-title"));
                break;
            case ! 1 : s._stopTextillateLines(n.find(".textillate-title"))
            }
        },
        this._staggerTextillateLines = function(e) {
            var t = e;
            t.each(function(e) {
                var t = $(this);
                t.textillate({
                    initialDelay: e * 250,
                    autoStart: !1,
                    "in": {
                        effect: "fadeInRight"
                    }
                }),
                t.textillate("start"),
                t.on("inAnimationBegin.tlt",
                function() {
                    t.css({
                        opacity: 1
                    })
                })
            })
        },
        this._stopTextillateLines = function(e) {
            var t = e;
            t.textillate("stop"),
            t.css({
                opacity: 0
            })
        },
        this._initInviewTriggerAudio = function() {
            C = $(".trigger-audio"),
            k = C.inViewport({
                onChangeInView: s._onChangeInviewTriggerAudioElems
            }),
            k.start()
        },
        this._onChangeInviewTriggerAudioElems = function(e) {
            var t = e.inView,
            n = e.$elem,
            r = n.attr("data-audio-elem"),
            i = n.attr("data-audio-mode"),
            s = $("." + r);
            switch (t) {
            case ! 0 : App.SOUNDON && App.JUKEBOX && App.JUKEBOX.playTrack(s, i);
                break;
            case ! 1 : App.SOUNDON && App.JUKEBOX && App.JUKEBOX.stopTrack(s, i)
            }
        },
        this._initFooter = function() {
            S = $("footer"),
            s._initForm(),
            s._initRedirectNovel(),
            x = S.inViewport({
                onChangeInView: s._onChangeInviewFooterElem
            }),
            x.start()
        },
        this._onChangeInviewFooterElem = function(e) {
            var t = e.inView,
            n = e.$elem;
            switch (t) {
            case ! 0 : n.trigger("is-inview"),
                $("body").trigger("enterPaperEvent");
                break;
            case ! 1 :
            }
        },
        this._destroyFooter = function() {
            x.destroy(),
            p = null,
            s._offFocusForm(),
            s._offClickSubmitForm(),
            s._offClickCatalogueModal()
        },
        this._initForm = function() {
            App.DEVICETYPE == "desktop" && s._initTyping(),
            App.SUBMITTEDFORM ? s._showCatalogueButton() : (s._onClickSubmitForm(), s._onFocusForm()),
            App.BROWSER != "ie" && (p = new i(".modal-oridami", {
                ripple: 1,
                speed: 700,
                vPanels: 8,
                touchEnabled: !1
            })),
            p && p.accordion(180, "left")
        },
        this._onClickSubmitForm = function() {
            $("#form-submit").on("click",
            function() {
                var e = $(this).parent(".form-download"),
                t = e.find(".name").val(),
                n = e.find(".country").val(),
                r = e.find(".email").val(),
                i = e.find(".feed").val(),
                o = "name=" + t + "&country=" + n + "&email=" + r + "&feed=" + i;
                return t == "" || r == "" || n == "" ? e.find(".req").each(function() {
                    $(this).val() == "" && $(this).addClass("error")
                }) : (TweenMax.to(e, .5, {
                    opacity: 0,
                    ease: Linear.EaseNone
                }), $(".form-download").css({
                    "pointer-events": "none"
                }), TweenMax.to($(".form-loader"), .4, {
                    opacity: 1,
                    ease: Linear.EaseNone,
                    onComplete: function() {
                        $.ajax({
                            type: "POST",
                            url: App.BASEURL + "/assets/php/script/send_mail.php",
                            data: o,
                            success: function() {
                                App.SUBMITTEDFORM = !0,
                                TweenMax.to($(".form-loader"), .4, {
                                    opacity: 0,
                                    ease: Linear.EaseNone,
                                    onComplete: function() {
                                        s._showCatalogueButton(),
                                        setTimeout(function() {
                                            s._openCatalogueModal()
                                        },
                                        1600)
                                    }
                                })
                            }
                        })
                    }
                })),
                !1
            })
        },
        this._onClickOpenCatalogue = function() {
            $(".open-catalogue-page").on("click",
            function() {
                s._openCatalogueModal()
            })
        },
        this._showCatalogueButton = function() {
            $(".form-download").css({
                "pointer-events": "none",
                opacity: 0
            }),
            TweenMax.to($(".open-catalogue-page"), .8, {
                delay: .5,
                opacity: 1,
                width: "14vw",
                height: "14vw",
                ease: Circ.easeInOut,
                onComplete: function() {
                    TweenMax.to($(".open-catalogue-page-text"), .3, {
                        opacity: 1,
                        onComplete: function() {
                            $(".form-thank").css({
                                "pointer-events": "auto"
                            }),
                            s._onClickOpenCatalogue()
                        }
                    })
                }
            })
        },
        this._openCatalogueModal = function() {
            TweenMax.to($(".catalogue-modal"), .4, {
                height: "100%",
                ease: Circ.EaseInOut,
                onComplete: function() {
                    p && p.accordion(0, "left"),
                    $(".catalogue-modal .cerchio-closer").on("click",
                    function() {
                        s._offClickCatalogueModal(),
                        s._closeCatalogueModal()
                    })
                }
            })
        },
        this._closeCatalogueModal = function() {
            p && p.accordion(180, "left"),
            TweenMax.to($(".catalogue-modal"), .4, {
                delay: 1.5,
                height: "0",
                ease: Circ.EaseInOut
            })
        },
        this._cleanSubmittedForm = function() {
            TweenMax.to($(".text-1, .text-2"), .4, {
                opacity: 0,
                ease: Linear.EaseNone,
                onComplete: function() {
                    $(".form-download").find('input[type="text"]').val(""),
                    $(".form-download").find("input").removeClass("error"),
                    TweenMax.to($(".form-download"), .5, {
                        opacity: 1,
                        ease: Linear.EaseNone
                    })
                }
            })
        },
        this._onFocusForm = function() {
            $(".form-download input.req").on("focusin",
            function() {
                s._playTyping()
            }),
            $(".form-download input.req").on("focusout",
            function() {
                s._pauseTyping()
            })
        },
        this._offFocusForm = function() {
            $(".form-download input.req").off("focusin"),
            $(".form-download input.req").off("focusout")
        },
        this._offClickCatalogueModal = function() {
            $(".catalogue-modal .cerchio-closer").off("click")
        },
        this._offClickSubmitForm = function() {
            $("#form-submit").off("click")
        },
        this._initTyping = function() {
            f = new r,
            f.init()
        },
        this._playTyping = function() {
            l && clearTimeout(l),
            $("#typing-canvas").css({
                display: "block"
            }),
            f.play()
        },
        this._pauseTyping = function() {
            l && clearTimeout(l),
            l = setTimeout(function() {
                $("#typing-canvas").css({
                    display: "none"
                })
            },
            1500),
            f.pause()
        },
        this._initRedirectNovel = function() {
            $("body").on("redirectNovel",
            function(e, t) {
                t && (a = t),
                s._scrollTopNovel()
            })
        },
        this._destroyInview = function() {
            b.destroy(),
            E.destroy(),
            N.destroy(),
            k.destroy()
        },
        this._destroyClick = function() {
            s._offClickCloseHeader(),
            s._offClickScrollDownArrow()
        },
        this._dispatchAfterClose = function() {
            u && u(a)
        },
        this._initOnScroll = function() {
            $(window).scroll(function() {
                s._scroll()
            })
        },
        this._scroll = function() {
            h && clearTimeout(h),
            s._checkImageStrip(),
            s._checkHeader(),
            s._checkScrollDown()
        },
        this._destroyScroll = function() {
            $(window).off("scroll")
        },
        this._initOnResize = function() {
            $(window).resize(function() {
                s._resize()
            })
        },
        this._resize = function() {},
        this._destroyResize = function() {
            $(window).off("resize")
        }
    };
    return s
}),
define("app/general/GeneralView", ["app/birds/Birds", "app/assetsProvider/General", "app/assetsProvider/Lake", "app/assetsProvider/Garden", "app/assetsProvider/Eyes", "app/novel/NovelView"],
function(e, t, n, r, i, s) {
    var o = function() {
        var e = this,
        o = null,
        u, a, f = !0,
        l = !1,
        c = !1,
        h = [],
        p = [],
        d = null,
        v = $(".birds-loop.loop"),
        m = null,
        g = null,
        y = [],
        b = [],
        w = null,
        E = null,
        S,
        x,
        T,
        N,
        C;
        this.init = function(t) {
            e._init()
        },
        this.open = function() {
            e._open()
        },
        this.openNovel = function(t) {
            e._openNovel(t)
        },
        this.closeNovel = function(t) {
            o = t,
            e._closeNovel()
        },
        this.onCompletePreload = function(e) {
            S = e
        },
        this.onCompleteOpen = function(e) {
            x = e
        },
        this.onCompleteOpenNovel = function(e) {
            T = e
        },
        this.onCompleteCloseNovel = function(e) {
            N = e
        },
        this._init = function() {
            e._initPreloader(),
            e._initNavDots(),
            e._initSounds(),
            e._startPreloader()
        },
        this._initAfterPreload = function() {
            e._dispatchCompletePreload()
        },
        this._open = function() {
            App.BIRDS.startMouseMove(),
            e._showNavDots(),
            e._showSoundSwitcher(),
            setTimeout(e._dispatchCompleteOpen, 100)
        },
        this._openNovel = function(t) {
            m = t,
            e._initPreloaderNovel(t)
        },
        this._closeNovel = function() {
            e._startCloseNovel(),
            e._destroyActualNovel()
        },
        this._startCloseNovel = function() {
            $("body").trigger("startCloseNovel"),
            TweenMax.to($("#main-circle-intro"), .5, {
                delay: .4,
                top: "50%",
                borderColor: "#BFBFBF",
                ease: Power3.EaseInOut,
                onStart: function() {
                    $(".main-cerchio-arrow").removeClass("visible")
                },
                onComplete: function() {
                    $(".novel-page").remove(),
                    $(".preloader-novel-wrapper .spinner-svg-novel circle").attr("stroke-dasharray", "0, 950"),
                    TweenMax.to($(".preloader-novel-wrapper .preloader-novel-close"), .5, {
                        delay: .1,
                        width: "0vw",
                        height: "0vw",
                        ease: Back.easeOut
                    }),
                    w.addClass("restore"),
                    w.find(".preloader-novel-background").css({
                        height: "0%"
                    }),
                    w.find(".preloader-novel-low-background").css({
                        height: "0%"
                    }),
                    w.find(".preloader-novel-text").css({
                        height: "0%"
                    }),
                    setTimeout(function() {
                        w.removeClass("restore"),
                        w.css({
                            display: "none"
                        }),
                        e._closePreviewNovel(m),
                        e._fadeInCanvasBirds(),
                        m = null,
                        e._dispatchCompleteCloseNovel()
                    },
                    1600)
                }
            })
        },
        this._initPreloaderNovel = function(t) {
            var n = t;
            w = $(".preloader-novel-wrapper[data-novel=" + n + "]"),
            w.css({
                display: "block"
            }),
            _$previewNovel = $(".preview-novel-content[data-novel=" + n + "]"),
            TweenMax.to(_$previewNovel.find(".preview-novel-scroll"), .5, {
                width: "0",
                height: "0",
                ease: Back.easeIn,
                onComplete: function() {
                    w.find(".preloader-novel-background").css({
                        height: "5%"
                    }),
                    w.find(".preloader-novel-low-background").css({
                        height: "5%"
                    }),
                    w.find(".preloader-novel-text").css({
                        height: "5%"
                    }),
                    $.ajax({
                        type: "POST",
                        data: {
                            lang: App.LANG
                        },
                        url: App.BASEURL + "/elements/novels/novel-" + n + ".php"
                    }).done(function(n) {
                        w.find(".preloader-novel-background").css({
                            height: "10%"
                        }),
                        w.find(".preloader-novel-low-background").css({
                            height: "10%"
                        }),
                        w.find(".preloader-novel-text").css({
                            height: "10%"
                        }),
                        E = n,
                        e._startPreloaderNovel(t)
                    })
                }
            })
        },
        this._startPreloaderNovel = function(t) {
            var s = t,
            o, u;
            switch (s) {
            case "lake":
                o = new n;
                break;
            case "garden":
                o = new r;
                break;
            case "eyes":
                o = new i
            }
            o.init(),
            y = o.provideImages(),
            b = o.provideSounds(),
            u = new PxLoader;
            for (var a = 0; a < y.length; a++) {
                var f = new PxLoaderImage(y[a]);
                u.add(f)
            }
            if (App.DEVICETYPE == "desktop") for (var a = 0; a < b.length; a++) {
                var l = new PxLoaderAudio(b[a], "audios");
                u.add(l)
            }
            u.addProgressListener(function(t) {
                e._onProgressPreloaderNovel(t)
            }),
            u.addCompletionListener(function() {
                e._onCompletePreloaderNovel(s)
            }),
            u.start()
        },
        this._onProgressPreloaderNovel = function(e) {
            var t = e,
            n, r;
            n = t.completedCount / t.totalCount,
            n = n * .9 + .1,
            r = n * 100,
            r += "%",
            w.find(".preloader-novel-background").css({
                height: r
            }),
            w.find(".preloader-novel-low-background").css({
                height: r
            }),
            w.find(".preloader-novel-text").css({
                height: r
            })
        },
        this._onCompletePreloaderNovel = function(t) {
            var n = t;
            e._fadeOutCanvasBirds(),
            e._changeStripImg(t),
            $('.preloader-novel-wrapper[data-novel="' + n + '"] .spinner-svg-novel circle').attr("stroke-dasharray", "950, 950"),
            TweenMax.to($("#main-circle-intro"), .5, {
                delay: 1.5,
                top: "28%",
                borderColor: "#FFF",
                ease: Circ.EaseInOut,
                onStart: function() {
                    $(".main-cerchio-arrow").addClass("visible")
                },
                onComplete: function() {
                    $(".intro-image-strips").css({
                        opacity: 1
                    }),
                    $(".intro-image-strips").addClass("open"),
                    TweenMax.to($('.preloader-novel-wrapper[data-novel="' + n + '"] .preloader-novel-close'), .5, {
                        delay: .1,
                        width: L,
                        height: L,
                        ease: Back.easeOut,
                        onComplete: function() {
                            TweenMax.to($(".main-cerchio-arrow").find(".arrow-line"), .2, {
                                delay: 1,
                                top: "60%",
                                onComplete: function() {
                                    TweenMax.to($(".main-cerchio-arrow").find(".arrow-line"), .2, {
                                        top: "52%"
                                    })
                                }
                            }),
                            $(".main-circle-title-wrapper").css({
                                opacity: "0"
                            }),
                            $(".main-circle-title").css({
                                opacity: "0"
                            }),
                            $(".sub-circle-title").css({
                                opacity: "0"
                            }),
                            $("body").append(E),
                            e._dispatchCompleteOpenNovel(),
                            e._initActualNovel(n)
                        }
                    })
                }
            })
        },
        this._changeStripImg = function(e) {
            var t = e;
            $(".intro-image-strips .image-strip").each(function(e) {
                var n = e + 1,
                r;
                switch (t) {
                case "lake":
                    r = "#AAB8BC",
                    opacity = 1;
                    break;
                case "garden":
                    r = "#84A387",
                    opacity = .9;
                    break;
                case "eyes":
                    r = "#BC8278",
                    opacity = .8
                }
                $(this).css({
                    "background-color": r
                }),
                $(this).find(".image-strip-bg").css({
                    "background-image": "url(" + App.BASEURL + "/assets/imgs/" + t + "/image-strip-" + n + ".jpg)",
                    opacity: opacity
                })
            })
        },
        this._initActualNovel = function(t) {
            g = new s,
            g.init(t),
            g.afterClose(e._backToHome),
            App.SOUNDON && e._stopBirdsTrack(),
            e._openActualNovel(),
            e._initClickCloseNovel(t)
        },
        this._openActualNovel = function() {
            g.show()
        },
        this._destroyActualNovel = function() {
            g.destroy(),
            g = null
        },
        this._initClickCloseNovel = function(t) {
            var n = t;
            w = $(".preloader-novel-wrapper[data-novel=" + n + "]"),
            w.find(".preloader-novel-close").on("click",
            function() {
                $(".intro-image-strips").removeClass("open"),
                e._backToHome()
            })
        },
        this._backToHome = function(e) {
            var t = "";
            e && (t = "/" + e),
            App.ROUTING.navigate(App.LANG + "/home" + t, {
                trigger: !0
            })
        },
        this._initPreloader = function() {
            var e = new t;
            e.init(),
            _assetsGeneral = e.provideImages(),
            _assetsAudioGeneral = e.provideSounds(),
            d = $(".spinner-svg-main circle")
        },
        this._startPreloader = function() {
            loader = new PxLoader;
            for (var t = 0; t < _assetsGeneral.length; t++) {
                var n = new PxLoaderImage(_assetsGeneral[t]);
                loader.add(n)
            }
            for (var t = 0; t < _assetsAudioGeneral.length; t++) {
                var r = new PxLoaderAudio(_assetsAudioGeneral[t]);
                loader.add(r)
            }
            loader.addProgressListener(function(t) {
                e._onProgressPreloader(t)
            }),
            loader.addCompletionListener(function() {
                e._onCompletePreloader()
            }),
            loader.start()
        },
        this._onProgressPreloader = function(e) {
            var t = e,
            n = d.attr("data-diametro"),
            r = t.completedCount / t.totalCount,
            i = n * r;
            d.attr("stroke-dasharray", i + ", 950")
        },
        this._onCompletePreloader = function() {
            $("img[data-src-img]").each(function() {
                var e = $(this).attr("data-src-img");
                $(this).attr("src", e)
            }),
            $("audio[data-src-audioplayer]").each(function() {
                var e = $(this).attr("data-src-audioplayer");
                $(this).attr("src", e)
            }),
            $(".main-circle-wrapper").css({
                border: "3px solid #616161"
            }),
            $(".main-circle-spinner").css({
                display: "none"
            }),
            TweenMax.to($(".main-circle-wrapper"), .6, {
                width: "92%",
                height: "92%",
                ease: Circ.easeInOut,
                onComplete: function() {
                    e._initAfterPreload()
                }
            })
        },
        this._playCanvasBirds = function() {
            App.BIRDS.play()
        },
        this._pauseCanvasBirds = function() {
            App.BIRDS.pause(),
            App.BIRDS.stopMouseMove()
        },
        this._fadeInCanvasBirds = function() {
            e._playCanvasBirds(),
            TweenMax.to($("#birds-canvas-holder"), 1, {
                opacity: 1
            })
        },
        this._fadeOutCanvasBirds = function() {
            TweenMax.to($("#birds-canvas-holder"), 1, {
                opacity: 0,
                onComplete: function() {
                    e._pauseCanvasBirds()
                }
            })
        };
        var k, L;
        this._initNavDots = function() {
            a = $(".intro-nav-dot"),
            e._initClickNavDot(),
            App.DEVICETYPE == "desktop" ? (k = "5.25vh", L = "6.3vh") : App.DEVICETYPE == "mobile" && (window.innerWidth >= 768 ? (k = "5.25vh", L = "6.3vh") : (k = "12vh", L = "8vh"))
        },
        this._showNavDots = function() {
            TweenMax.staggerTo(a, .5, {
                ease: Back.easeOut,
                width: k,
                height: k,
                onComplete: function() {
                    TweenMax.to(a.find("span"), .3, {
                        opacity: 1
                    })
                }
            },
            .2)
        },
        this._initClickNavDot = function() {
            $(".intro-nav-dot").on("click",
            function() {
                o = null;
                if (f) {
                    f = !1;
                    var t = $(this).attr("data-novel");
                    e._openPreviewNovel(t)
                }
            })
        },
        this._clickCloserNavDot = function() {
            $(".intro-nav-dot-closer").one("click",
            function(t) {
                o = null,
                t.stopPropagation();
                if (l) {
                    l = !1;
                    var n = $(this).parent().attr("data-novel");
                    e._closePreviewNovel(n)
                }
            })
        },
        this._initSounds = function() {
            App.SOUNDON = !0,
            e._initSoundSwitcher()
        },
        this._initSoundSwitcher = function() {
            C = $(".sound-switcher")
        },
        this._showSoundSwitcher = function() {
            C.css({
                "pointer-events": "auto"
            }),
            TweenMax.to(C, .4, {
                opacity: 1,
                ease: Linear.EaseNone,
                onComplete: function() {
                    e._onClickSoundSwitcher()
                }
            })
        },
        this._hideSoundSwitcher = function() {
            C.css({
                "pointer-events": "none"
            }),
            TweenMax.to(C, .4, {
                opacity: 0,
                ease: Linear.EaseNone,
                onComplete: function() {
                    e._offClickSoundSwitcher()
                }
            })
        },
        this._onClickSoundSwitcher = function() {
            C.on("click",
            function() {
                App.SOUNDON = App.SOUNDON ? !1 : !0,
                App.SOUNDON ? (e._playBirdsTrack(), C.removeClass("sound-off")) : (e._stopBirdsTrack(), C.addClass("sound-off"))
            })
        },
        this._offClickSoundSwitcher = function() {
            C.off("click")
        },
        e._playBirdsTrack = function() {
            App.SOUNDON && App.JUKEBOX && App.JUKEBOX.playTrack(v, "loop")
        },
        e._stopBirdsTrack = function() {
            App.JUKEBOX && App.JUKEBOX.stopTrack(v, "loop")
        },
        this._openPreviewNovel = function(t) {
            var n = $(".preview-novel-content[data-novel=" + t + "]"),
            r = $(".intro-nav-dot[data-novel=" + t + "]"),
            i = $(".intro-nav-dot:not([data-novel=" + t + "])");
            setTimeout(function() {
                l = !0,
                e._clickCloserNavDot()
            },
            500),
            TweenMax.to(i.find("span"), .3, {
                opacity: 0,
                onComplete: function() {
                    TweenMax.to(i, .6, {
                        width: 0,
                        height: 0,
                        ease: Back.easeIn
                    })
                }
            }),
            TweenMax.to(r.find("span"), .4, {
                opacity: 0,
                ease: Linear.easeNone,
                onComplete: function() {
                    TweenMax.to(r.find(".cerchio-closer"), .4, {
                        width: "101%",
                        height: "101%",
                        ease: Circ.easeInOut,
                        onComplete: function() {
                            TweenMax.to(r.find(".cross-line"), .4, {
                                width: "50%",
                                ease: Circ.easeInOut
                            })
                        }
                    })
                }
            }),
            TweenMax.to($(".main-circle-title-wrapper"), .4, {
                opacity: 0,
                ease: Linear.easeNone,
                onComplete: function() {
                    n.css({
                        display: "block",
                        opacity: 1
                    }),
                    TweenMax.staggerTo(n.find(".timbro"), .7, {
                        left: "50%",
                        ease: Circ.easeInOut,
                        onComplete: function() {
                            TweenMax.staggerTo(n.find(".timbro"), .7, {
                                delay: .3,
                                left: "-50%",
                                ease: Circ.easeInOut,
                                onComplete: function() {
                                    TweenMax.to(n.find(".preview-novel-text"), .6, {
                                        opacity: 1
                                    }),
                                    TweenMax.staggerTo(n.find(".preview-novel-imgs img"), 0, {
                                        className: "+=visible",
                                        onStart: function() {
                                            n.find(".preview-novel-imgs img.visible").removeClass("visible")
                                        }
                                    },
                                    .1,
                                    function() {
                                        TweenMax.to(n.find(".preview-novel-text"), .5, {
                                            delay: .6,
                                            fontSize: "3.8vh",
                                            autoRound: !1
                                        }),
                                        n.find(".preview-novel-scroll").css({
                                            width: L,
                                            height: L
                                        }),
                                        TweenMax.to(n.find(".preview-novel-scroll"), .6, {
                                            marginTop: 0,
                                            delay: .7,
                                            opacity: 1
                                        }),
                                        TweenMax.to(n.find(".preview-novel-imgs"), .8, {
                                            delay: .2,
                                            width: "65%",
                                            height: "50%",
                                            ease: Circ.easeInOut,
                                            onComplete: function() {
                                                n.css({
                                                    "pointer-events": "auto"
                                                }),
                                                o ? e._startOpenNovel(o) : e._startOpenNovel(t)
                                            }
                                        })
                                    })
                                }
                            })
                        }
                    })
                }
            })
        },
        this._closePreviewNovel = function(t) {
            e._offClickOpenNovel(t),
            e._offWheelOpenNovel(t);
            var n = $(".preview-novel-content[data-novel=" + t + "]"),
            r = $(".intro-nav-dot[data-novel=" + t + "]"),
            i = $(".intro-nav-dot");
            TweenMax.to(n, .7, {
                opacity: 0,
                ease: Linear.easeNone,
                onComplete: function() {
                    TweenMax.killTweensOf($(".main-circle-title-wrapper")),
                    TweenMax.killTweensOf(n.find(".timbro")),
                    TweenMax.killTweensOf(n.find(".preview-novel-text")),
                    TweenMax.killTweensOf(n.find(".preview-novel-imgs img")),
                    TweenMax.killTweensOf(n.find(".preview-novel-text")),
                    TweenMax.killTweensOf(n.find(".preview-novel-scroll")),
                    TweenMax.killTweensOf(n.find(".preview-novel-imgs")),
                    n.css({
                        display: "none"
                    }),
                    n.find(".timbro").css({
                        left: "150%"
                    }),
                    n.find(".preview-novel-imgs").css({
                        opacity: 1,
                        width: "100%",
                        height: "75%"
                    }),
                    n.find(".preview-novel-imgs img.visible").removeClass("visible"),
                    n.find(".preview-novel-text").css({
                        opacity: 0,
                        "font-size": "3.15vh"
                    }),
                    n.find(".preview-novel-scroll").css({
                        opacity: 0,
                        "margin-top": "1.5vw"
                    }),
                    setTimeout(function() {
                        o || ($(".main-circle-title-wrapper").css({
                            opacity: 1
                        }), $(".main-circle-title").textillate("in"), $(".main-circle-title").css({
                            opacity: 1
                        }), $(".sub-circle-title").textillate("in"), $(".sub-circle-title").css({
                            opacity: 1
                        })),
                        TweenMax.to(i, .6, {
                            width: k,
                            height: k,
                            ease: Back.easeOut,
                            onComplete: function() {
                                o || TweenMax.to(i.find("span"), .3, {
                                    opacity: 1
                                })
                            }
                        }),
                        TweenMax.to(r.find(".cross-line"), .4, {
                            width: "0%",
                            ease: Circ.easeInOut,
                            onComplete: function() {
                                TweenMax.to(r.find(".cerchio-closer"), .4, {
                                    width: "0%",
                                    height: "0%",
                                    ease: Circ.easeInOut,
                                    onComplete: function() {
                                        o || TweenMax.to(r.find("span"), .4, {
                                            opacity: 1,
                                            ease: Linear.easeNone
                                        })
                                    }
                                })
                            }
                        }),
                        App.BIRDS.startMouseMove(),
                        e._showSoundSwitcher(),
                        e._playBirdsTrack(),
                        f = !0,
                        n.css({
                            "pointer-events": "none"
                        }),
                        o && e._openPreviewNovel(o)
                    },
                    200)
                }
            })
        },
        this._onClickOpenNovel = function(t) {
            $(".preview-novel-scroll[data-novel=" + t + "]").on("click",
            function() {
                e._startOpenNovel(t)
            })
        },
        this._offClickOpenNovel = function(e) {
            $(".preview-novel-scroll[data-novel=" + e + "]").off("click")
        },
        this._onWheelOpenNovel = function(t) {
            $(window).one("mousewheel",
            function() {
                e._startOpenNovel(t)
            })
        },
        this._offWheelOpenNovel = function(e) {
            $(window).off("mousewheel")
        },
        this._startOpenNovel = function(t) {
            App.SOUNDON && e._stopBirdsTrack(),
            f = !1,
            l = !1,
            e._hideSoundSwitcher(),
            TweenMax.to($(".intro-nav-dot"), .4, {
                width: 0,
                height: 0,
                ease: Back.easeIn,
                onComplete: function() {
                    o = null,
                    App.ROUTING.navigate(App.LANG + "/novel/" + t + "/", {
                        trigger: !0
                    })
                }
            })
        },
        this._dispatchCompletePreload = function() {
            S && S()
        },
        this._dispatchCompleteOpen = function() {
            x && x()
        },
        this._dispatchCompleteOpenNovel = function() {
            T && T()
        },
        this._dispatchCompleteCloseNovel = function() {
            N && N()
        },
        this._initOnScroll = function() {
            $(window).scroll(function() {
                e._scroll()
            })
        },
        this._scroll = function() {},
        this._initOnResize = function() {
            $(window).resize(function() {
                e._resize()
            })
        },
        this._resize = function() {}
    };
    return new o
}),
define("app/jukebox/Jukebox", [],
function() {
    var e = function() {
        var e = this;
        this.init = function() {
            e._init()
        },
        this.playTrack = function(e, t) {
            if (!e) return;
            if (!e[0]) return;
            var n = e;
            if (t == "loop") {
                var r = 0;
                n[0].play(),
                n[0].volume = r;
                var i = setInterval(function() {
                    r += .1;
                    if (r >= 1) {
                        clearInterval(i);
                        return
                    }
                    n[0].volume = r
                },
                150)
            } else n[0].play()
        },
        this.stopTrack = function(e, t) {
            if (!e) return;
            if (!e[0]) return;
            var n = e;
            if (t == "loop") {
                var r = 1;
                n[0].volume = r;
                var i = setInterval(function() {
                    r -= .1;
                    if (r <= 0) {
                        clearInterval(i);
                        return
                    }
                    n[0].volume = r
                },
                150);
                setTimeout(function() {
                    n[0].pause(),
                    n[0].currentTime = 0
                },
                1500)
            }
        },
        this._init = function() {}
    };
    return e
}),
define("app/detector/Detector", [],
function() {
    var e = function() {
        this.init = function() {
            _this._init()
        },
        this.detectBrowser = function() {
            var e = !!window.opr && !!opr.addons || !!window.opera || navigator.userAgent.indexOf(" OPR/") >= 0,
            t = typeof InstallTrigger != "undefined",
            n = Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") > 0,
            r = !!document.documentMode,
            i = !r && !!window.StyleMedia,
            s = !!window.chrome && !!window.chrome.webstore,
            o = (s || e) && !!window.CSS;
            if (e) return "opera";
            if (t) return "firefox";
            if (n) return "safari";
            if (r) return "ie";
            if (i) return "edge";
            if (s) return "chrome";
            if (o) return "blink"
        },
        this.detectDeviceType = function() {
            var e;
            return Modernizr.touchevents && window.innerWidth < 1500 ? e = "mobile": e = "desktop",
            e
        },
        this._init = function() {}
    };
    return e
}),
define("app/routers/Router", ["app/general/GeneralView"],
function(e) {
    var t = function() {
        var t = "initialized",
        n = "type-home",
        r = "type-novel",
        i = "page-home",
        s = "page-novel",
        o = this,
        u, a;
        this.init = function() {
            o._init()
        },
        this._init = function() {
            o._initRouting()
        };
        var f, l;
        this._initRouting = function() {
            var e = Backbone.Router.extend({
                routes: {
                    ":lang/": "openHome",
                    ":lang/home": "openHome",
                    ":lang/home/": "openHome",
                    ":lang/home/:novelRedirect": "openHome",
                    ":lang/novel/:novelName/": "openNovel"
                },
                openHome: function(e, t) {
                    t ? l = t: l = null,
                    App.PAGE_ID = "home",
                    o._openHome(),
                    o._updateAnalytics("home")
                },
                openNovel: function(e, t) {
                    App.PAGE_ID = "novel",
                    o._openNovel(t),
                    o._updateAnalytics("novel/" + t)
                }
            });
            App.ROUTING = new e;
            var t = "/";
            Backbone.history.start({
                pushState: !0,
                root: t
            })
        };
        var c, h;
        this._openHome = function() {
            if (h) return;
            o._disableChangeState(),
            c != i && (c == s ? (e.onCompleteCloseNovel(function() {
                o._enableChangeState()
            }), e.closeNovel(l)) : c || (e.onCompletePreload(e.open), e.onCompleteOpen(o._enableChangeState), e.init())),
            c = i
        },
        this._openNovel = function(t) {
            if (h) return;
            o._disableChangeState(),
            c == i ? (e.onCompleteOpenNovel(o._enableChangeState), e.openNovel(t)) : c != s && (c || (e.onCompletePreload(function() {
                e.openNovel(t)
            }), e.onCompleteOpenNovel(o._enableChangeState), e.init())),
            c = s
        },
        this._enableChangeState = function() {
            h = !1
        },
        this._disableChangeState = function() {
            h = !0
        },
        this._updateAnalytics = function(e) {
            var t = this;
            ga("send", "pageview", {
                page: e,
                title: e
            })
        }
    };
    return new t
}),
(window._gsQueue || (window._gsQueue = [])).push(function() {
    var e = document.documentElement,
    t = window,
    n = function(n, r) {
        var i = "x" === r ? "Width": "Height",
        s = "scroll" + i,
        o = "client" + i,
        u = document.body;
        return n === t || n === e || n === u ? Math.max(e[s], u[s]) - (t["inner" + i] || Math.max(e[o], u[o])) : n[s] - n["offset" + i]
    },
    r = window._gsDefine.plugin({
        propName: "scrollTo",
        API: 2,
        version: "1.7.3",
        init: function(e, r, i) {
            return this._wdw = e === t,
            this._target = e,
            this._tween = i,
            "object" != typeof r && (r = {
                y: r
            }),
            this._autoKill = r.autoKill !== !1,
            this.x = this.xPrev = this.getX(),
            this.y = this.yPrev = this.getY(),
            null != r.x ? (this._addTween(this, "x", this.x, "max" === r.x ? n(e, "x") : r.x, "scrollTo_x", !0), this._overwriteProps.push("scrollTo_x")) : this.skipX = !0,
            null != r.y ? (this._addTween(this, "y", this.y, "max" === r.y ? n(e, "y") : r.y, "scrollTo_y", !0), this._overwriteProps.push("scrollTo_y")) : this.skipY = !0,
            !0
        },
        set: function(e) {
            this._super.setRatio.call(this, e);
            var r = this._wdw || !this.skipX ? this.getX() : this.xPrev,
            i = this._wdw || !this.skipY ? this.getY() : this.yPrev,
            s = i - this.yPrev,
            o = r - this.xPrev;
            this._autoKill && (!this.skipX && (o > 7 || -7 > o) && n(this._target, "x") > r && (this.skipX = !0), !this.skipY && (s > 7 || -7 > s) && n(this._target, "y") > i && (this.skipY = !0), this.skipX && this.skipY && this._tween.kill()),
            this._wdw ? t.scrollTo(this.skipX ? r: this.x, this.skipY ? i: this.y) : (this.skipY || (this._target.scrollTop = this.y), this.skipX || (this._target.scrollLeft = this.x)),
            this.xPrev = this.x,
            this.yPrev = this.y
        }
    }),
    i = r.prototype;
    r.max = n,
    i.getX = function() {
        return this._wdw ? null != t.pageXOffset ? t.pageXOffset: null != e.scrollLeft ? e.scrollLeft: document.body.scrollLeft: this._target.scrollLeft
    },
    i.getY = function() {
        return this._wdw ? null != t.pageYOffset ? t.pageYOffset: null != e.scrollTop ? e.scrollTop: document.body.scrollTop: this._target.scrollTop
    },
    i._kill = function(e) {
        return e.scrollTo_x && (this.skipX = !0),
        e.scrollTo_y && (this.skipY = !0),
        this._super._kill.call(this, e)
    }
}),
window._gsDefine && window._gsQueue.pop()(),
define("scrollToPlugin", ["TweenMax"],
function() {}),
!
function(e, t, n) {
    function r(e, t) {
        return typeof e === t
    }
    function i() {
        var e, t, n, i, s, o, u;
        for (var a in l) if (l.hasOwnProperty(a)) {
            if (e = [], t = l[a], t.name && (e.push(t.name.toLowerCase()), t.options && t.options.aliases && t.options.aliases.length)) for (n = 0; n < t.options.aliases.length; n++) e.push(t.options.aliases[n].toLowerCase());
            for (i = r(t.fn, "function") ? t.fn() : t.fn, s = 0; s < e.length; s++) o = e[s],
            u = o.split("."),
            1 === u.length ? h[u[0]] = i: (!h[u[0]] || h[u[0]] instanceof Boolean || (h[u[0]] = new Boolean(h[u[0]])), h[u[0]][u[1]] = i),
            f.push((i ? "": "no-") + u.join("-"))
        }
    }
    function s(e) {
        var t = p.className,
        n = h._config.classPrefix || "";
        if (d && (t = t.baseVal), h._config.enableJSClass) {
            var r = new RegExp("(^|\\s)" + n + "no-js(\\s|$)");
            t = t.replace(r, "$1" + n + "js$2")
        }
        h._config.enableClasses && (t += " " + n + e.join(" " + n), d ? p.className.baseVal = t: p.className = t)
    }
    function o() {
        return "function" != typeof t.createElement ? t.createElement(arguments[0]) : d ? t.createElementNS.call(t, "http://www.w3.org/2000/svg", arguments[0]) : t.createElement.apply(t, arguments)
    }
    function u() {
        var e = t.body;
        return e || (e = o(d ? "svg": "body"), e.fake = !0),
        e
    }
    function a(e, n, r, i) {
        var s, a, f, l, c = "modernizr",
        h = o("div"),
        d = u();
        if (parseInt(r, 10)) for (; r--;) f = o("div"),
        f.id = i ? i[r] : c + (r + 1),
        h.appendChild(f);
        return s = o("style"),
        s.type = "text/css",
        s.id = "s" + c,
        (d.fake ? d: h).appendChild(s),
        d.appendChild(h),
        s.styleSheet ? s.styleSheet.cssText = e: s.appendChild(t.createTextNode(e)),
        h.id = c,
        d.fake && (d.style.background = "", d.style.overflow = "hidden", l = p.style.overflow, p.style.overflow = "hidden", p.appendChild(d)),
        a = n(h, e),
        d.fake ? (d.parentNode.removeChild(d), p.style.overflow = l, p.offsetHeight) : h.parentNode.removeChild(h),
        !!a
    }
    var f = [],
    l = [],
    c = {
        _version: "3.3.1",
        _config: {
            classPrefix: "",
            enableClasses: !0,
            enableJSClass: !0,
            usePrefixes: !0
        },
        _q: [],
        on: function(e, t) {
            var n = this;
            setTimeout(function() {
                t(n[e])
            },
            0)
        },
        addTest: function(e, t, n) {
            l.push({
                name: e,
                fn: t,
                options: n
            })
        },
        addAsyncTest: function(e) {
            l.push({
                name: null,
                fn: e
            })
        }
    },
    h = function() {};
    h.prototype = c,
    h = new h;
    var p = t.documentElement,
    d = "svg" === p.nodeName.toLowerCase(),
    v = c._config.usePrefixes ? " -webkit- -moz- -o- -ms- ".split(" ") : ["", ""];
    c._prefixes = v;
    var m = c.testStyles = a;
    h.addTest("touchevents",
    function() {
        var n;
        if ("ontouchstart" in e || e.DocumentTouch && t instanceof DocumentTouch) n = !0;
        else {
            var r = ["@media (", v.join("touch-enabled),("), "heartz", ")", "{#modernizr{top:9px;position:absolute}}"].join("");
            m(r,
            function(e) {
                n = 9 === e.offsetTop
            })
        }
        return n
    }),
    i(),
    s(f),
    delete c.addTest,
    delete c.addAsyncTest;
    for (var g = 0; g < h._q.length; g++) h._q[g]();
    e.Modernizr = h
} (window, document),
define("Modernizr",
function() {}),
function(e) {
    function t(e) {
        e = e || {},
        this.settings = e,
        e.statusInterval == null && (e.statusInterval = 5e3),
        e.loggingDelay == null && (e.loggingDelay = 2e4),
        e.noProgressTimeout == null && (e.noProgressTimeout = Infinity);
        var t = [],
        r = [],
        i,
        s = Date.now(),
        o = {
            QUEUED: 0,
            WAITING: 1,
            LOADED: 2,
            ERROR: 3,
            TIMEOUT: 4
        },
        u = function(e) {
            return e == null ? [] : Array.isArray(e) ? e: [e]
        };
        this.add = function(e) {
            e.tags = new n(e.tags),
            e.priority == null && (e.priority = Infinity),
            t.push({
                resource: e,
                status: o.QUEUED
            })
        },
        this.addProgressListener = function(e, t) {
            r.push({
                callback: e,
                tags: new n(t)
            })
        },
        this.addCompletionListener = function(e, t) {
            r.push({
                tags: new n(t),
                callback: function(t) {
                    t.completedCount === t.totalCount && e(t)
                }
            })
        };
        var a = function(e) {
            e = u(e);
            var t = function(t) {
                var n = t.resource,
                r = Infinity;
                for (var i = 0; i < n.tags.length; i++) for (var s = 0; s < Math.min(e.length, r); s++) {
                    if (n.tags.all[i] === e[s] && s < r) {
                        r = s;
                        if (r === 0) break
                    }
                    if (r === 0) break
                }
                return r
            };
            return function(e, n) {
                var r = t(e),
                i = t(n);
                return r < i ? -1 : r > i ? 1 : e.priority < n.priority ? -1 : e.priority > n.priority ? 1 : 0
            }
        };
        this.start = function(e) {
            i = Date.now();
            var n = a(e);
            t.sort(n);
            for (var r = 0,
            s = t.length; r < s; r++) {
                var u = t[r];
                u.status = o.WAITING,
                u.resource.start(this)
            }
            setTimeout(f, 100)
        };
        var f = function() {
            var n = !1,
            r = Date.now() - s,
            i = r >= e.noProgressTimeout,
            u = r >= e.loggingDelay;
            for (var a = 0,
            l = t.length; a < l; a++) {
                var c = t[a];
                if (c.status !== o.WAITING) continue;
                c.resource.checkStatus && c.resource.checkStatus(),
                c.status === o.WAITING && (i ? c.resource.onTimeout() : n = !0)
            }
            u && n && h(),
            n && setTimeout(f, e.statusInterval)
        };
        this.isBusy = function() {
            for (var e = 0,
            n = t.length; e < n; e++) if (t[e].status === o.QUEUED || t[e].status === o.WAITING) return ! 0;
            return ! 1
        };
        var l = function(e, n) {
            var i = null,
            u, a, f, l, h;
            for (u = 0, a = t.length; u < a; u++) if (t[u].resource === e) {
                i = t[u];
                break
            }
            if (i == null || i.status !== o.WAITING) return;
            i.status = n,
            s = Date.now(),
            f = e.tags.length;
            for (u = 0, a = r.length; u < a; u++) l = r[u],
            l.tags.length === 0 ? h = !0 : h = e.tags.intersects(l.tags),
            h && c(i, l)
        };
        this.onLoad = function(e) {
            l(e, o.LOADED)
        },
        this.onError = function(e) {
            l(e, o.ERROR)
        },
        this.onTimeout = function(e) {
            l(e, o.TIMEOUT)
        };
        var c = function(e, n) {
            var r = 0,
            i = 0,
            s, u, a, f;
            for (s = 0, u = t.length; s < u; s++) a = t[s],
            f = !1,
            n.tags.length === 0 ? f = !0 : f = a.resource.tags.intersects(n.tags),
            f && (i++, (a.status === o.LOADED || a.status === o.ERROR || a.status === o.TIMEOUT) && r++);
            n.callback({
                resource: e.resource,
                loaded: e.status === o.LOADED,
                error: e.status === o.ERROR,
                timeout: e.status === o.TIMEOUT,
                completedCount: r,
                totalCount: i
            })
        },
        h = this.log = function(e) {
            if (!window.console) return;
            var n = Math.round((Date.now() - i) / 1e3);
            window.console.log("PxLoader elapsed: " + n + " sec");
            for (var r = 0,
            s = t.length; r < s; r++) {
                var u = t[r];
                if (!e && u.status !== o.WAITING) continue;
                var a = "PxLoader: #" + r + " " + u.resource.getName();
                switch (u.status) {
                case o.QUEUED:
                    a += " (Not Started)";
                    break;
                case o.WAITING:
                    a += " (Waiting)";
                    break;
                case o.LOADED:
                    a += " (Loaded)";
                    break;
                case o.ERROR:
                    a += " (Error)";
                    break;
                case o.TIMEOUT:
                    a += " (Timeout)"
                }
                u.resource.tags.length > 0 && (a += " Tags: [" + u.resource.tags.all.join(",") + "]"),
                window.console.log(a)
            }
        }
    }
    function n(e) {
        this.all = [],
        this.first = null,
        this.length = 0,
        this.lookup = {};
        if (e) {
            if (Array.isArray(e)) this.all = e.slice(0);
            else if (typeof e == "object") for (var t in e) e.hasOwnProperty(t) && this.all.push(t);
            else this.all.push(e);
            this.length = this.all.length,
            this.length > 0 && (this.first = this.all[0]);
            for (var n = 0; n < this.length; n++) this.lookup[this.all[n]] = !0
        }
    }
    n.prototype.intersects = function(e) {
        if (this.length === 0 || e.length === 0) return ! 1;
        if (this.length === 1 && e.length === 1) return this.first === e.first;
        if (e.length < this.length) return e.intersects(this);
        for (var t in this.lookup) if (e.lookup[t]) return ! 0;
        return ! 1
    },
    typeof define == "function" && define.amd && define("PxLoader", [],
    function() {
        return t
    }),
    typeof module != "undefined" && module.exports ? module.exports = t: e.PxLoader = t
} (this),
Date.now || (Date.now = function() {
    return (new Date).getTime()
}),
Array.isArray || (Array.isArray = function(e) {
    return Object.prototype.toString.call(e) === "[object Array]"
}),
define("pxloader",
function() {}),
PxLoader.prototype.addImage = function(e, t, n, r) {
    var i = new PxLoaderImage(e, t, n, r);
    return this.add(i),
    i.img
},
typeof define == "function" && define.amd && define("PxLoaderImage", [],
function() {
    return PxLoaderImage
}),
define("pxloaderImage", ["pxloader"],
function() {}),
PxLoader.prototype.addAudio = function(e, t, n) {
    var r = new PxLoaderAudio(e, t, n);
    return this.add(r),
    r.audio
},
typeof define == "function" && define.amd && define("PxLoaderAudio", [],
function() {
    return PxLoaderAudio
}),
define("pxloaderAudio", ["pxloader"],
function() {}),
PxLoader.prototype.addVideo = function(e, t, n, r) {
    var i = new PxLoaderVideo(e, t, n, r);
    return this.add(i),
    i.vid
},
typeof define == "function" && define.amd && define("PxLoaderVideo", [],
function() {
    return PxLoaderVideo
}),
define("pxloaderVideo", ["pxloader"],
function() {});
var THREE = {
    REVISION: "75"
};
"function" == typeof define && define.amd ? define("three", THREE) : "undefined" != typeof exports && "undefined" != typeof module && (module.exports = THREE),
void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)),
void 0 === Math.sign && (Math.sign = function(e) {
    return 0 > e ? -1 : 0 < e ? 1 : +e
}),
void 0 === Function.prototype.name && void 0 !== Object.defineProperty && Object.defineProperty(Function.prototype, "name", {
    get: function() {
        return this.toString().match(/^\s*function\s*(\S*)\s*\(/)[1]
    }
}),
void 0 === Object.assign && Object.defineProperty(Object, "assign", {
    writable: !0,
    configurable: !0,
    value: function(e) {
        if (void 0 === e || null === e) throw new TypeError("Cannot convert first argument to object");
        for (var t = Object(e), n = 1, r = arguments.length; n !== r; ++n) {
            var i = arguments[n];
            if (void 0 !== i && null !== i) for (var i = Object(i), s = Object.keys(i), o = 0, u = s.length; o !== u; ++o) {
                var a = s[o],
                f = Object.getOwnPropertyDescriptor(i, a);
                void 0 !== f && f.enumerable && (t[a] = i[a])
            }
        }
        return t
    }
}),
THREE.MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2
},
THREE.CullFaceNone = 0,
THREE.CullFaceBack = 1,
THREE.CullFaceFront = 2,
THREE.CullFaceFrontBack = 3,
THREE.FrontFaceDirectionCW = 0,
THREE.FrontFaceDirectionCCW = 1,
THREE.BasicShadowMap = 0,
THREE.PCFShadowMap = 1,
THREE.PCFSoftShadowMap = 2,
THREE.FrontSide = 0,
THREE.BackSide = 1,
THREE.DoubleSide = 2,
THREE.FlatShading = 1,
THREE.SmoothShading = 2,
THREE.NoColors = 0,
THREE.FaceColors = 1,
THREE.VertexColors = 2,
THREE.NoBlending = 0,
THREE.NormalBlending = 1,
THREE.AdditiveBlending = 2,
THREE.SubtractiveBlending = 3,
THREE.MultiplyBlending = 4,
THREE.CustomBlending = 5,
THREE.AddEquation = 100,
THREE.SubtractEquation = 101,
THREE.ReverseSubtractEquation = 102,
THREE.MinEquation = 103,
THREE.MaxEquation = 104,
THREE.ZeroFactor = 200,
THREE.OneFactor = 201,
THREE.SrcColorFactor = 202,
THREE.OneMinusSrcColorFactor = 203,
THREE.SrcAlphaFactor = 204,
THREE.OneMinusSrcAlphaFactor = 205,
THREE.DstAlphaFactor = 206,
THREE.OneMinusDstAlphaFactor = 207,
THREE.DstColorFactor = 208,
THREE.OneMinusDstColorFactor = 209,
THREE.SrcAlphaSaturateFactor = 210,
THREE.NeverDepth = 0,
THREE.AlwaysDepth = 1,
THREE.LessDepth = 2,
THREE.LessEqualDepth = 3,
THREE.EqualDepth = 4,
THREE.GreaterEqualDepth = 5,
THREE.GreaterDepth = 6,
THREE.NotEqualDepth = 7,
THREE.MultiplyOperation = 0,
THREE.MixOperation = 1,
THREE.AddOperation = 2,
THREE.NoToneMapping = 0,
THREE.LinearToneMapping = 1,
THREE.ReinhardToneMapping = 2,
THREE.Uncharted2ToneMapping = 3,
THREE.CineonToneMapping = 4,
THREE.UVMapping = 300,
THREE.CubeReflectionMapping = 301,
THREE.CubeRefractionMapping = 302,
THREE.EquirectangularReflectionMapping = 303,
THREE.EquirectangularRefractionMapping = 304,
THREE.SphericalReflectionMapping = 305,
THREE.CubeUVReflectionMapping = 306,
THREE.CubeUVRefractionMapping = 307,
THREE.RepeatWrapping = 1e3,
THREE.ClampToEdgeWrapping = 1001,
THREE.MirroredRepeatWrapping = 1002,
THREE.NearestFilter = 1003,
THREE.NearestMipMapNearestFilter = 1004,
THREE.NearestMipMapLinearFilter = 1005,
THREE.LinearFilter = 1006,
THREE.LinearMipMapNearestFilter = 1007,
THREE.LinearMipMapLinearFilter = 1008,
THREE.UnsignedByteType = 1009,
THREE.ByteType = 1010,
THREE.ShortType = 1011,
THREE.UnsignedShortType = 1012,
THREE.IntType = 1013,
THREE.UnsignedIntType = 1014,
THREE.FloatType = 1015,
THREE.HalfFloatType = 1025,
THREE.UnsignedShort4444Type = 1016,
THREE.UnsignedShort5551Type = 1017,
THREE.UnsignedShort565Type = 1018,
THREE.AlphaFormat = 1019,
THREE.RGBFormat = 1020,
THREE.RGBAFormat = 1021,
THREE.LuminanceFormat = 1022,
THREE.LuminanceAlphaFormat = 1023,
THREE.RGBEFormat = THREE.RGBAFormat,
THREE.RGB_S3TC_DXT1_Format = 2001,
THREE.RGBA_S3TC_DXT1_Format = 2002,
THREE.RGBA_S3TC_DXT3_Format = 2003,
THREE.RGBA_S3TC_DXT5_Format = 2004,
THREE.RGB_PVRTC_4BPPV1_Format = 2100,
THREE.RGB_PVRTC_2BPPV1_Format = 2101,
THREE.RGBA_PVRTC_4BPPV1_Format = 2102,
THREE.RGBA_PVRTC_2BPPV1_Format = 2103,
THREE.RGB_ETC1_Format = 2151,
THREE.LoopOnce = 2200,
THREE.LoopRepeat = 2201,
THREE.LoopPingPong = 2202,
THREE.InterpolateDiscrete = 2300,
THREE.InterpolateLinear = 2301,
THREE.InterpolateSmooth = 2302,
THREE.ZeroCurvatureEnding = 2400,
THREE.ZeroSlopeEnding = 2401,
THREE.WrapAroundEnding = 2402,
THREE.TrianglesDrawMode = 0,
THREE.TriangleStripDrawMode = 1,
THREE.TriangleFanDrawMode = 2,
THREE.LinearEncoding = 3e3,
THREE.sRGBEncoding = 3001,
THREE.GammaEncoding = 3007,
THREE.RGBEEncoding = 3002,
THREE.LogLuvEncoding = 3003,
THREE.RGBM7Encoding = 3004,
THREE.RGBM16Encoding = 3005,
THREE.RGBDEncoding = 3006,
THREE.Color = function(e) {
    return 3 === arguments.length ? this.fromArray(arguments) : this.set(e)
},
THREE.Color.prototype = {
    constructor: THREE.Color,
    r: 1,
    g: 1,
    b: 1,
    set: function(e) {
        return e instanceof THREE.Color ? this.copy(e) : "number" == typeof e ? this.setHex(e) : "string" == typeof e && this.setStyle(e),
        this
    },
    setScalar: function(e) {
        this.b = this.g = this.r = e
    },
    setHex: function(e) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        this
    },
    setRGB: function(e, t, n) {
        return this.r = e,
        this.g = t,
        this.b = n,
        this
    },
    setHSL: function() {
        function e(e, t, n) {
            return 0 > n && (n += 1),
            1 < n && (n -= 1),
            n < 1 / 6 ? e + 6 * (t - e) * n: .5 > n ? t: n < 2 / 3 ? e + 6 * (t - e) * (2 / 3 - n) : e
        }
        return function(t, n, r) {
            return t = THREE.Math.euclideanModulo(t, 1),
            n = THREE.Math.clamp(n, 0, 1),
            r = THREE.Math.clamp(r, 0, 1),
            0 === n ? this.r = this.g = this.b = r: (n = .5 >= r ? r * (1 + n) : r + n - r * n, r = 2 * r - n, this.r = e(r, n, t + 1 / 3), this.g = e(r, n, t), this.b = e(r, n, t - 1 / 3)),
            this
        }
    } (),
    setStyle: function(e) {
        function t(t) {
            void 0 !== t && 1 > parseFloat(t) && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        var n;
        if (n = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(e)) {
            var r = n[2];
            switch (n[1]) {
            case "rgb":
            case "rgba":
                if (n = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(255, parseInt(n[1], 10)) / 255,
                this.g = Math.min(255, parseInt(n[2], 10)) / 255,
                this.b = Math.min(255, parseInt(n[3], 10)) / 255,
                t(n[5]),
                this;
                if (n = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) return this.r = Math.min(100, parseInt(n[1], 10)) / 100,
                this.g = Math.min(100, parseInt(n[2], 10)) / 100,
                this.b = Math.min(100, parseInt(n[3], 10)) / 100,
                t(n[5]),
                this;
                break;
            case "hsl":
            case "hsla":
                if (n = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(r)) {
                    var r = parseFloat(n[1]) / 360,
                    i = parseInt(n[2], 10) / 100,
                    s = parseInt(n[3], 10) / 100;
                    return t(n[5]),
                    this.setHSL(r, i, s)
                }
            }
        } else if (n = /^\#([A-Fa-f0-9]+)$/.exec(e)) {
            n = n[1],
            r = n.length;
            if (3 === r) return this.r = parseInt(n.charAt(0) + n.charAt(0), 16) / 255,
            this.g = parseInt(n.charAt(1) + n.charAt(1), 16) / 255,
            this.b = parseInt(n.charAt(2) + n.charAt(2), 16) / 255,
            this;
            if (6 === r) return this.r = parseInt(n.charAt(0) + n.charAt(1), 16) / 255,
            this.g = parseInt(n.charAt(2) + n.charAt(3), 16) / 255,
            this.b = parseInt(n.charAt(4) + n.charAt(5), 16) / 255,
            this
        }
        return e && 0 < e.length && (n = THREE.ColorKeywords[e], void 0 !== n ? this.setHex(n) : console.warn("THREE.Color: Unknown color " + e)),
        this
    },
    clone: function() {
        return new this.constructor(this.r, this.g, this.b)
    },
    copy: function(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    },
    copyGammaToLinear: function(e, t) {
        return void 0 === t && (t = 2),
        this.r = Math.pow(e.r, t),
        this.g = Math.pow(e.g, t),
        this.b = Math.pow(e.b, t),
        this
    },
    copyLinearToGamma: function(e, t) {
        void 0 === t && (t = 2);
        var n = 0 < t ? 1 / t: 1;
        return this.r = Math.pow(e.r, n),
        this.g = Math.pow(e.g, n),
        this.b = Math.pow(e.b, n),
        this
    },
    convertGammaToLinear: function() {
        var e = this.r,
        t = this.g,
        n = this.b;
        return this.r = e * e,
        this.g = t * t,
        this.b = n * n,
        this
    },
    convertLinearToGamma: function() {
        return this.r = Math.sqrt(this.r),
        this.g = Math.sqrt(this.g),
        this.b = Math.sqrt(this.b),
        this
    },
    getHex: function() {
        return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
    },
    getHexString: function() {
        return ("000000" + this.getHex().toString(16)).slice( - 6)
    },
    getHSL: function(e) {
        e = e || {
            h: 0,
            s: 0,
            l: 0
        };
        var t = this.r,
        n = this.g,
        r = this.b,
        i = Math.max(t, n, r),
        s = Math.min(t, n, r),
        o,
        u = (s + i) / 2;
        if (s === i) s = o = 0;
        else {
            var a = i - s,
            s = .5 >= u ? a / (i + s) : a / (2 - i - s);
            switch (i) {
            case t:
                o = (n - r) / a + (n < r ? 6 : 0);
                break;
            case n:
                o = (r - t) / a + 2;
                break;
            case r:
                o = (t - n) / a + 4
            }
            o /= 6
        }
        return e.h = o,
        e.s = s,
        e.l = u,
        e
    },
    getStyle: function() {
        return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
    },
    offsetHSL: function(e, t, n) {
        var r = this.getHSL();
        return r.h += e,
        r.s += t,
        r.l += n,
        this.setHSL(r.h, r.s, r.l),
        this
    },
    add: function(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    },
    addColors: function(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    },
    addScalar: function(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    },
    multiply: function(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    },
    multiplyScalar: function(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    },
    lerp: function(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    },
    equals: function(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    },
    fromArray: function(e, t) {
        return void 0 === t && (t = 0),
        this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    },
    toArray: function(e, t) {
        return void 0 === e && (e = []),
        void 0 === t && (t = 0),
        e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
},
THREE.ColorKeywords = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
},
THREE.Quaternion = function(e, t, n, r) {
    this._x = e || 0,
    this._y = t || 0,
    this._z = n || 0,
    this._w = void 0 !== r ? r: 1
},
THREE.Quaternion.prototype = {
    constructor: THREE.Quaternion,
    get x() {
        return this._x
    },
    set x(e) {
        this._x = e,
        this.onChangeCallback()
    },
    get y() {
        return this._y
    },
    set y(e) {
        this._y = e,
        this.onChangeCallback()
    },
    get z() {
        return this._z
    },
    set z(e) {
        this._z = e,
        this.onChangeCallback()
    },
    get w() {
        return this._w
    },
    set w(e) {
        this._w = e,
        this.onChangeCallback()
    },
    set: function(e, t, n, r) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._w = r,
        this.onChangeCallback(),
        this
    },
    clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._w)
    },
    copy: function(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this.onChangeCallback(),
        this
    },
    setFromEuler: function(e, t) {
        if (0 == e instanceof THREE.Euler) throw Error("THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var n = Math.cos(e._x / 2),
        r = Math.cos(e._y / 2),
        i = Math.cos(e._z / 2),
        s = Math.sin(e._x / 2),
        o = Math.sin(e._y / 2),
        u = Math.sin(e._z / 2),
        a = e.order;
        return "XYZ" === a ? (this._x = s * r * i + n * o * u, this._y = n * o * i - s * r * u, this._z = n * r * u + s * o * i, this._w = n * r * i - s * o * u) : "YXZ" === a ? (this._x = s * r * i + n * o * u, this._y = n * o * i - s * r * u, this._z = n * r * u - s * o * i, this._w = n * r * i + s * o * u) : "ZXY" === a ? (this._x = s * r * i - n * o * u, this._y = n * o * i + s * r * u, this._z = n * r * u + s * o * i, this._w = n * r * i - s * o * u) : "ZYX" === a ? (this._x = s * r * i - n * o * u, this._y = n * o * i + s * r * u, this._z = n * r * u - s * o * i, this._w = n * r * i + s * o * u) : "YZX" === a ? (this._x = s * r * i + n * o * u, this._y = n * o * i + s * r * u, this._z = n * r * u - s * o * i, this._w = n * r * i - s * o * u) : "XZY" === a && (this._x = s * r * i - n * o * u, this._y = n * o * i - s * r * u, this._z = n * r * u + s * o * i, this._w = n * r * i + s * o * u),
        !1 !== t && this.onChangeCallback(),
        this
    },
    setFromAxisAngle: function(e, t) {
        var n = t / 2,
        r = Math.sin(n);
        return this._x = e.x * r,
        this._y = e.y * r,
        this._z = e.z * r,
        this._w = Math.cos(n),
        this.onChangeCallback(),
        this
    },
    setFromRotationMatrix: function(e) {
        var t = e.elements,
        n = t[0];
        e = t[4];
        var r = t[8],
        i = t[1],
        s = t[5],
        o = t[9],
        u = t[2],
        a = t[6],
        t = t[10],
        f = n + s + t;
        return 0 < f ? (n = .5 / Math.sqrt(f + 1), this._w = .25 / n, this._x = (a - o) * n, this._y = (r - u) * n, this._z = (i - e) * n) : n > s && n > t ? (n = 2 * Math.sqrt(1 + n - s - t), this._w = (a - o) / n, this._x = .25 * n, this._y = (e + i) / n, this._z = (r + u) / n) : s > t ? (n = 2 * Math.sqrt(1 + s - n - t), this._w = (r - u) / n, this._x = (e + i) / n, this._y = .25 * n, this._z = (o + a) / n) : (n = 2 * Math.sqrt(1 + t - n - s), this._w = (i - e) / n, this._x = (r + u) / n, this._y = (o + a) / n, this._z = .25 * n),
        this.onChangeCallback(),
        this
    },
    setFromUnitVectors: function() {
        var e, t;
        return function(n, r) {
            return void 0 === e && (e = new THREE.Vector3),
            t = n.dot(r) + 1,
            1e-6 > t ? (t = 0, Math.abs(n.x) > Math.abs(n.z) ? e.set( - n.y, n.x, 0) : e.set(0, -n.z, n.y)) : e.crossVectors(n, r),
            this._x = e.x,
            this._y = e.y,
            this._z = e.z,
            this._w = t,
            this.normalize(),
            this
        }
    } (),
    inverse: function() {
        return this.conjugate().normalize(),
        this
    },
    conjugate: function() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this.onChangeCallback(),
        this
    },
    dot: function(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    },
    lengthSq: function() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    },
    length: function() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    },
    normalize: function() {
        var e = this.length();
        return 0 === e ? (this._z = this._y = this._x = 0, this._w = 1) : (e = 1 / e, this._x *= e, this._y *= e, this._z *= e, this._w *= e),
        this.onChangeCallback(),
        this
    },
    multiply: function(e, t) {
        return void 0 !== t ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(e, t)) : this.multiplyQuaternions(this, e)
    },
    multiplyQuaternions: function(e, t) {
        var n = e._x,
        r = e._y,
        i = e._z,
        s = e._w,
        o = t._x,
        u = t._y,
        a = t._z,
        f = t._w;
        return this._x = n * f + s * o + r * a - i * u,
        this._y = r * f + s * u + i * o - n * a,
        this._z = i * f + s * a + n * u - r * o,
        this._w = s * f - n * o - r * u - i * a,
        this.onChangeCallback(),
        this
    },
    slerp: function(e, t) {
        if (0 === t) return this;
        if (1 === t) return this.copy(e);
        var n = this._x,
        r = this._y,
        i = this._z,
        s = this._w,
        o = s * e._w + n * e._x + r * e._y + i * e._z;
        0 > o ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, o = -o) : this.copy(e);
        if (1 <= o) return this._w = s,
        this._x = n,
        this._y = r,
        this._z = i,
        this;
        var u = Math.sqrt(1 - o * o);
        if (.001 > Math.abs(u)) return this._w = .5 * (s + this._w),
        this._x = .5 * (n + this._x),
        this._y = .5 * (r + this._y),
        this._z = .5 * (i + this._z),
        this;
        var a = Math.atan2(u, o),
        o = Math.sin((1 - t) * a) / u,
        u = Math.sin(t * a) / u;
        return this._w = s * o + this._w * u,
        this._x = n * o + this._x * u,
        this._y = r * o + this._y * u,
        this._z = i * o + this._z * u,
        this.onChangeCallback(),
        this
    },
    equals: function(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    },
    fromArray: function(e, t) {
        return void 0 === t && (t = 0),
        this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this.onChangeCallback(),
        this
    },
    toArray: function(e, t) {
        return void 0 === e && (e = []),
        void 0 === t && (t = 0),
        e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    },
    onChange: function(e) {
        return this.onChangeCallback = e,
        this
    },
    onChangeCallback: function() {}
},
Object.assign(THREE.Quaternion, {
    slerp: function(e, t, n, r) {
        return n.copy(e).slerp(t, r)
    },
    slerpFlat: function(e, t, n, r, i, s, o) {
        var u = n[r + 0],
        a = n[r + 1],
        f = n[r + 2];
        n = n[r + 3],
        r = i[s + 0];
        var l = i[s + 1],
        c = i[s + 2];
        i = i[s + 3];
        if (n !== i || u !== r || a !== l || f !== c) {
            s = 1 - o;
            var h = u * r + a * l + f * c + n * i,
            p = 0 <= h ? 1 : -1,
            d = 1 - h * h;
            d > Number.EPSILON && (d = Math.sqrt(d), h = Math.atan2(d, h * p), s = Math.sin(s * h) / d, o = Math.sin(o * h) / d),
            p *= o,
            u = u * s + r * p,
            a = a * s + l * p,
            f = f * s + c * p,
            n = n * s + i * p,
            s === 1 - o && (o = 1 / Math.sqrt(u * u + a * a + f * f + n * n), u *= o, a *= o, f *= o, n *= o)
        }
        e[t] = u,
        e[t + 1] = a,
        e[t + 2] = f,
        e[t + 3] = n
    }
}),
THREE.Vector2 = function(e, t) {
    this.x = e || 0,
    this.y = t || 0
},
THREE.Vector2.prototype = {
    constructor: THREE.Vector2,
    get width() {
        return this.x
    },
    set width(e) {
        this.x = e
    },
    get height() {
        return this.y
    },
    set height(e) {
        this.y = e
    },
    set: function(e, t) {
        return this.x = e,
        this.y = t,
        this
    },
    setScalar: function(e) {
        return this.y = this.x = e,
        this
    },
    setX: function(e) {
        return this.x = e,
        this
    },
    setY: function(e) {
        return this.y = e,
        this
    },
    setComponent: function(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw Error("index is out of range: " + e)
        }
    },
    getComponent: function(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw Error("index is out of range: " + e)
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y)
    },
    copy: function(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    },
    add: function(e, t) {
        return void 0 !== t ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this)
    },
    addScalar: function(e) {
        return this.x += e,
        this.y += e,
        this
    },
    addVectors: function(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    },
    addScaledVector: function(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    },
    sub: function(e, t) {
        return void 0 !== t ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this)
    },
    subScalar: function(e) {
        return this.x -= e,
        this.y -= e,
        this
    },
    subVectors: function(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    },
    multiply: function(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    },
    multiplyScalar: function(e) {
        return isFinite(e) ? (this.x *= e, this.y *= e) : this.y = this.x = 0,
        this
    },
    divide: function(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    },
    divideScalar: function(e) {
        return this.multiplyScalar(1 / e)
    },
    min: function(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    },
    max: function(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    },
    clamp: function(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    },
    clampScalar: function() {
        var e, t;
        return function(n, r) {
            return void 0 === e && (e = new THREE.Vector2, t = new THREE.Vector2),
            e.set(n, n),
            t.set(r, r),
            this.clamp(e, t)
        }
    } (),
    clampLength: function(e, t) {
        var n = this.length();
        return this.multiplyScalar(Math.max(e, Math.min(t, n)) / n),
        this
    },
    floor: function() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    },
    ceil: function() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    },
    round: function() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    },
    roundToZero: function() {
        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y),
        this
    },
    negate: function() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    },
    dot: function(e) {
        return this.x * e.x + this.y * e.y
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y)
    },
    normalize: function() {
        return this.divideScalar(this.length())
    },
    angle: function() {
        var e = Math.atan2(this.y, this.x);
        return 0 > e && (e += 2 * Math.PI),
        e
    },
    distanceTo: function(e) {
        return Math.sqrt(this.distanceToSquared(e))
    },
    distanceToSquared: function(e) {
        var t = this.x - e.x;
        return e = this.y - e.y,
        t * t + e * e
    },
    setLength: function(e) {
        return this.multiplyScalar(e / this.length())
    },
    lerp: function(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    },
    lerpVectors: function(e, t, n) {
        return this.subVectors(t, e).multiplyScalar(n).add(e),
        this
    },
    equals: function(e) {
        return e.x === this.x && e.y === this.y
    },
    fromArray: function(e, t) {
        return void 0 === t && (t = 0),
        this.x = e[t],
        this.y = e[t + 1],
        this
    },
    toArray: function(e, t) {
        return void 0 === e && (e = []),
        void 0 === t && (t = 0),
        e[t] = this.x,
        e[t + 1] = this.y,
        e
    },
    fromAttribute: function(e, t, n) {
        return void 0 === n && (n = 0),
        t = t * e.itemSize + n,
        this.x = e.array[t],
        this.y = e.array[t + 1],
        this
    },
    rotateAround: function(e, t) {
        var n = Math.cos(t),
        r = Math.sin(t),
        i = this.x - e.x,
        s = this.y - e.y;
        return this.x = i * n - s * r + e.x,
        this.y = i * r + s * n + e.y,
        this
    }
},
THREE.Vector3 = function(e, t, n) {
    this.x = e || 0,
    this.y = t || 0,
    this.z = n || 0
},
THREE.Vector3.prototype = {
    constructor: THREE.Vector3,
    set: function(e, t, n) {
        return this.x = e,
        this.y = t,
        this.z = n,
        this
    },
    setScalar: function(e) {
        return this.z = this.y = this.x = e,
        this
    },
    setX: function(e) {
        return this.x = e,
        this
    },
    setY: function(e) {
        return this.y = e,
        this
    },
    setZ: function(e) {
        return this.z = e,
        this
    },
    setComponent: function(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw Error("index is out of range: " + e)
        }
    },
    getComponent: function(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw Error("index is out of range: " + e)
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y, this.z)
    },
    copy: function(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    },
    add: function(e, t) {
        return void 0 !== t ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this)
    },
    addScalar: function(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    },
    addVectors: function(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    },
    addScaledVector: function(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    },
    sub: function(e, t) {
        return void 0 !== t ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this)
    },
    subScalar: function(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    },
    subVectors: function(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    },
    multiply: function(e, t) {
        return void 0 !== t ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(e, t)) : (this.x *= e.x, this.y *= e.y, this.z *= e.z, this)
    },
    multiplyScalar: function(e) {
        return isFinite(e) ? (this.x *= e, this.y *= e, this.z *= e) : this.z = this.y = this.x = 0,
        this
    },
    multiplyVectors: function(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    },
    applyEuler: function() {
        var e;
        return function(t) {
            return 0 == t instanceof THREE.Euler && console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),
            void 0 === e && (e = new THREE.Quaternion),
            this.applyQuaternion(e.setFromEuler(t)),
            this
        }
    } (),
    applyAxisAngle: function() {
        var e;
        return function(t, n) {
            return void 0 === e && (e = new THREE.Quaternion),
            this.applyQuaternion(e.setFromAxisAngle(t, n)),
            this
        }
    } (),
    applyMatrix3: function(e) {
        var t = this.x,
        n = this.y,
        r = this.z;
        return e = e.elements,
        this.x = e[0] * t + e[3] * n + e[6] * r,
        this.y = e[1] * t + e[4] * n + e[7] * r,
        this.z = e[2] * t + e[5] * n + e[8] * r,
        this
    },
    applyMatrix4: function(e) {
        var t = this.x,
        n = this.y,
        r = this.z;
        return e = e.elements,
        this.x = e[0] * t + e[4] * n + e[8] * r + e[12],
        this.y = e[1] * t + e[5] * n + e[9] * r + e[13],
        this.z = e[2] * t + e[6] * n + e[10] * r + e[14],
        this
    },
    applyProjection: function(e) {
        var t = this.x,
        n = this.y,
        r = this.z;
        e = e.elements;
        var i = 1 / (e[3] * t + e[7] * n + e[11] * r + e[15]);
        return this.x = (e[0] * t + e[4] * n + e[8] * r + e[12]) * i,
        this.y = (e[1] * t + e[5] * n + e[9] * r + e[13]) * i,
        this.z = (e[2] * t + e[6] * n + e[10] * r + e[14]) * i,
        this
    },
    applyQuaternion: function(e) {
        var t = this.x,
        n = this.y,
        r = this.z,
        i = e.x,
        s = e.y,
        o = e.z;
        e = e.w;
        var u = e * t + s * r - o * n,
        a = e * n + o * t - i * r,
        f = e * r + i * n - s * t,
        t = -i * t - s * n - o * r;
        return this.x = u * e + t * -i + a * -o - f * -s,
        this.y = a * e + t * -s + f * -i - u * -o,
        this.z = f * e + t * -o + u * -s - a * -i,
        this
    },
    project: function() {
        var e;
        return function(t) {
            return void 0 === e && (e = new THREE.Matrix4),
            e.multiplyMatrices(t.projectionMatrix, e.getInverse(t.matrixWorld)),
            this.applyProjection(e)
        }
    } (),
    unproject: function() {
        var e;
        return function(t) {
            return void 0 === e && (e = new THREE.Matrix4),
            e.multiplyMatrices(t.matrixWorld, e.getInverse(t.projectionMatrix)),
            this.applyProjection(e)
        }
    } (),
    transformDirection: function(e) {
        var t = this.x,
        n = this.y,
        r = this.z;
        return e = e.elements,
        this.x = e[0] * t + e[4] * n + e[8] * r,
        this.y = e[1] * t + e[5] * n + e[9] * r,
        this.z = e[2] * t + e[6] * n + e[10] * r,
        this.normalize(),
        this
    },
    divide: function(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    },
    divideScalar: function(e) {
        return this.multiplyScalar(1 / e)
    },
    min: function(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    },
    max: function(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    },
    clamp: function(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    },
    clampScalar: function() {
        var e, t;
        return function(n, r) {
            return void 0 === e && (e = new THREE.Vector3, t = new THREE.Vector3),
            e.set(n, n, n),
            t.set(r, r, r),
            this.clamp(e, t)
        }
    } (),
    clampLength: function(e, t) {
        var n = this.length();
        return this.multiplyScalar(Math.max(e, Math.min(t, n)) / n),
        this
    },
    floor: function() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    },
    ceil: function() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    },
    round: function() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    },
    roundToZero: function() {
        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z),
        this
    },
    negate: function() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    },
    dot: function(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    },
    normalize: function() {
        return this.divideScalar(this.length())
    },
    setLength: function(e) {
        return this.multiplyScalar(e / this.length())
    },
    lerp: function(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    },
    lerpVectors: function(e, t, n) {
        return this.subVectors(t, e).multiplyScalar(n).add(e),
        this
    },
    cross: function(e, t) {
        if (void 0 !== t) return console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),
        this.crossVectors(e, t);
        var n = this.x,
        r = this.y,
        i = this.z;
        return this.x = r * e.z - i * e.y,
        this.y = i * e.x - n * e.z,
        this.z = n * e.y - r * e.x,
        this
    },
    crossVectors: function(e, t) {
        var n = e.x,
        r = e.y,
        i = e.z,
        s = t.x,
        o = t.y,
        u = t.z;
        return this.x = r * u - i * o,
        this.y = i * s - n * u,
        this.z = n * o - r * s,
        this
    },
    projectOnVector: function() {
        var e, t;
        return function(n) {
            return void 0 === e && (e = new THREE.Vector3),
            e.copy(n).normalize(),
            t = this.dot(e),
            this.copy(e).multiplyScalar(t)
        }
    } (),
    projectOnPlane: function() {
        var e;
        return function(t) {
            return void 0 === e && (e = new THREE.Vector3),
            e.copy(this).projectOnVector(t),
            this.sub(e)
        }
    } (),
    reflect: function() {
        var e;
        return function(t) {
            return void 0 === e && (e = new THREE.Vector3),
            this.sub(e.copy(t).multiplyScalar(2 * this.dot(t)))
        }
    } (),
    angleTo: function(e) {
        return e = this.dot(e) / Math.sqrt(this.lengthSq() * e.lengthSq()),
        Math.acos(THREE.Math.clamp(e, -1, 1))
    },
    distanceTo: function(e) {
        return Math.sqrt(this.distanceToSquared(e))
    },
    distanceToSquared: function(e) {
        var t = this.x - e.x,
        n = this.y - e.y;
        return e = this.z - e.z,
        t * t + n * n + e * e
    },
    setFromSpherical: function(e) {
        var t = Math.sin(e.phi) * e.radius;
        return this.x = t * Math.sin(e.theta),
        this.y = Math.cos(e.phi) * e.radius,
        this.z = t * Math.cos(e.theta),
        this
    },
    setFromMatrixPosition: function(e) {
        return this.setFromMatrixColumn(e, 3)
    },
    setFromMatrixScale: function(e) {
        var t = this.setFromMatrixColumn(e, 0).length(),
        n = this.setFromMatrixColumn(e, 1).length();
        return e = this.setFromMatrixColumn(e, 2).length(),
        this.x = t,
        this.y = n,
        this.z = e,
        this
    },
    setFromMatrixColumn: function(e, t) {
        return "number" == typeof e && (console.warn("THREE.Vector3: setFromMatrixColumn now expects ( matrix, index )."), t = e = t),
        this.fromArray(e.elements, 4 * t)
    },
    equals: function(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    },
    fromArray: function(e, t) {
        return void 0 === t && (t = 0),
        this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    },
    toArray: function(e, t) {
        return void 0 === e && (e = []),
        void 0 === t && (t = 0),
        e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    },
    fromAttribute: function(e, t, n) {
        return void 0 === n && (n = 0),
        t = t * e.itemSize + n,
        this.x = e.array[t],
        this.y = e.array[t + 1],
        this.z = e.array[t + 2],
        this
    }
},
THREE.Vector4 = function(e, t, n, r) {
    this.x = e || 0,
    this.y = t || 0,
    this.z = n || 0,
    this.w = void 0 !== r ? r: 1
},
THREE.Vector4.prototype = {
    constructor: THREE.Vector4,
    set: function(e, t, n, r) {
        return this.x = e,
        this.y = t,
        this.z = n,
        this.w = r,
        this
    },
    setScalar: function(e) {
        return this.w = this.z = this.y = this.x = e,
        this
    },
    setX: function(e) {
        return this.x = e,
        this
    },
    setY: function(e) {
        return this.y = e,
        this
    },
    setZ: function(e) {
        return this.z = e,
        this
    },
    setW: function(e) {
        return this.w = e,
        this
    },
    setComponent: function(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw Error("index is out of range: " + e)
        }
    },
    getComponent: function(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw Error("index is out of range: " + e)
        }
    },
    clone: function() {
        return new this.constructor(this.x, this.y, this.z, this.w)
    },
    copy: function(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = void 0 !== e.w ? e.w: 1,
        this
    },
    add: function(e, t) {
        return void 0 !== t ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(e, t)) : (this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this)
    },
    addScalar: function(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    },
    addVectors: function(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    },
    addScaledVector: function(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    },
    sub: function(e, t) {
        return void 0 !== t ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(e, t)) : (this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this)
    },
    subScalar: function(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    },
    subVectors: function(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    },
    multiplyScalar: function(e) {
        return isFinite(e) ? (this.x *= e, this.y *= e, this.z *= e, this.w *= e) : this.w = this.z = this.y = this.x = 0,
        this
    },
    applyMatrix4: function(e) {
        var t = this.x,
        n = this.y,
        r = this.z,
        i = this.w;
        return e = e.elements,
        this.x = e[0] * t + e[4] * n + e[8] * r + e[12] * i,
        this.y = e[1] * t + e[5] * n + e[9] * r + e[13] * i,
        this.z = e[2] * t + e[6] * n + e[10] * r + e[14] * i,
        this.w = e[3] * t + e[7] * n + e[11] * r + e[15] * i,
        this
    },
    divideScalar: function(e) {
        return this.multiplyScalar(1 / e)
    },
    setAxisAngleFromQuaternion: function(e) {
        this.w = 2 * Math.acos(e.w);
        var t = Math.sqrt(1 - e.w * e.w);
        return 1e-4 > t ? (this.x = 1, this.z = this.y = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t),
        this
    },
    setAxisAngleFromRotationMatrix: function(e) {
        var t, n, r;
        e = e.elements;
        var i = e[0];
        r = e[4];
        var s = e[8],
        o = e[1],
        u = e[5],
        a = e[9];
        n = e[2],
        t = e[6];
        var f = e[10];
        return.01 > Math.abs(r - o) && .01 > Math.abs(s - n) && .01 > Math.abs(a - t) ? .1 > Math.abs(r + o) && .1 > Math.abs(s + n) && .1 > Math.abs(a + t) && .1 > Math.abs(i + u + f - 3) ? (this.set(1, 0, 0, 0), this) : (e = Math.PI, i = (i + 1) / 2, u = (u + 1) / 2, f = (f + 1) / 2, r = (r + o) / 4, s = (s + n) / 4, a = (a + t) / 4, i > u && i > f ? .01 > i ? (t = 0, r = n = .707106781) : (t = Math.sqrt(i), n = r / t, r = s / t) : u > f ? .01 > u ? (t = .707106781, n = 0, r = .707106781) : (n = Math.sqrt(u), t = r / n, r = a / n) : .01 > f ? (n = t = .707106781, r = 0) : (r = Math.sqrt(f), t = s / r, n = a / r), this.set(t, n, r, e), this) : (e = Math.sqrt((t - a) * (t - a) + (s - n) * (s - n) + (o - r) * (o - r)), .001 > Math.abs(e) && (e = 1), this.x = (t - a) / e, this.y = (s - n) / e, this.z = (o - r) / e, this.w = Math.acos((i + u + f - 1) / 2), this)
    },
    min: function(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    },
    max: function(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    },
    clamp: function(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    },
    clampScalar: function() {
        var e, t;
        return function(n, r) {
            return void 0 === e && (e = new THREE.Vector4, t = new THREE.Vector4),
            e.set(n, n, n, n),
            t.set(r, r, r, r),
            this.clamp(e, t)
        }
    } (),
    floor: function() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    },
    ceil: function() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    },
    round: function() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    },
    roundToZero: function() {
        return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x),
        this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y),
        this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z),
        this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w),
        this
    },
    negate: function() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    },
    dot: function(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    },
    lengthSq: function() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    },
    length: function() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    },
    lengthManhattan: function() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    },
    normalize: function() {
        return this.divideScalar(this.length())
    },
    setLength: function(e) {
        return this.multiplyScalar(e / this.length())
    },
    lerp: function(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    },
    lerpVectors: function(e, t, n) {
        return this.subVectors(t, e).multiplyScalar(n).add(e),
        this
    },
    equals: function(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    },
    fromArray: function(e, t) {
        return void 0 === t && (t = 0),
        this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    },
    toArray: function(e, t) {
        return void 0 === e && (e = []),
        void 0 === t && (t = 0),
        e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    },
    fromAttribute: function(e, t, n) {
        return void 0 === n && (n = 0),
        t = t * e.itemSize + n,
        this.x = e.array[t],
        this.y = e.array[t + 1],
        this.z = e.array[t + 2],
        this.w = e.array[t + 3],
        this
    }
},
THREE.Euler = function(e, t, n, r) {
    this._x = e || 0,
    this._y = t || 0,
    this._z = n || 0,
    this._order = r || THREE.Euler.DefaultOrder
},
THREE.Euler.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "),
THREE.Euler.DefaultOrder = "XYZ",
THREE.Euler.prototype = {
    constructor: THREE.Euler,
    get x() {
        return this._x
    },
    set x(e) {
        this._x = e,
        this.onChangeCallback()
    },
    get y() {
        return this._y
    },
    set y(e) {
        this._y = e,
        this.onChangeCallback()
    },
    get z() {
        return this._z
    },
    set z(e) {
        this._z = e,
        this.onChangeCallback()
    },
    get order() {
        return this._order
    },
    set order(e) {
        this._order = e,
        this.onChangeCallback()
    },
    set: function(e, t, n, r) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._order = r || this._order,
        this.onChangeCallback(),
        this
    },
    clone: function() {
        return new this.constructor(this._x, this._y, this._z, this._order)
    },
    copy: function(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this.onChangeCallback(),
        this
    },
    setFromRotationMatrix: function(e, t, n) {
        var r = THREE.Math.clamp,
        i = e.elements;
        e = i[0];
        var s = i[4],
        o = i[8],
        u = i[1],
        a = i[5],
        f = i[9],
        l = i[2],
        c = i[6],
        i = i[10];
        return t = t || this._order,
        "XYZ" === t ? (this._y = Math.asin(r(o, -1, 1)), .99999 > Math.abs(o) ? (this._x = Math.atan2( - f, i), this._z = Math.atan2( - s, e)) : (this._x = Math.atan2(c, a), this._z = 0)) : "YXZ" === t ? (this._x = Math.asin( - r(f, -1, 1)), .99999 > Math.abs(f) ? (this._y = Math.atan2(o, i), this._z = Math.atan2(u, a)) : (this._y = Math.atan2( - l, e), this._z = 0)) : "ZXY" === t ? (this._x = Math.asin(r(c, -1, 1)), .99999 > Math.abs(c) ? (this._y = Math.atan2( - l, i), this._z = Math.atan2( - s, a)) : (this._y = 0, this._z = Math.atan2(u, e))) : "ZYX" === t ? (this._y = Math.asin( - r(l, -1, 1)), .99999 > Math.abs(l) ? (this._x = Math.atan2(c, i), this._z = Math.atan2(u, e)) : (this._x = 0, this._z = Math.atan2( - s, a))) : "YZX" === t ? (this._z = Math.asin(r(u, -1, 1)), .99999 > Math.abs(u) ? (this._x = Math.atan2( - f, a), this._y = Math.atan2( - l, e)) : (this._x = 0, this._y = Math.atan2(o, i))) : "XZY" === t ? (this._z = Math.asin( - r(s, -1, 1)), .99999 > Math.abs(s) ? (this._x = Math.atan2(c, a), this._y = Math.atan2(o, e)) : (this._x = Math.atan2( - f, i), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + t),
        this._order = t,
        !1 !== n && this.onChangeCallback(),
        this
    },
    setFromQuaternion: function() {
        var e;
        return function(t, n, r) {
            return void 0 === e && (e = new THREE.Matrix4),
            e.makeRotationFromQuaternion(t),
            this.setFromRotationMatrix(e, n, r),
            this
        }
    } (),
    setFromVector3: function(e, t) {
        return this.set(e.x, e.y, e.z, t || this._order)
    },
    reorder: function() {
        var e = new THREE.Quaternion;
        return function(t) {
            e.setFromEuler(this),
            this.setFromQuaternion(e, t)
        }
    } (),
    equals: function(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    },
    fromArray: function(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        void 0 !== e[3] && (this._order = e[3]),
        this.onChangeCallback(),
        this
    },
    toArray: function(e, t) {
        return void 0 === e && (e = []),
        void 0 === t && (t = 0),
        e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    },
    toVector3: function(e) {
        return e ? e.set(this._x, this._y, this._z) : new THREE.Vector3(this._x, this._y, this._z)
    },
    onChange: function(e) {
        return this.onChangeCallback = e,
        this
    },
    onChangeCallback: function() {}
},
THREE.Line3 = function(e, t) {
    this.start = void 0 !== e ? e: new THREE.Vector3,
    this.end = void 0 !== t ? t: new THREE.Vector3
},
THREE.Line3.prototype = {
    constructor: THREE.Line3,
    set: function(e, t) {
        return this.start.copy(e),
        this.end.copy(t),
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(e) {
        return this.start.copy(e.start),
        this.end.copy(e.end),
        this
    },
    center: function(e) {
        return (e || new THREE.Vector3).addVectors(this.start, this.end).multiplyScalar(.5)
    },
    delta: function(e) {
        return (e || new THREE.Vector3).subVectors(this.end, this.start)
    },
    distanceSq: function() {
        return this.start.distanceToSquared(this.end)
    },
    distance: function() {
        return this.start.distanceTo(this.end)
    },
    at: function(e, t) {
        var n = t || new THREE.Vector3;
        return this.delta(n).multiplyScalar(e).add(this.start)
    },
    closestPointToPointParameter: function() {
        var e = new THREE.Vector3,
        t = new THREE.Vector3;
        return function(n, r) {
            e.subVectors(n, this.start),
            t.subVectors(this.end, this.start);
            var i = t.dot(t),
            i = t.dot(e) / i;
            return r && (i = THREE.Math.clamp(i, 0, 1)),
            i
        }
    } (),
    closestPointToPoint: function(e, t, n) {
        return e = this.closestPointToPointParameter(e, t),
        n = n || new THREE.Vector3,
        this.delta(n).multiplyScalar(e).add(this.start)
    },
    applyMatrix4: function(e) {
        return this.start.applyMatrix4(e),
        this.end.applyMatrix4(e),
        this
    },
    equals: function(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
},
THREE.Box2 = function(e, t) {
    this.min = void 0 !== e ? e: new THREE.Vector2(Infinity, Infinity),
    this.max = void 0 !== t ? t: new THREE.Vector2( - Infinity, -Infinity)
},
THREE.Box2.prototype = {
    constructor: THREE.Box2,
    set: function(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    },
    setFromPoints: function(e) {
        this.makeEmpty();
        for (var t = 0,
        n = e.length; t < n; t++) this.expandByPoint(e[t]);
        return this
    },
    setFromCenterAndSize: function() {
        var e = new THREE.Vector2;
        return function(t, n) {
            var r = e.copy(n).multiplyScalar(.5);
            return this.min.copy(t).sub(r),
            this.max.copy(t).add(r),
            this
        }
    } (),
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    },
    makeEmpty: function() {
        return this.min.x = this.min.y = Infinity,
        this.max.x = this.max.y = -Infinity,
        this
    },
    isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    },
    center: function(e) {
        return (e || new THREE.Vector2).addVectors(this.min, this.max).multiplyScalar(.5)
    },
    size: function(e) {
        return (e || new THREE.Vector2).subVectors(this.max, this.min)
    },
    expandByPoint: function(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    },
    expandByVector: function(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    },
    expandByScalar: function(e) {
        return this.min.addScalar( - e),
        this.max.addScalar(e),
        this
    },
    containsPoint: function(e) {
        return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y ? !1 : !0
    },
    containsBox: function(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y ? !0 : !1
    },
    getParameter: function(e, t) {
        return (t || new THREE.Vector2).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    },
    intersectsBox: function(e) {
        return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y ? !1 : !0
    },
    clampPoint: function(e, t) {
        return (t || new THREE.Vector2).copy(e).clamp(this.min, this.max)
    },
    distanceToPoint: function() {
        var e = new THREE.Vector2;
        return function(t) {
            return e.copy(t).clamp(this.min, this.max).sub(t).length()
        }
    } (),
    intersect: function(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this
    },
    union: function(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    },
    translate: function(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    },
    equals: function(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
},
THREE.Box3 = function(e, t) {
    this.min = void 0 !== e ? e: new THREE.Vector3(Infinity, Infinity, Infinity),
    this.max = void 0 !== t ? t: new THREE.Vector3( - Infinity, -Infinity, -Infinity)
},
THREE.Box3.prototype = {
    constructor: THREE.Box3,
    set: function(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    },
    setFromArray: function(e) {
        this.makeEmpty();
        for (var t = Infinity,
        n = Infinity,
        r = Infinity,
        i = -Infinity,
        s = -Infinity,
        o = -Infinity,
        u = 0,
        a = e.length; u < a; u += 3) {
            var f = e[u],
            l = e[u + 1],
            c = e[u + 2];
            f < t && (t = f),
            l < n && (n = l),
            c < r && (r = c),
            f > i && (i = f),
            l > s && (s = l),
            c > o && (o = c)
        }
        this.min.set(t, n, r),
        this.max.set(i, s, o)
    },
    setFromPoints: function(e) {
        this.makeEmpty();
        for (var t = 0,
        n = e.length; t < n; t++) this.expandByPoint(e[t]);
        return this
    },
    setFromCenterAndSize: function() {
        var e = new THREE.Vector3;
        return function(t, n) {
            var r = e.copy(n).multiplyScalar(.5);
            return this.min.copy(t).sub(r),
            this.max.copy(t).add(r),
            this
        }
    } (),
    setFromObject: function() {
        var e;
        return function(t) {
            void 0 === e && (e = new THREE.Box3);
            var n = this;
            return this.makeEmpty(),
            t.updateMatrixWorld(!0),
            t.traverse(function(t) {
                var r = t.geometry;
                void 0 !== r && (null === r.boundingBox && r.computeBoundingBox(), !1 === r.boundingBox.isEmpty() && (e.copy(r.boundingBox), e.applyMatrix4(t.matrixWorld), n.union(e)))
            }),
            this
        }
    } (),
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    },
    makeEmpty: function() {
        return this.min.x = this.min.y = this.min.z = Infinity,
        this.max.x = this.max.y = this.max.z = -Infinity,
        this
    },
    isEmpty: function() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    },
    center: function(e) {
        return (e || new THREE.Vector3).addVectors(this.min, this.max).multiplyScalar(.5)
    },
    size: function(e) {
        return (e || new THREE.Vector3).subVectors(this.max, this.min)
    },
    expandByPoint: function(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    },
    expandByVector: function(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    },
    expandByScalar: function(e) {
        return this.min.addScalar( - e),
        this.max.addScalar(e),
        this
    },
    containsPoint: function(e) {
        return e.x < this.min.x || e.x > this.max.x || e.y < this.min.y || e.y > this.max.y || e.z < this.min.z || e.z > this.max.z ? !1 : !0
    },
    containsBox: function(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z ? !0 : !1
    },
    getParameter: function(e, t) {
        return (t || new THREE.Vector3).set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    },
    intersectsBox: function(e) {
        return e.max.x < this.min.x || e.min.x > this.max.x || e.max.y < this.min.y || e.min.y > this.max.y || e.max.z < this.min.z || e.min.z > this.max.z ? !1 : !0
    },
    intersectsSphere: function() {
        var e;
        return function(t) {
            return void 0 === e && (e = new THREE.Vector3),
            this.clampPoint(t.center, e),
            e.distanceToSquared(t.center) <= t.radius * t.radius
        }
    } (),
    intersectsPlane: function(e) {
        var t, n;
        return 0 < e.normal.x ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x),
        0 < e.normal.y ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y),
        0 < e.normal.z ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z),
        t <= e.constant && n >= e.constant
    },
    clampPoint: function(e, t) {
        return (t || new THREE.Vector3).copy(e).clamp(this.min, this.max)
    },
    distanceToPoint: function() {
        var e = new THREE.Vector3;
        return function(t) {
            return e.copy(t).clamp(this.min, this.max).sub(t).length()
        }
    } (),
    getBoundingSphere: function() {
        var e = new THREE.Vector3;
        return function(t) {
            return t = t || new THREE.Sphere,
            t.center = this.center(),
            t.radius = .5 * this.size(e).length(),
            t
        }
    } (),
    intersect: function(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this
    },
    union: function(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    },
    applyMatrix4: function() {
        var e = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3, new THREE.Vector3];
        return function(t) {
            return e[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(t),
            e[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(t),
            e[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(t),
            e[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(t),
            e[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(t),
            e[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(t),
            e[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(t),
            e[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(t),
            this.makeEmpty(),
            this.setFromPoints(e),
            this
        }
    } (),
    translate: function(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    },
    equals: function(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
},
THREE.Matrix3 = function() {
    this.elements = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]),
    0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
},
THREE.Matrix3.prototype = {
    constructor: THREE.Matrix3,
    set: function(e, t, n, r, i, s, o, u, a) {
        var f = this.elements;
        return f[0] = e,
        f[1] = r,
        f[2] = o,
        f[3] = t,
        f[4] = i,
        f[5] = u,
        f[6] = n,
        f[7] = s,
        f[8] = a,
        this
    },
    identity: function() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    },
    clone: function() {
        return (new this.constructor).fromArray(this.elements)
    },
    copy: function(e) {
        return e = e.elements,
        this.set(e[0], e[3], e[6], e[1], e[4], e[7], e[2], e[5], e[8]),
        this
    },
    setFromMatrix4: function(e) {
        return e = e.elements,
        this.set(e[0], e[4], e[8], e[1], e[5], e[9], e[2], e[6], e[10]),
        this
    },
    applyToVector3Array: function() {
        var e;
        return function(t, n, r) {
            void 0 === e && (e = new THREE.Vector3),
            void 0 === n && (n = 0),
            void 0 === r && (r = t.length);
            for (var i = 0; i < r; i += 3, n += 3) e.fromArray(t, n),
            e.applyMatrix3(this),
            e.toArray(t, n);
            return t
        }
    } (),
    applyToBuffer: function() {
        var e;
        return function(t, n, r) {
            void 0 === e && (e = new THREE.Vector3),
            void 0 === n && (n = 0),
            void 0 === r && (r = t.length / t.itemSize);
            for (var i = 0; i < r; i++, n++) e.x = t.getX(n),
            e.y = t.getY(n),
            e.z = t.getZ(n),
            e.applyMatrix3(this),
            t.setXYZ(e.x, e.y, e.z);
            return t
        }
    } (),
    multiplyScalar: function(e) {
        var t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    },
    determinant: function() {
        var e = this.elements,
        t = e[0],
        n = e[1],
        r = e[2],
        i = e[3],
        s = e[4],
        o = e[5],
        u = e[6],
        a = e[7],
        e = e[8];
        return t * s * e - t * o * a - n * i * e + n * o * u + r * i * a - r * s * u
    },
    getInverse: function(e, t) {
        e instanceof THREE.Matrix4 && console.warn("THREE.Matrix3.getInverse no longer takes a Matrix4 argument.");
        var n = e.elements,
        r = this.elements,
        i = n[0],
        s = n[1],
        o = n[2],
        u = n[3],
        a = n[4],
        f = n[5],
        l = n[6],
        c = n[7],
        n = n[8],
        h = n * a - f * c,
        p = f * l - n * u,
        d = c * u - a * l,
        v = i * h + s * p + o * d;
        if (0 === v) {
            if (t) throw Error("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0");
            return console.warn("THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0"),
            this.identity()
        }
        return r[0] = h,
        r[1] = o * c - n * s,
        r[2] = f * s - o * a,
        r[3] = p,
        r[4] = n * i - o * l,
        r[5] = o * u - f * i,
        r[6] = d,
        r[7] = s * l - c * i,
        r[8] = a * i - s * u,
        this.multiplyScalar(1 / v)
    },
    transpose: function() {
        var e, t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    },
    flattenToArrayOffset: function(e, t) {
        var n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e
    },
    getNormalMatrix: function(e) {
        return this.setFromMatrix4(e).getInverse(this).transpose()
    },
    transposeIntoArray: function(e) {
        var t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    },
    fromArray: function(e) {
        return this.elements.set(e),
        this
    },
    toArray: function() {
        var e = this.elements;
        return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8]]
    }
},
THREE.Matrix4 = function() {
    this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
    0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
},
THREE.Matrix4.prototype = {
    constructor: THREE.Matrix4,
    set: function(e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v) {
        var m = this.elements;
        return m[0] = e,
        m[4] = t,
        m[8] = n,
        m[12] = r,
        m[1] = i,
        m[5] = s,
        m[9] = o,
        m[13] = u,
        m[2] = a,
        m[6] = f,
        m[10] = l,
        m[14] = c,
        m[3] = h,
        m[7] = p,
        m[11] = d,
        m[15] = v,
        this
    },
    identity: function() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    },
    clone: function() {
        return (new THREE.Matrix4).fromArray(this.elements)
    },
    copy: function(e) {
        return this.elements.set(e.elements),
        this
    },
    copyPosition: function(e) {
        var t = this.elements;
        return e = e.elements,
        t[12] = e[12],
        t[13] = e[13],
        t[14] = e[14],
        this
    },
    extractBasis: function(e, t, n) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
    },
    makeBasis: function(e, t, n) {
        return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
        this
    },
    extractRotation: function() {
        var e;
        return function(t) {
            void 0 === e && (e = new THREE.Vector3);
            var n = this.elements,
            r = t.elements,
            i = 1 / e.setFromMatrixColumn(t, 0).length(),
            s = 1 / e.setFromMatrixColumn(t, 1).length();
            return t = 1 / e.setFromMatrixColumn(t, 2).length(),
            n[0] = r[0] * i,
            n[1] = r[1] * i,
            n[2] = r[2] * i,
            n[4] = r[4] * s,
            n[5] = r[5] * s,
            n[6] = r[6] * s,
            n[8] = r[8] * t,
            n[9] = r[9] * t,
            n[10] = r[10] * t,
            this
        }
    } (),
    makeRotationFromEuler: function(e) {
        0 == e instanceof THREE.Euler && console.error("THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
        var t = this.elements,
        n = e.x,
        r = e.y,
        i = e.z,
        s = Math.cos(n),
        n = Math.sin(n),
        o = Math.cos(r),
        r = Math.sin(r),
        u = Math.cos(i),
        i = Math.sin(i);
        if ("XYZ" === e.order) {
            e = s * u;
            var a = s * i,
            f = n * u,
            l = n * i;
            t[0] = o * u,
            t[4] = -o * i,
            t[8] = r,
            t[1] = a + f * r,
            t[5] = e - l * r,
            t[9] = -n * o,
            t[2] = l - e * r,
            t[6] = f + a * r,
            t[10] = s * o
        } else "YXZ" === e.order ? (e = o * u, a = o * i, f = r * u, l = r * i, t[0] = e + l * n, t[4] = f * n - a, t[8] = s * r, t[1] = s * i, t[5] = s * u, t[9] = -n, t[2] = a * n - f, t[6] = l + e * n, t[10] = s * o) : "ZXY" === e.order ? (e = o * u, a = o * i, f = r * u, l = r * i, t[0] = e - l * n, t[4] = -s * i, t[8] = f + a * n, t[1] = a + f * n, t[5] = s * u, t[9] = l - e * n, t[2] = -s * r, t[6] = n, t[10] = s * o) : "ZYX" === e.order ? (e = s * u, a = s * i, f = n * u, l = n * i, t[0] = o * u, t[4] = f * r - a, t[8] = e * r + l, t[1] = o * i, t[5] = l * r + e, t[9] = a * r - f, t[2] = -r, t[6] = n * o, t[10] = s * o) : "YZX" === e.order ? (e = s * o, a = s * r, f = n * o, l = n * r, t[0] = o * u, t[4] = l - e * i, t[8] = f * i + a, t[1] = i, t[5] = s * u, t[9] = -n * u, t[2] = -r * u, t[6] = a * i + f, t[10] = e - l * i) : "XZY" === e.order && (e = s * o, a = s * r, f = n * o, l = n * r, t[0] = o * u, t[4] = -i, t[8] = r * u, t[1] = e * i + l, t[5] = s * u, t[9] = a * i - f, t[2] = f * i - a, t[6] = n * u, t[10] = l * i + e);
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    },
    makeRotationFromQuaternion: function(e) {
        var t = this.elements,
        n = e.x,
        r = e.y,
        i = e.z,
        s = e.w,
        o = n + n,
        u = r + r,
        a = i + i;
        e = n * o;
        var f = n * u,
        n = n * a,
        l = r * u,
        r = r * a,
        i = i * a,
        o = s * o,
        u = s * u,
        s = s * a;
        return t[0] = 1 - (l + i),
        t[4] = f - s,
        t[8] = n + u,
        t[1] = f + s,
        t[5] = 1 - (e + i),
        t[9] = r - o,
        t[2] = n - u,
        t[6] = r + o,
        t[10] = 1 - (e + l),
        t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    },
    lookAt: function() {
        var e, t, n;
        return function(r, i, s) {
            void 0 === e && (e = new THREE.Vector3),
            void 0 === t && (t = new THREE.Vector3),
            void 0 === n && (n = new THREE.Vector3);
            var o = this.elements;
            return n.subVectors(r, i).normalize(),
            0 === n.lengthSq() && (n.z = 1),
            e.crossVectors(s, n).normalize(),
            0 === e.lengthSq() && (n.x += 1e-4, e.crossVectors(s, n).normalize()),
            t.crossVectors(n, e),
            o[0] = e.x,
            o[4] = t.x,
            o[8] = n.x,
            o[1] = e.y,
            o[5] = t.y,
            o[9] = n.y,
            o[2] = e.z,
            o[6] = t.z,
            o[10] = n.z,
            this
        }
    } (),
    multiply: function(e, t) {
        return void 0 !== t ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(e, t)) : this.multiplyMatrices(this, e)
    },
    multiplyMatrices: function(e, t) {
        var n = e.elements,
        r = t.elements,
        i = this.elements,
        s = n[0],
        o = n[4],
        u = n[8],
        a = n[12],
        f = n[1],
        l = n[5],
        c = n[9],
        h = n[13],
        p = n[2],
        d = n[6],
        v = n[10],
        m = n[14],
        g = n[3],
        y = n[7],
        b = n[11],
        n = n[15],
        w = r[0],
        E = r[4],
        S = r[8],
        x = r[12],
        T = r[1],
        N = r[5],
        C = r[9],
        k = r[13],
        L = r[2],
        A = r[6],
        O = r[10],
        M = r[14],
        _ = r[3],
        D = r[7],
        P = r[11],
        r = r[15];
        return i[0] = s * w + o * T + u * L + a * _,
        i[4] = s * E + o * N + u * A + a * D,
        i[8] = s * S + o * C + u * O + a * P,
        i[12] = s * x + o * k + u * M + a * r,
        i[1] = f * w + l * T + c * L + h * _,
        i[5] = f * E + l * N + c * A + h * D,
        i[9] = f * S + l * C + c * O + h * P,
        i[13] = f * x + l * k + c * M + h * r,
        i[2] = p * w + d * T + v * L + m * _,
        i[6] = p * E + d * N + v * A + m * D,
        i[10] = p * S + d * C + v * O + m * P,
        i[14] = p * x + d * k + v * M + m * r,
        i[3] = g * w + y * T + b * L + n * _,
        i[7] = g * E + y * N + b * A + n * D,
        i[11] = g * S + y * C + b * O + n * P,
        i[15] = g * x + y * k + b * M + n * r,
        this
    },
    multiplyToArray: function(e, t, n) {
        var r = this.elements;
        return this.multiplyMatrices(e, t),
        n[0] = r[0],
        n[1] = r[1],
        n[2] = r[2],
        n[3] = r[3],
        n[4] = r[4],
        n[5] = r[5],
        n[6] = r[6],
        n[7] = r[7],
        n[8] = r[8],
        n[9] = r[9],
        n[10] = r[10],
        n[11] = r[11],
        n[12] = r[12],
        n[13] = r[13],
        n[14] = r[14],
        n[15] = r[15],
        this
    },
    multiplyScalar: function(e) {
        var t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    },
    applyToVector3Array: function() {
        var e;
        return function(t, n, r) {
            void 0 === e && (e = new THREE.Vector3),
            void 0 === n && (n = 0),
            void 0 === r && (r = t.length);
            for (var i = 0; i < r; i += 3, n += 3) e.fromArray(t, n),
            e.applyMatrix4(this),
            e.toArray(t, n);
            return t
        }
    } (),
    applyToBuffer: function() {
        var e;
        return function(t, n, r) {
            void 0 === e && (e = new THREE.Vector3),
            void 0 === n && (n = 0),
            void 0 === r && (r = t.length / t.itemSize);
            for (var i = 0; i < r; i++, n++) e.x = t.getX(n),
            e.y = t.getY(n),
            e.z = t.getZ(n),
            e.applyMatrix4(this),
            t.setXYZ(e.x, e.y, e.z);
            return t
        }
    } (),
    determinant: function() {
        var e = this.elements,
        t = e[0],
        n = e[4],
        r = e[8],
        i = e[12],
        s = e[1],
        o = e[5],
        u = e[9],
        a = e[13],
        f = e[2],
        l = e[6],
        c = e[10],
        h = e[14];
        return e[3] * ( + i * u * l - r * a * l - i * o * c + n * a * c + r * o * h - n * u * h) + e[7] * ( + t * u * h - t * a * c + i * s * c - r * s * h + r * a * f - i * u * f) + e[11] * ( + t * a * l - t * o * h - i * s * l + n * s * h + i * o * f - n * a * f) + e[15] * ( - r * o * f - t * u * l + t * o * c + r * s * l - n * s * c + n * u * f)
    },
    transpose: function() {
        var e = this.elements,
        t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    },
    flattenToArrayOffset: function(e, t) {
        var n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e[t + 9] = n[9],
        e[t + 10] = n[10],
        e[t + 11] = n[11],
        e[t + 12] = n[12],
        e[t + 13] = n[13],
        e[t + 14] = n[14],
        e[t + 15] = n[15],
        e
    },
    getPosition: function() {
        var e;
        return function() {
            return void 0 === e && (e = new THREE.Vector3),
            console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."),
            e.setFromMatrixColumn(this, 3)
        }
    } (),
    setPosition: function(e) {
        var t = this.elements;
        return t[12] = e.x,
        t[13] = e.y,
        t[14] = e.z,
        this
    },
    getInverse: function(e, t) {
        var n = this.elements,
        r = e.elements,
        i = r[0],
        s = r[1],
        o = r[2],
        u = r[3],
        a = r[4],
        f = r[5],
        l = r[6],
        c = r[7],
        h = r[8],
        p = r[9],
        d = r[10],
        v = r[11],
        m = r[12],
        g = r[13],
        y = r[14],
        r = r[15],
        b = p * y * c - g * d * c + g * l * v - f * y * v - p * l * r + f * d * r,
        w = m * d * c - h * y * c - m * l * v + a * y * v + h * l * r - a * d * r,
        E = h * g * c - m * p * c + m * f * v - a * g * v - h * f * r + a * p * r,
        S = m * p * l - h * g * l - m * f * d + a * g * d + h * f * y - a * p * y,
        x = i * b + s * w + o * E + u * S;
        if (0 === x) {
            if (t) throw Error("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0");
            return console.warn("THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0"),
            this.identity()
        }
        return n[0] = b,
        n[1] = g * d * u - p * y * u - g * o * v + s * y * v + p * o * r - s * d * r,
        n[2] = f * y * u - g * l * u + g * o * c - s * y * c - f * o * r + s * l * r,
        n[3] = p * l * u - f * d * u - p * o * c + s * d * c + f * o * v - s * l * v,
        n[4] = w,
        n[5] = h * y * u - m * d * u + m * o * v - i * y * v - h * o * r + i * d * r,
        n[6] = m * l * u - a * y * u - m * o * c + i * y * c + a * o * r - i * l * r,
        n[7] = a * d * u - h * l * u + h * o * c - i * d * c - a * o * v + i * l * v,
        n[8] = E,
        n[9] = m * p * u - h * g * u - m * s * v + i * g * v + h * s * r - i * p * r,
        n[10] = a * g * u - m * f * u + m * s * c - i * g * c - a * s * r + i * f * r,
        n[11] = h * f * u - a * p * u - h * s * c + i * p * c + a * s * v - i * f * v,
        n[12] = S,
        n[13] = h * g * o - m * p * o + m * s * d - i * g * d - h * s * y + i * p * y,
        n[14] = m * f * o - a * g * o - m * s * l + i * g * l + a * s * y - i * f * y,
        n[15] = a * p * o - h * f * o + h * s * l - i * p * l - a * s * d + i * f * d,
        this.multiplyScalar(1 / x)
    },
    scale: function(e) {
        var t = this.elements,
        n = e.x,
        r = e.y;
        return e = e.z,
        t[0] *= n,
        t[4] *= r,
        t[8] *= e,
        t[1] *= n,
        t[5] *= r,
        t[9] *= e,
        t[2] *= n,
        t[6] *= r,
        t[10] *= e,
        t[3] *= n,
        t[7] *= r,
        t[11] *= e,
        this
    },
    getMaxScaleOnAxis: function() {
        var e = this.elements;
        return Math.sqrt(Math.max(e[0] * e[0] + e[1] * e[1] + e[2] * e[2], e[4] * e[4] + e[5] * e[5] + e[6] * e[6], e[8] * e[8] + e[9] * e[9] + e[10] * e[10]))
    },
    makeTranslation: function(e, t, n) {
        return this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
        this
    },
    makeRotationX: function(e) {
        var t = Math.cos(e);
        return e = Math.sin(e),
        this.set(1, 0, 0, 0, 0, t, -e, 0, 0, e, t, 0, 0, 0, 0, 1),
        this
    },
    makeRotationY: function(e) {
        var t = Math.cos(e);
        return e = Math.sin(e),
        this.set(t, 0, e, 0, 0, 1, 0, 0, -e, 0, t, 0, 0, 0, 0, 1),
        this
    },
    makeRotationZ: function(e) {
        var t = Math.cos(e);
        return e = Math.sin(e),
        this.set(t, -e, 0, 0, e, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    },
    makeRotationAxis: function(e, t) {
        var n = Math.cos(t),
        r = Math.sin(t),
        i = 1 - n,
        s = e.x,
        o = e.y,
        u = e.z,
        a = i * s,
        f = i * o;
        return this.set(a * s + n, a * o - r * u, a * u + r * o, 0, a * o + r * u, f * o + n, f * u - r * s, 0, a * u - r * o, f * u + r * s, i * u * u + n, 0, 0, 0, 0, 1),
        this
    },
    makeScale: function(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
        this
    },
    compose: function(e, t, n) {
        return this.makeRotationFromQuaternion(t),
        this.scale(n),
        this.setPosition(e),
        this
    },
    decompose: function() {
        var e, t;
        return function(n, r, i) {
            void 0 === e && (e = new THREE.Vector3),
            void 0 === t && (t = new THREE.Matrix4);
            var s = this.elements,
            o = e.set(s[0], s[1], s[2]).length(),
            u = e.set(s[4], s[5], s[6]).length(),
            f = e.set(s[8], s[9], s[10]).length();
            0 > this.determinant() && (o = -o),
            n.x = s[12],
            n.y = s[13],
            n.z = s[14],
            t.elements.set(this.elements),
            n = 1 / o;
            var s = 1 / u,
            l = 1 / f;
            return t.elements[0] *= n,
            t.elements[1] *= n,
            t.elements[2] *= n,
            t.elements[4] *= s,
            t.elements[5] *= s,
            t.elements[6] *= s,
            t.elements[8] *= l,
            t.elements[9] *= l,
            t.elements[10] *= l,
            r.setFromRotationMatrix(t),
            i.x = o,
            i.y = u,
            i.z = f,
            this
        }
    } (),
    makeFrustum: function(e, t, n, r, i, s) {
        var o = this.elements;
        return o[0] = 2 * i / (t - e),
        o[4] = 0,
        o[8] = (t + e) / (t - e),
        o[12] = 0,
        o[1] = 0,
        o[5] = 2 * i / (r - n),
        o[9] = (r + n) / (r - n),
        o[13] = 0,
        o[2] = 0,
        o[6] = 0,
        o[10] = -(s + i) / (s - i),
        o[14] = -2 * s * i / (s - i),
        o[3] = 0,
        o[7] = 0,
        o[11] = -1,
        o[15] = 0,
        this
    },
    makePerspective: function(e, t, n, r) {
        e = n * Math.tan(THREE.Math.degToRad(.5 * e));
        var i = -e;
        return this.makeFrustum(i * t, e * t, i, e, n, r)
    },
    makeOrthographic: function(e, t, n, r, i, s) {
        var o = this.elements,
        u = 1 / (t - e),
        a = 1 / (n - r),
        f = 1 / (s - i);
        return o[0] = 2 * u,
        o[4] = 0,
        o[8] = 0,
        o[12] = -((t + e) * u),
        o[1] = 0,
        o[5] = 2 * a,
        o[9] = 0,
        o[13] = -((n + r) * a),
        o[2] = 0,
        o[6] = 0,
        o[10] = -2 * f,
        o[14] = -((s + i) * f),
        o[3] = 0,
        o[7] = 0,
        o[11] = 0,
        o[15] = 1,
        this
    },
    equals: function(e) {
        var t = this.elements;
        e = e.elements;
        for (var n = 0; 16 > n; n++) if (t[n] !== e[n]) return ! 1;
        return ! 0
    },
    fromArray: function(e) {
        return this.elements.set(e),
        this
    },
    toArray: function() {
        var e = this.elements;
        return [e[0], e[1], e[2], e[3], e[4], e[5], e[6], e[7], e[8], e[9], e[10], e[11], e[12], e[13], e[14], e[15]]
    }
},
THREE.Ray = function(e, t) {
    this.origin = void 0 !== e ? e: new THREE.Vector3,
    this.direction = void 0 !== t ? t: new THREE.Vector3
},
THREE.Ray.prototype = {
    constructor: THREE.Ray,
    set: function(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    },
    at: function(e, t) {
        return (t || new THREE.Vector3).copy(this.direction).multiplyScalar(e).add(this.origin)
    },
    lookAt: function(e) {
        this.direction.copy(e).sub(this.origin).normalize()
    },
    recast: function() {
        var e = new THREE.Vector3;
        return function(t) {
            return this.origin.copy(this.at(t, e)),
            this
        }
    } (),
    closestPointToPoint: function(e, t) {
        var n = t || new THREE.Vector3;
        n.subVectors(e, this.origin);
        var r = n.dot(this.direction);
        return 0 > r ? n.copy(this.origin) : n.copy(this.direction).multiplyScalar(r).add(this.origin)
    },
    distanceToPoint: function(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    },
    distanceSqToPoint: function() {
        var e = new THREE.Vector3;
        return function(t) {
            var n = e.subVectors(t, this.origin).dot(this.direction);
            return 0 > n ? this.origin.distanceToSquared(t) : (e.copy(this.direction).multiplyScalar(n).add(this.origin), e.distanceToSquared(t))
        }
    } (),
    distanceSqToSegment: function() {
        var e = new THREE.Vector3,
        t = new THREE.Vector3,
        n = new THREE.Vector3;
        return function(r, i, s, o) {
            e.copy(r).add(i).multiplyScalar(.5),
            t.copy(i).sub(r).normalize(),
            n.copy(this.origin).sub(e);
            var u = .5 * r.distanceTo(i),
            f = -this.direction.dot(t),
            l = n.dot(this.direction),
            h = -n.dot(t),
            p = n.lengthSq(),
            d = Math.abs(1 - f * f),
            v;
            return 0 < d ? (r = f * h - l, i = f * l - h, v = u * d, 0 <= r ? i >= -v ? i <= v ? (u = 1 / d, r *= u, i *= u, f = r * (r + f * i + 2 * l) + i * (f * r + i + 2 * h) + p) : (i = u, r = Math.max(0, -(f * i + l)), f = -r * r + i * (i + 2 * h) + p) : (i = -u, r = Math.max(0, -(f * i + l)), f = -r * r + i * (i + 2 * h) + p) : i <= -v ? (r = Math.max(0, -( - f * u + l)), i = 0 < r ? -u: Math.min(Math.max( - u, -h), u), f = -r * r + i * (i + 2 * h) + p) : i <= v ? (r = 0, i = Math.min(Math.max( - u, -h), u), f = i * (i + 2 * h) + p) : (r = Math.max(0, -(f * u + l)), i = 0 < r ? u: Math.min(Math.max( - u, -h), u), f = -r * r + i * (i + 2 * h) + p)) : (i = 0 < f ? -u: u, r = Math.max(0, -(f * i + l)), f = -r * r + i * (i + 2 * h) + p),
            s && s.copy(this.direction).multiplyScalar(r).add(this.origin),
            o && o.copy(t).multiplyScalar(i).add(e),
            f
        }
    } (),
    intersectSphere: function() {
        var e = new THREE.Vector3;
        return function(t, n) {
            e.subVectors(t.center, this.origin);
            var r = e.dot(this.direction),
            i = e.dot(e) - r * r,
            s = t.radius * t.radius;
            return i > s ? null: (s = Math.sqrt(s - i), i = r - s, r += s, 0 > i && 0 > r ? null: 0 > i ? this.at(r, n) : this.at(i, n))
        }
    } (),
    intersectsSphere: function(e) {
        return this.distanceToPoint(e.center) <= e.radius
    },
    distanceToPlane: function(e) {
        var t = e.normal.dot(this.direction);
        return 0 === t ? 0 === e.distanceToPoint(this.origin) ? 0 : null: (e = -(this.origin.dot(e.normal) + e.constant) / t, 0 <= e ? e: null)
    },
    intersectPlane: function(e, t) {
        var n = this.distanceToPlane(e);
        return null === n ? null: this.at(n, t)
    },
    intersectsPlane: function(e) {
        var t = e.distanceToPoint(this.origin);
        return 0 === t || 0 > e.normal.dot(this.direction) * t ? !0 : !1
    },
    intersectBox: function(e, t) {
        var n, r, i, s, o;
        r = 1 / this.direction.x,
        s = 1 / this.direction.y,
        o = 1 / this.direction.z;
        var u = this.origin;
        0 <= r ? (n = (e.min.x - u.x) * r, r *= e.max.x - u.x) : (n = (e.max.x - u.x) * r, r *= e.min.x - u.x),
        0 <= s ? (i = (e.min.y - u.y) * s, s *= e.max.y - u.y) : (i = (e.max.y - u.y) * s, s *= e.min.y - u.y);
        if (n > s || i > r) return null;
        if (i > n || n !== n) n = i;
        if (s < r || r !== r) r = s;
        0 <= o ? (i = (e.min.z - u.z) * o, o *= e.max.z - u.z) : (i = (e.max.z - u.z) * o, o *= e.min.z - u.z);
        if (n > o || i > r) return null;
        if (i > n || n !== n) n = i;
        if (o < r || r !== r) r = o;
        return 0 > r ? null: this.at(0 <= n ? n: r, t)
    },
    intersectsBox: function() {
        var e = new THREE.Vector3;
        return function(t) {
            return null !== this.intersectBox(t, e)
        }
    } (),
    intersectTriangle: function() {
        var e = new THREE.Vector3,
        t = new THREE.Vector3,
        n = new THREE.Vector3,
        r = new THREE.Vector3;
        return function(i, s, o, u, f) {
            t.subVectors(s, i),
            n.subVectors(o, i),
            r.crossVectors(t, n),
            s = this.direction.dot(r);
            if (0 < s) {
                if (u) return null;
                u = 1
            } else {
                if (! (0 > s)) return null;
                u = -1,
                s = -s
            }
            return e.subVectors(this.origin, i),
            i = u * this.direction.dot(n.crossVectors(e, n)),
            0 > i ? null: (o = u * this.direction.dot(t.cross(e)), 0 > o || i + o > s ? null: (i = -u * e.dot(r), 0 > i ? null: this.at(i / s, f)))
        }
    } (),
    applyMatrix4: function(e) {
        return this.direction.add(this.origin).applyMatrix4(e),
        this.origin.applyMatrix4(e),
        this.direction.sub(this.origin),
        this.direction.normalize(),
        this
    },
    equals: function(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
},
THREE.Sphere = function(e, t) {
    this.center = void 0 !== e ? e: new THREE.Vector3,
    this.radius = void 0 !== t ? t: 0
},
THREE.Sphere.prototype = {
    constructor: THREE.Sphere,
    set: function(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    },
    setFromPoints: function() {
        var e = new THREE.Box3;
        return function(t, n) {
            var r = this.center;
            void 0 !== n ? r.copy(n) : e.setFromPoints(t).center(r);
            for (var i = 0,
            s = 0,
            o = t.length; s < o; s++) i = Math.max(i, r.distanceToSquared(t[s]));
            return this.radius = Math.sqrt(i),
            this
        }
    } (),
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    },
    empty: function() {
        return 0 >= this.radius
    },
    containsPoint: function(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    },
    distanceToPoint: function(e) {
        return e.distanceTo(this.center) - this.radius
    },
    intersectsSphere: function(e) {
        var t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    },
    intersectsBox: function(e) {
        return e.intersectsSphere(this)
    },
    intersectsPlane: function(e) {
        return Math.abs(this.center.dot(e.normal) - e.constant) <= this.radius
    },
    clampPoint: function(e, t) {
        var n = this.center.distanceToSquared(e),
        r = t || new THREE.Vector3;
        return r.copy(e),
        n > this.radius * this.radius && (r.sub(this.center).normalize(), r.multiplyScalar(this.radius).add(this.center)),
        r
    },
    getBoundingBox: function(e) {
        return e = e || new THREE.Box3,
        e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e
    },
    applyMatrix4: function(e) {
        return this.center.applyMatrix4(e),
        this.radius *= e.getMaxScaleOnAxis(),
        this
    },
    translate: function(e) {
        return this.center.add(e),
        this
    },
    equals: function(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
},
THREE.Frustum = function(e, t, n, r, i, s) {
    this.planes = [void 0 !== e ? e: new THREE.Plane, void 0 !== t ? t: new THREE.Plane, void 0 !== n ? n: new THREE.Plane, void 0 !== r ? r: new THREE.Plane, void 0 !== i ? i: new THREE.Plane, void 0 !== s ? s: new THREE.Plane]
},
THREE.Frustum.prototype = {
    constructor: THREE.Frustum,
    set: function(e, t, n, r, i, s) {
        var o = this.planes;
        return o[0].copy(e),
        o[1].copy(t),
        o[2].copy(n),
        o[3].copy(r),
        o[4].copy(i),
        o[5].copy(s),
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(e) {
        for (var t = this.planes,
        n = 0; 6 > n; n++) t[n].copy(e.planes[n]);
        return this
    },
    setFromMatrix: function(e) {
        var t = this.planes,
        n = e.elements;
        e = n[0];
        var r = n[1],
        i = n[2],
        s = n[3],
        o = n[4],
        u = n[5],
        a = n[6],
        f = n[7],
        l = n[8],
        c = n[9],
        h = n[10],
        p = n[11],
        d = n[12],
        v = n[13],
        m = n[14],
        n = n[15];
        return t[0].setComponents(s - e, f - o, p - l, n - d).normalize(),
        t[1].setComponents(s + e, f + o, p + l, n + d).normalize(),
        t[2].setComponents(s + r, f + u, p + c, n + v).normalize(),
        t[3].setComponents(s - r, f - u, p - c, n - v).normalize(),
        t[4].setComponents(s - i, f - a, p - h, n - m).normalize(),
        t[5].setComponents(s + i, f + a, p + h, n + m).normalize(),
        this
    },
    intersectsObject: function() {
        var e = new THREE.Sphere;
        return function(t) {
            var n = t.geometry;
            return null === n.boundingSphere && n.computeBoundingSphere(),
            e.copy(n.boundingSphere),
            e.applyMatrix4(t.matrixWorld),
            this.intersectsSphere(e)
        }
    } (),
    intersectsSphere: function(e) {
        var t = this.planes,
        n = e.center;
        e = -e.radius;
        for (var r = 0; 6 > r; r++) if (t[r].distanceToPoint(n) < e) return ! 1;
        return ! 0
    },
    intersectsBox: function() {
        var e = new THREE.Vector3,
        t = new THREE.Vector3;
        return function(n) {
            for (var r = this.planes,
            i = 0; 6 > i; i++) {
                var s = r[i];
                e.x = 0 < s.normal.x ? n.min.x: n.max.x,
                t.x = 0 < s.normal.x ? n.max.x: n.min.x,
                e.y = 0 < s.normal.y ? n.min.y: n.max.y,
                t.y = 0 < s.normal.y ? n.max.y: n.min.y,
                e.z = 0 < s.normal.z ? n.min.z: n.max.z,
                t.z = 0 < s.normal.z ? n.max.z: n.min.z;
                var o = s.distanceToPoint(e),
                s = s.distanceToPoint(t);
                if (0 > o && 0 > s) return ! 1
            }
            return ! 0
        }
    } (),
    containsPoint: function(e) {
        for (var t = this.planes,
        n = 0; 6 > n; n++) if (0 > t[n].distanceToPoint(e)) return ! 1;
        return ! 0
    }
},
THREE.Plane = function(e, t) {
    this.normal = void 0 !== e ? e: new THREE.Vector3(1, 0, 0),
    this.constant = void 0 !== t ? t: 0
},
THREE.Plane.prototype = {
    constructor: THREE.Plane,
    set: function(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    },
    setComponents: function(e, t, n, r) {
        return this.normal.set(e, t, n),
        this.constant = r,
        this
    },
    setFromNormalAndCoplanarPoint: function(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    },
    setFromCoplanarPoints: function() {
        var e = new THREE.Vector3,
        t = new THREE.Vector3;
        return function(n, r, i) {
            return r = e.subVectors(i, r).cross(t.subVectors(n, r)).normalize(),
            this.setFromNormalAndCoplanarPoint(r, n),
            this
        }
    } (),
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    },
    normalize: function() {
        var e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    },
    negate: function() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    },
    distanceToPoint: function(e) {
        return this.normal.dot(e) + this.constant
    },
    distanceToSphere: function(e) {
        return this.distanceToPoint(e.center) - e.radius
    },
    projectPoint: function(e, t) {
        return this.orthoPoint(e, t).sub(e).negate()
    },
    orthoPoint: function(e, t) {
        var n = this.distanceToPoint(e);
        return (t || new THREE.Vector3).copy(this.normal).multiplyScalar(n)
    },
    intersectLine: function() {
        var e = new THREE.Vector3;
        return function(t, n) {
            var r = n || new THREE.Vector3,
            i = t.delta(e),
            s = this.normal.dot(i);
            if (0 !== s) return s = -(t.start.dot(this.normal) + this.constant) / s,
            0 > s || 1 < s ? void 0 : r.copy(i).multiplyScalar(s).add(t.start);
            if (0 === this.distanceToPoint(t.start)) return r.copy(t.start)
        }
    } (),
    intersectsLine: function(e) {
        var t = this.distanceToPoint(e.start);
        return e = this.distanceToPoint(e.end),
        0 > t && 0 < e || 0 > e && 0 < t
    },
    intersectsBox: function(e) {
        return e.intersectsPlane(this)
    },
    intersectsSphere: function(e) {
        return e.intersectsPlane(this)
    },
    coplanarPoint: function(e) {
        return (e || new THREE.Vector3).copy(this.normal).multiplyScalar( - this.constant)
    },
    applyMatrix4: function() {
        var e = new THREE.Vector3,
        t = new THREE.Vector3,
        n = new THREE.Matrix3;
        return function(r, i) {
            var s = i || n.getNormalMatrix(r),
            s = e.copy(this.normal).applyMatrix3(s),
            o = this.coplanarPoint(t);
            return o.applyMatrix4(r),
            this.setFromNormalAndCoplanarPoint(s, o),
            this
        }
    } (),
    translate: function(e) {
        return this.constant -= e.dot(this.normal),
        this
    },
    equals: function(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
},
THREE.Spherical = function(e, t, n) {
    return this.radius = void 0 !== e ? e: 1,
    this.phi = void 0 !== t ? t: 0,
    this.theta = void 0 !== n ? n: 0,
    this
},
THREE.Spherical.prototype = {
    constructor: THREE.Spherical,
    set: function(e, t, n) {
        this.radius = e,
        this.phi = t,
        this.theta = n
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(e) {
        return this.radius.copy(e.radius),
        this.phi.copy(e.phi),
        this.theta.copy(e.theta),
        this
    },
    makeSafe: function() {
        this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi))
    },
    setFromVector3: function(e) {
        return this.radius = e.length(),
        0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(e.x, e.z), this.phi = Math.acos(THREE.Math.clamp(e.y / this.radius, -1, 1))),
        this
    }
},
THREE.Math = {
    generateUUID: function() {
        var e = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),
        t = Array(36),
        n = 0,
        r;
        return function() {
            for (var i = 0; 36 > i; i++) 8 === i || 13 === i || 18 === i || 23 === i ? t[i] = "-": 14 === i ? t[i] = "4": (2 >= n && (n = 33554432 + 16777216 * Math.random() | 0), r = n & 15, n >>= 4, t[i] = e[19 === i ? r & 3 | 8 : r]);
            return t.join("")
        }
    } (),
    clamp: function(e, t, n) {
        return Math.max(t, Math.min(n, e))
    },
    euclideanModulo: function(e, t) {
        return (e % t + t) % t
    },
    mapLinear: function(e, t, n, r, i) {
        return r + (e - t) * (i - r) / (n - t)
    },
    smoothstep: function(e, t, n) {
        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * (3 - 2 * e))
    },
    smootherstep: function(e, t, n) {
        return e <= t ? 0 : e >= n ? 1 : (e = (e - t) / (n - t), e * e * e * (e * (6 * e - 15) + 10))
    },
    random16: function() {
        return console.warn("THREE.Math.random16() has been deprecated. Use Math.random() instead."),
        Math.random()
    },
    randInt: function(e, t) {
        return e + Math.floor(Math.random() * (t - e + 1))
    },
    randFloat: function(e, t) {
        return e + Math.random() * (t - e)
    },
    randFloatSpread: function(e) {
        return e * (.5 - Math.random())
    },
    degToRad: function() {
        var e = Math.PI / 180;
        return function(t) {
            return t * e
        }
    } (),
    radToDeg: function() {
        var e = 180 / Math.PI;
        return function(t) {
            return t * e
        }
    } (),
    isPowerOfTwo: function(e) {
        return 0 === (e & e - 1) && 0 !== e
    },
    nearestPowerOfTwo: function(e) {
        return Math.pow(2, Math.round(Math.log(e) / Math.LN2))
    },
    nextPowerOfTwo: function(e) {
        return e--,
        e |= e >> 1,
        e |= e >> 2,
        e |= e >> 4,
        e |= e >> 8,
        e |= e >> 16,
        e++,
        e
    }
},
THREE.Spline = function(e) {
    function t(e, t, n, r, i, s, o) {
        return e = .5 * (n - e),
        r = .5 * (r - t),
        (2 * (t - n) + e + r) * o + ( - 3 * (t - n) - 2 * e - r) * s + e * i + t
    }
    this.points = e;
    var n = [],
    r = {
        x: 0,
        y: 0,
        z: 0
    },
    i,
    s,
    o,
    u,
    a,
    f,
    l,
    c,
    h;
    this.initFromArray = function(e) {
        this.points = [];
        for (var t = 0; t < e.length; t++) this.points[t] = {
            x: e[t][0],
            y: e[t][1],
            z: e[t][2]
        }
    },
    this.getPoint = function(e) {
        return i = (this.points.length - 1) * e,
        s = Math.floor(i),
        o = i - s,
        n[0] = 0 === s ? s: s - 1,
        n[1] = s,
        n[2] = s > this.points.length - 2 ? this.points.length - 1 : s + 1,
        n[3] = s > this.points.length - 3 ? this.points.length - 1 : s + 2,
        f = this.points[n[0]],
        l = this.points[n[1]],
        c = this.points[n[2]],
        h = this.points[n[3]],
        u = o * o,
        a = o * u,
        r.x = t(f.x, l.x, c.x, h.x, o, u, a),
        r.y = t(f.y, l.y, c.y, h.y, o, u, a),
        r.z = t(f.z, l.z, c.z, h.z, o, u, a),
        r
    },
    this.getControlPointsArray = function() {
        var e, t, n = this.points.length,
        r = [];
        for (e = 0; e < n; e++) t = this.points[e],
        r[e] = [t.x, t.y, t.z];
        return r
    },
    this.getLength = function(e) {
        var t, n, r, i = t = t = 0,
        s = new THREE.Vector3,
        o = new THREE.Vector3,
        u = [],
        a = 0;
        u[0] = 0,
        e || (e = 100),
        n = this.points.length * e,
        s.copy(this.points[0]);
        for (e = 1; e < n; e++) t = e / n,
        r = this.getPoint(t),
        o.copy(r),
        a += o.distanceTo(s),
        s.copy(r),
        t *= this.points.length - 1,
        t = Math.floor(t),
        t !== i && (u[t] = a, i = t);
        return u[u.length] = a,
        {
            chunks: u,
            total: a
        }
    },
    this.reparametrizeByArcLength = function(e) {
        var t, n, r, i, s, o, u = [],
        a = new THREE.Vector3,
        f = this.getLength();
        u.push(a.copy(this.points[0]).clone());
        for (t = 1; t < this.points.length; t++) {
            n = f.chunks[t] - f.chunks[t - 1],
            o = Math.ceil(e * n / f.total),
            i = (t - 1) / (this.points.length - 1),
            s = t / (this.points.length - 1);
            for (n = 1; n < o - 1; n++) r = i + 1 / o * n * (s - i),
            r = this.getPoint(r),
            u.push(a.copy(r).clone());
            u.push(a.copy(this.points[t]).clone())
        }
        this.points = u
    }
},
THREE.Triangle = function(e, t, n) {
    this.a = void 0 !== e ? e: new THREE.Vector3,
    this.b = void 0 !== t ? t: new THREE.Vector3,
    this.c = void 0 !== n ? n: new THREE.Vector3
},
THREE.Triangle.normal = function() {
    var e = new THREE.Vector3;
    return function(t, n, r, i) {
        return i = i || new THREE.Vector3,
        i.subVectors(r, n),
        e.subVectors(t, n),
        i.cross(e),
        t = i.lengthSq(),
        0 < t ? i.multiplyScalar(1 / Math.sqrt(t)) : i.set(0, 0, 0)
    }
} (),
THREE.Triangle.barycoordFromPoint = function() {
    var e = new THREE.Vector3,
    t = new THREE.Vector3,
    n = new THREE.Vector3;
    return function(r, i, s, o, u) {
        e.subVectors(o, i),
        t.subVectors(s, i),
        n.subVectors(r, i),
        r = e.dot(e),
        i = e.dot(t),
        s = e.dot(n);
        var f = t.dot(t);
        o = t.dot(n);
        var l = r * f - i * i;
        return u = u || new THREE.Vector3,
        0 === l ? u.set( - 2, -1, -1) : (l = 1 / l, f = (f * s - i * o) * l, r = (r * o - i * s) * l, u.set(1 - f - r, r, f))
    }
} (),
THREE.Triangle.containsPoint = function() {
    var e = new THREE.Vector3;
    return function(t, n, r, i) {
        return t = THREE.Triangle.barycoordFromPoint(t, n, r, i, e),
        0 <= t.x && 0 <= t.y && 1 >= t.x + t.y
    }
} (),
THREE.Triangle.prototype = {
    constructor: THREE.Triangle,
    set: function(e, t, n) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(n),
        this
    },
    setFromPointsAndIndices: function(e, t, n, r) {
        return this.a.copy(e[t]),
        this.b.copy(e[n]),
        this.c.copy(e[r]),
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    },
    area: function() {
        var e = new THREE.Vector3,
        t = new THREE.Vector3;
        return function() {
            return e.subVectors(this.c, this.b),
            t.subVectors(this.a, this.b),
            .5 * e.cross(t).length()
        }
    } (),
    midpoint: function(e) {
        return (e || new THREE.Vector3).addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    },
    normal: function(e) {
        return THREE.Triangle.normal(this.a, this.b, this.c, e)
    },
    plane: function(e) {
        return (e || new THREE.Plane).setFromCoplanarPoints(this.a, this.b, this.c)
    },
    barycoordFromPoint: function(e, t) {
        return THREE.Triangle.barycoordFromPoint(e, this.a, this.b, this.c, t)
    },
    containsPoint: function(e) {
        return THREE.Triangle.containsPoint(e, this.a, this.b, this.c)
    },
    equals: function(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
},
THREE.Interpolant = function(e, t, n, r) {
    this.parameterPositions = e,
    this._cachedIndex = 0,
    this.resultBuffer = void 0 !== r ? r: new t.constructor(n),
    this.sampleValues = t,
    this.valueSize = n
},
THREE.Interpolant.prototype = {
    constructor: THREE.Interpolant,
    evaluate: function(e) {
        var t = this.parameterPositions,
        n = this._cachedIndex,
        r = t[n],
        i = t[n - 1];
        e: {
            t: {
                n: {
                    r: if (! (e < r)) {
                        for (var s = n + 2;;) {
                            if (void 0 === r) {
                                if (e < i) break r;
                                return this._cachedIndex = n = t.length,
                                this.afterEnd_(n - 1, e, i)
                            }
                            if (n === s) break;
                            i = r,
                            r = t[++n];
                            if (e < r) break t
                        }
                        r = t.length;
                        break n
                    }
                    if (e >= i) break e;
                    s = t[1],
                    e < s && (n = 2, i = s);
                    for (s = n - 2;;) {
                        if (void 0 === i) return this._cachedIndex = 0,
                        this.beforeStart_(0, e, r);
                        if (n === s) break;
                        r = i,
                        i = t[--n - 1];
                        if (e >= i) break t
                    }
                    r = n,
                    n = 0
                }
                for (; n < r;) i = n + r >>> 1,
                e < t[i] ? r = i: n = i + 1;
                r = t[n],
                i = t[n - 1];
                if (void 0 === i) return this._cachedIndex = 0,
                this.beforeStart_(0, e, r);
                if (void 0 === r) return this._cachedIndex = n = t.length,
                this.afterEnd_(n - 1, i, e)
            }
            this._cachedIndex = n,
            this.intervalChanged_(n, i, r)
        }
        return this.interpolate_(n, i, e, r)
    },
    settings: null,
    DefaultSettings_: {},
    getSettings_: function() {
        return this.settings || this.DefaultSettings_
    },
    copySampleValue_: function(e) {
        var t = this.resultBuffer,
        n = this.sampleValues,
        r = this.valueSize;
        e *= r;
        for (var i = 0; i !== r; ++i) t[i] = n[e + i];
        return t
    },
    interpolate_: function(e, t, n, r) {
        throw Error("call to abstract method")
    },
    intervalChanged_: function(e, t, n) {}
},
Object.assign(THREE.Interpolant.prototype, {
    beforeStart_: THREE.Interpolant.prototype.copySampleValue_,
    afterEnd_: THREE.Interpolant.prototype.copySampleValue_
}),
THREE.CubicInterpolant = function(e, t, n, r) {
    THREE.Interpolant.call(this, e, t, n, r),
    this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = 0
},
THREE.CubicInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
    constructor: THREE.CubicInterpolant,
    DefaultSettings_: {
        endingStart: THREE.ZeroCurvatureEnding,
        endingEnd: THREE.ZeroCurvatureEnding
    },
    intervalChanged_: function(e, t, n) {
        var r = this.parameterPositions,
        i = e - 2,
        s = e + 1,
        o = r[i],
        u = r[s];
        if (void 0 === o) switch (this.getSettings_().endingStart) {
        case THREE.ZeroSlopeEnding:
            i = e,
            o = 2 * t - n;
            break;
        case THREE.WrapAroundEnding:
            i = r.length - 2,
            o = t + r[i] - r[i + 1];
            break;
        default:
            i = e,
            o = n
        }
        if (void 0 === u) switch (this.getSettings_().endingEnd) {
        case THREE.ZeroSlopeEnding:
            s = e,
            u = 2 * n - t;
            break;
        case THREE.WrapAroundEnding:
            s = 1,
            u = n + r[1] - r[0];
            break;
        default:
            s = e - 1,
            u = t
        }
        e = .5 * (n - t),
        r = this.valueSize,
        this._weightPrev = e / (t - o),
        this._weightNext = e / (u - n),
        this._offsetPrev = i * r,
        this._offsetNext = s * r
    },
    interpolate_: function(e, t, n, r) {
        var i = this.resultBuffer,
        s = this.sampleValues,
        o = this.valueSize;
        e *= o;
        var u = e - o,
        a = this._offsetPrev,
        f = this._offsetNext,
        l = this._weightPrev,
        c = this._weightNext,
        h = (n - t) / (r - t);
        n = h * h,
        r = n * h,
        t = -l * r + 2 * l * n - l * h,
        l = (1 + l) * r + ( - 1.5 - 2 * l) * n + ( - 0.5 + l) * h + 1,
        h = ( - 1 - c) * r + (1.5 + c) * n + .5 * h,
        c = c * r - c * n;
        for (n = 0; n !== o; ++n) i[n] = t * s[a + n] + l * s[u + n] + h * s[e + n] + c * s[f + n];
        return i
    }
}),
THREE.DiscreteInterpolant = function(e, t, n, r) {
    THREE.Interpolant.call(this, e, t, n, r)
},
THREE.DiscreteInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
    constructor: THREE.DiscreteInterpolant,
    interpolate_: function(e, t, n, r) {
        return this.copySampleValue_(e - 1)
    }
}),
THREE.LinearInterpolant = function(e, t, n, r) {
    THREE.Interpolant.call(this, e, t, n, r)
},
THREE.LinearInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
    constructor: THREE.LinearInterpolant,
    interpolate_: function(e, t, n, r) {
        var i = this.resultBuffer,
        s = this.sampleValues,
        o = this.valueSize;
        e *= o;
        var u = e - o;
        t = (n - t) / (r - t),
        n = 1 - t;
        for (r = 0; r !== o; ++r) i[r] = s[u + r] * n + s[e + r] * t;
        return i
    }
}),
THREE.QuaternionLinearInterpolant = function(e, t, n, r) {
    THREE.Interpolant.call(this, e, t, n, r)
},
THREE.QuaternionLinearInterpolant.prototype = Object.assign(Object.create(THREE.Interpolant.prototype), {
    constructor: THREE.QuaternionLinearInterpolant,
    interpolate_: function(e, t, n, r) {
        var i = this.resultBuffer,
        s = this.sampleValues,
        o = this.valueSize;
        e *= o,
        t = (n - t) / (r - t);
        for (n = e + o; e !== n; e += 4) THREE.Quaternion.slerpFlat(i, 0, s, e - o, s, e, t);
        return i
    }
}),
THREE.Clock = function(e) {
    this.autoStart = void 0 !== e ? e: !0,
    this.elapsedTime = this.oldTime = this.startTime = 0,
    this.running = !1
},
THREE.Clock.prototype = {
    constructor: THREE.Clock,
    start: function() {
        this.oldTime = this.startTime = performance.now(),
        this.running = !0
    },
    stop: function() {
        this.getElapsedTime(),
        this.running = !1
    },
    getElapsedTime: function() {
        return this.getDelta(),
        this.elapsedTime
    },
    getDelta: function() {
        var e = 0;
        this.autoStart && !this.running && this.start();
        if (this.running) {
            var t = performance.now(),
            e = .001 * (t - this.oldTime);
            this.oldTime = t,
            this.elapsedTime += e
        }
        return e
    }
},
THREE.EventDispatcher = function() {},
THREE.EventDispatcher.prototype = {
    constructor: THREE.EventDispatcher,
    apply: function(e) {
        e.addEventListener = THREE.EventDispatcher.prototype.addEventListener,
        e.hasEventListener = THREE.EventDispatcher.prototype.hasEventListener,
        e.removeEventListener = THREE.EventDispatcher.prototype.removeEventListener,
        e.dispatchEvent = THREE.EventDispatcher.prototype.dispatchEvent
    },
    addEventListener: function(e, t) {
        void 0 === this._listeners && (this._listeners = {});
        var n = this._listeners;
        void 0 === n[e] && (n[e] = []),
        -1 === n[e].indexOf(t) && n[e].push(t)
    },
    hasEventListener: function(e, t) {
        if (void 0 === this._listeners) return ! 1;
        var n = this._listeners;
        return void 0 !== n[e] && -1 !== n[e].indexOf(t) ? !0 : !1
    },
    removeEventListener: function(e, t) {
        if (void 0 !== this._listeners) {
            var n = this._listeners[e];
            if (void 0 !== n) {
                var r = n.indexOf(t); - 1 !== r && n.splice(r, 1)
            }
        }
    },
    dispatchEvent: function(e) {
        if (void 0 !== this._listeners) {
            var t = this._listeners[e.type];
            if (void 0 !== t) {
                e.target = this;
                for (var n = [], r = t.length, i = 0; i < r; i++) n[i] = t[i];
                for (i = 0; i < r; i++) n[i].call(this, e)
            }
        }
    }
},
THREE.Layers = function() {
    this.mask = 1
},
THREE.Layers.prototype = {
    constructor: THREE.Layers,
    set: function(e) {
        this.mask = 1 << e
    },
    enable: function(e) {
        this.mask |= 1 << e
    },
    toggle: function(e) {
        this.mask ^= 1 << e
    },
    disable: function(e) {
        this.mask &= ~ (1 << e)
    },
    test: function(e) {
        return 0 !== (this.mask & e.mask)
    }
},
function(e) {
    function t(e, t) {
        return e.distance - t.distance
    }
    function n(e, t, r, i) {
        if (!1 !== e.visible && (e.raycast(t, r), !0 === i)) {
            e = e.children,
            i = 0;
            for (var s = e.length; i < s; i++) n(e[i], t, r, !0)
        }
    }
    e.Raycaster = function(t, n, r, i) {
        this.ray = new e.Ray(t, n),
        this.near = r || 0,
        this.far = i || Infinity,
        this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        },
        Object.defineProperties(this.params, {
            PointCloud: {
                get: function() {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."),
                    this.Points
                }
            }
        })
    },
    e.Raycaster.prototype = {
        constructor: e.Raycaster,
        linePrecision: 1,
        set: function(e, t) {
            this.ray.set(e, t)
        },
        setFromCamera: function(t, n) {
            n instanceof e.PerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(n.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(n).sub(this.ray.origin).normalize()) : n instanceof e.OrthographicCamera ? (this.ray.origin.set(t.x, t.y, -1).unproject(n), this.ray.direction.set(0, 0, -1).transformDirection(n.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        },
        intersectObject: function(e, r) {
            var i = [];
            return n(e, this, i, r),
            i.sort(t),
            i
        },
        intersectObjects: function(e, r) {
            var i = [];
            if (!1 === Array.isArray(e)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."),
            i;
            for (var s = 0,
            o = e.length; s < o; s++) n(e[s], this, i, r);
            return i.sort(t),
            i
        }
    }
} (THREE),
THREE.Object3D = function() {
    Object.defineProperty(this, "id", {
        value: THREE.Object3DIdCount++
    }),
    this.uuid = THREE.Math.generateUUID(),
    this.name = "",
    this.type = "Object3D",
    this.parent = null,
    this.children = [],
    this.up = THREE.Object3D.DefaultUp.clone();
    var e = new THREE.Vector3,
    t = new THREE.Euler,
    n = new THREE.Quaternion,
    r = new THREE.Vector3(1, 1, 1);
    t.onChange(function() {
        n.setFromEuler(t, !1)
    }),
    n.onChange(function() {
        t.setFromQuaternion(n, void 0, !1)
    }),
    Object.defineProperties(this, {
        position: {
            enumerable: !0,
            value: e
        },
        rotation: {
            enumerable: !0,
            value: t
        },
        quaternion: {
            enumerable: !0,
            value: n
        },
        scale: {
            enumerable: !0,
            value: r
        },
        modelViewMatrix: {
            value: new THREE.Matrix4
        },
        normalMatrix: {
            value: new THREE.Matrix3
        }
    }),
    this.rotationAutoUpdate = !0,
    this.matrix = new THREE.Matrix4,
    this.matrixWorld = new THREE.Matrix4,
    this.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate,
    this.matrixWorldNeedsUpdate = !1,
    this.layers = new THREE.Layers,
    this.visible = !0,
    this.receiveShadow = this.castShadow = !1,
    this.frustumCulled = !0,
    this.renderOrder = 0,
    this.userData = {}
},
THREE.Object3D.DefaultUp = new THREE.Vector3(0, 1, 0),
THREE.Object3D.DefaultMatrixAutoUpdate = !0,
THREE.Object3D.prototype = {
    constructor: THREE.Object3D,
    applyMatrix: function(e) {
        this.matrix.multiplyMatrices(e, this.matrix),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    },
    setRotationFromAxisAngle: function(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    },
    setRotationFromEuler: function(e) {
        this.quaternion.setFromEuler(e, !0)
    },
    setRotationFromMatrix: function(e) {
        this.quaternion.setFromRotationMatrix(e)
    },
    setRotationFromQuaternion: function(e) {
        this.quaternion.copy(e)
    },
    rotateOnAxis: function() {
        var e = new THREE.Quaternion;
        return function(t, n) {
            return e.setFromAxisAngle(t, n),
            this.quaternion.multiply(e),
            this
        }
    } (),
    rotateX: function() {
        var e = new THREE.Vector3(1, 0, 0);
        return function(t) {
            return this.rotateOnAxis(e, t)
        }
    } (),
    rotateY: function() {
        var e = new THREE.Vector3(0, 1, 0);
        return function(t) {
            return this.rotateOnAxis(e, t)
        }
    } (),
    rotateZ: function() {
        var e = new THREE.Vector3(0, 0, 1);
        return function(t) {
            return this.rotateOnAxis(e, t)
        }
    } (),
    translateOnAxis: function() {
        var e = new THREE.Vector3;
        return function(t, n) {
            return e.copy(t).applyQuaternion(this.quaternion),
            this.position.add(e.multiplyScalar(n)),
            this
        }
    } (),
    translateX: function() {
        var e = new THREE.Vector3(1, 0, 0);
        return function(t) {
            return this.translateOnAxis(e, t)
        }
    } (),
    translateY: function() {
        var e = new THREE.Vector3(0, 1, 0);
        return function(t) {
            return this.translateOnAxis(e, t)
        }
    } (),
    translateZ: function() {
        var e = new THREE.Vector3(0, 0, 1);
        return function(t) {
            return this.translateOnAxis(e, t)
        }
    } (),
    localToWorld: function(e) {
        return e.applyMatrix4(this.matrixWorld)
    },
    worldToLocal: function() {
        var e = new THREE.Matrix4;
        return function(t) {
            return t.applyMatrix4(e.getInverse(this.matrixWorld))
        }
    } (),
    lookAt: function() {
        var e = new THREE.Matrix4;
        return function(t) {
            e.lookAt(t, this.position, this.up),
            this.quaternion.setFromRotationMatrix(e)
        }
    } (),
    add: function(e) {
        if (1 < arguments.length) {
            for (var t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e instanceof THREE.Object3D ? (null !== e.parent && e.parent.remove(e), e.parent = this, e.dispatchEvent({
            type: "added"
        }), this.children.push(e)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
    },
    remove: function(e) {
        if (1 < arguments.length) for (var t = 0; t < arguments.length; t++) this.remove(arguments[t]);
        t = this.children.indexOf(e),
        -1 !== t && (e.parent = null, e.dispatchEvent({
            type: "removed"
        }), this.children.splice(t, 1))
    },
    getObjectById: function(e) {
        return this.getObjectByProperty("id", e)
    },
    getObjectByName: function(e) {
        return this.getObjectByProperty("name", e)
    },
    getObjectByProperty: function(e, t) {
        if (this[e] === t) return this;
        for (var n = 0,
        r = this.children.length; n < r; n++) {
            var i = this.children[n].getObjectByProperty(e, t);
            if (void 0 !== i) return i
        }
    },
    getWorldPosition: function(e) {
        return e = e || new THREE.Vector3,
        this.updateMatrixWorld(!0),
        e.setFromMatrixPosition(this.matrixWorld)
    },
    getWorldQuaternion: function() {
        var e = new THREE.Vector3,
        t = new THREE.Vector3;
        return function(n) {
            return n = n || new THREE.Quaternion,
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(e, n, t),
            n
        }
    } (),
    getWorldRotation: function() {
        var e = new THREE.Quaternion;
        return function(t) {
            return t = t || new THREE.Euler,
            this.getWorldQuaternion(e),
            t.setFromQuaternion(e, this.rotation.order, !1)
        }
    } (),
    getWorldScale: function() {
        var e = new THREE.Vector3,
        t = new THREE.Quaternion;
        return function(n) {
            return n = n || new THREE.Vector3,
            this.updateMatrixWorld(!0),
            this.matrixWorld.decompose(e, t, n),
            n
        }
    } (),
    getWorldDirection: function() {
        var e = new THREE.Quaternion;
        return function(t) {
            return t = t || new THREE.Vector3,
            this.getWorldQuaternion(e),
            t.set(0, 0, 1).applyQuaternion(e)
        }
    } (),
    raycast: function() {},
    traverse: function(e) {
        e(this);
        for (var t = this.children,
        n = 0,
        r = t.length; n < r; n++) t[n].traverse(e)
    },
    traverseVisible: function(e) {
        if (!1 !== this.visible) {
            e(this);
            for (var t = this.children,
            n = 0,
            r = t.length; n < r; n++) t[n].traverseVisible(e)
        }
    },
    traverseAncestors: function(e) {
        var t = this.parent;
        null !== t && (e(t), t.traverseAncestors(e))
    },
    updateMatrix: function() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    },
    updateMatrixWorld: function(e) { ! 0 === this.matrixAutoUpdate && this.updateMatrix();
        if (!0 === this.matrixWorldNeedsUpdate || !0 === e) null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        this.matrixWorldNeedsUpdate = !1,
        e = !0;
        for (var t = 0,
        n = this.children.length; t < n; t++) this.children[t].updateMatrixWorld(e)
    },
    toJSON: function(e) {
        function t(e) {
            var t = [],
            n;
            for (n in e) {
                var r = e[n];
                delete r.metadata,
                t.push(r)
            }
            return t
        }
        var n = void 0 === e,
        r = {};
        n && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {}
        },
        r.metadata = {
            version: 4.4,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        var i = {};
        i.uuid = this.uuid,
        i.type = this.type,
        "" !== this.name && (i.name = this.name),
        "{}" !== JSON.stringify(this.userData) && (i.userData = this.userData),
        !0 === this.castShadow && (i.castShadow = !0),
        !0 === this.receiveShadow && (i.receiveShadow = !0),
        !1 === this.visible && (i.visible = !1),
        i.matrix = this.matrix.toArray(),
        void 0 !== this.geometry && (void 0 === e.geometries[this.geometry.uuid] && (e.geometries[this.geometry.uuid] = this.geometry.toJSON(e)), i.geometry = this.geometry.uuid),
        void 0 !== this.material && (void 0 === e.materials[this.material.uuid] && (e.materials[this.material.uuid] = this.material.toJSON(e)), i.material = this.material.uuid);
        if (0 < this.children.length) {
            i.children = [];
            for (var s = 0; s < this.children.length; s++) i.children.push(this.children[s].toJSON(e).object)
        }
        if (n) {
            var n = t(e.geometries),
            s = t(e.materials),
            o = t(e.textures);
            e = t(e.images),
            0 < n.length && (r.geometries = n),
            0 < s.length && (r.materials = s),
            0 < o.length && (r.textures = o),
            0 < e.length && (r.images = e)
        }
        return r.object = i,
        r
    },
    clone: function(e) {
        return (new this.constructor).copy(this, e)
    },
    copy: function(e, t) {
        void 0 === t && (t = !0),
        this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.rotationAutoUpdate = e.rotationAutoUpdate,
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.userData = JSON.parse(JSON.stringify(e.userData));
        if (!0 === t) for (var n = 0; n < e.children.length; n++) this.add(e.children[n].clone());
        return this
    }
},
THREE.EventDispatcher.prototype.apply(THREE.Object3D.prototype),
THREE.Object3DIdCount = 0,
THREE.Face3 = function(e, t, n, r, i, s) {
    this.a = e,
    this.b = t,
    this.c = n,
    this.normal = r instanceof THREE.Vector3 ? r: new THREE.Vector3,
    this.vertexNormals = Array.isArray(r) ? r: [],
    this.color = i instanceof THREE.Color ? i: new THREE.Color,
    this.vertexColors = Array.isArray(i) ? i: [],
    this.materialIndex = void 0 !== s ? s: 0
},
THREE.Face3.prototype = {
    constructor: THREE.Face3,
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(e) {
        this.a = e.a,
        this.b = e.b,
        this.c = e.c,
        this.normal.copy(e.normal),
        this.color.copy(e.color),
        this.materialIndex = e.materialIndex;
        for (var t = 0,
        n = e.vertexNormals.length; t < n; t++) this.vertexNormals[t] = e.vertexNormals[t].clone();
        t = 0;
        for (n = e.vertexColors.length; t < n; t++) this.vertexColors[t] = e.vertexColors[t].clone();
        return this
    }
},
THREE.BufferAttribute = function(e, t) {
    this.uuid = THREE.Math.generateUUID(),
    this.array = e,
    this.itemSize = t,
    this.dynamic = !1,
    this.updateRange = {
        offset: 0,
        count: -1
    },
    this.version = 0
},
THREE.BufferAttribute.prototype = {
    constructor: THREE.BufferAttribute,
    get count() {
        return this.array.length / this.itemSize
    },
    set needsUpdate(e) { ! 0 === e && this.version++
    },
    setDynamic: function(e) {
        return this.dynamic = e,
        this
    },
    copy: function(e) {
        return this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.dynamic = e.dynamic,
        this
    },
    copyAt: function(e, t, n) {
        e *= this.itemSize,
        n *= t.itemSize;
        for (var r = 0,
        i = this.itemSize; r < i; r++) this.array[e + r] = t.array[n + r];
        return this
    },
    copyArray: function(e) {
        return this.array.set(e),
        this
    },
    copyColorsArray: function(e) {
        for (var t = this.array,
        n = 0,
        r = 0,
        i = e.length; r < i; r++) {
            var s = e[r];
            void 0 === s && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", r), s = new THREE.Color),
            t[n++] = s.r,
            t[n++] = s.g,
            t[n++] = s.b
        }
        return this
    },
    copyIndicesArray: function(e) {
        for (var t = this.array,
        n = 0,
        r = 0,
        i = e.length; r < i; r++) {
            var s = e[r];
            t[n++] = s.a,
            t[n++] = s.b,
            t[n++] = s.c
        }
        return this
    },
    copyVector2sArray: function(e) {
        for (var t = this.array,
        n = 0,
        r = 0,
        i = e.length; r < i; r++) {
            var s = e[r];
            void 0 === s && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), s = new THREE.Vector2),
            t[n++] = s.x,
            t[n++] = s.y
        }
        return this
    },
    copyVector3sArray: function(e) {
        for (var t = this.array,
        n = 0,
        r = 0,
        i = e.length; r < i; r++) {
            var s = e[r];
            void 0 === s && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", r), s = new THREE.Vector3),
            t[n++] = s.x,
            t[n++] = s.y,
            t[n++] = s.z
        }
        return this
    },
    copyVector4sArray: function(e) {
        for (var t = this.array,
        n = 0,
        r = 0,
        i = e.length; r < i; r++) {
            var s = e[r];
            void 0 === s && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", r), s = new THREE.Vector4),
            t[n++] = s.x,
            t[n++] = s.y,
            t[n++] = s.z,
            t[n++] = s.w
        }
        return this
    },
    set: function(e, t) {
        return void 0 === t && (t = 0),
        this.array.set(e, t),
        this
    },
    getX: function(e) {
        return this.array[e * this.itemSize]
    },
    setX: function(e, t) {
        return this.array[e * this.itemSize] = t,
        this
    },
    getY: function(e) {
        return this.array[e * this.itemSize + 1]
    },
    setY: function(e, t) {
        return this.array[e * this.itemSize + 1] = t,
        this
    },
    getZ: function(e) {
        return this.array[e * this.itemSize + 2]
    },
    setZ: function(e, t) {
        return this.array[e * this.itemSize + 2] = t,
        this
    },
    getW: function(e) {
        return this.array[e * this.itemSize + 3]
    },
    setW: function(e, t) {
        return this.array[e * this.itemSize + 3] = t,
        this
    },
    setXY: function(e, t, n) {
        return e *= this.itemSize,
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this
    },
    setXYZ: function(e, t, n, r) {
        return e *= this.itemSize,
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = r,
        this
    },
    setXYZW: function(e, t, n, r, i) {
        return e *= this.itemSize,
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = r,
        this.array[e + 3] = i,
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    }
},
THREE.Int8Attribute = function(e, t) {
    return new THREE.BufferAttribute(new Int8Array(e), t)
},
THREE.Uint8Attribute = function(e, t) {
    return new THREE.BufferAttribute(new Uint8Array(e), t)
},
THREE.Uint8ClampedAttribute = function(e, t) {
    return new THREE.BufferAttribute(new Uint8ClampedArray(e), t)
},
THREE.Int16Attribute = function(e, t) {
    return new THREE.BufferAttribute(new Int16Array(e), t)
},
THREE.Uint16Attribute = function(e, t) {
    return new THREE.BufferAttribute(new Uint16Array(e), t)
},
THREE.Int32Attribute = function(e, t) {
    return new THREE.BufferAttribute(new Int32Array(e), t)
},
THREE.Uint32Attribute = function(e, t) {
    return new THREE.BufferAttribute(new Uint32Array(e), t)
},
THREE.Float32Attribute = function(e, t) {
    return new THREE.BufferAttribute(new Float32Array(e), t)
},
THREE.Float64Attribute = function(e, t) {
    return new THREE.BufferAttribute(new Float64Array(e), t)
},
THREE.DynamicBufferAttribute = function(e, t) {
    return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."),
    (new THREE.BufferAttribute(e, t)).setDynamic(!0)
},
THREE.InstancedBufferAttribute = function(e, t, n) {
    THREE.BufferAttribute.call(this, e, t),
    this.meshPerAttribute = n || 1
},
THREE.InstancedBufferAttribute.prototype = Object.create(THREE.BufferAttribute.prototype),
THREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute,
THREE.InstancedBufferAttribute.prototype.copy = function(e) {
    return THREE.BufferAttribute.prototype.copy.call(this, e),
    this.meshPerAttribute = e.meshPerAttribute,
    this
},
THREE.InterleavedBuffer = function(e, t) {
    this.uuid = THREE.Math.generateUUID(),
    this.array = e,
    this.stride = t,
    this.dynamic = !1,
    this.updateRange = {
        offset: 0,
        count: -1
    },
    this.version = 0
},
THREE.InterleavedBuffer.prototype = {
    constructor: THREE.InterleavedBuffer,
    get length() {
        return this.array.length
    },
    get count() {
        return this.array.length / this.stride
    },
    set needsUpdate(e) { ! 0 === e && this.version++
    },
    setDynamic: function(e) {
        return this.dynamic = e,
        this
    },
    copy: function(e) {
        return this.array = new e.array.constructor(e.array),
        this.stride = e.stride,
        this.dynamic = e.dynamic,
        this
    },
    copyAt: function(e, t, n) {
        e *= this.stride,
        n *= t.stride;
        for (var r = 0,
        i = this.stride; r < i; r++) this.array[e + r] = t.array[n + r];
        return this
    },
    set: function(e, t) {
        return void 0 === t && (t = 0),
        this.array.set(e, t),
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    }
},
THREE.InstancedInterleavedBuffer = function(e, t, n) {
    THREE.InterleavedBuffer.call(this, e, t),
    this.meshPerAttribute = n || 1
},
THREE.InstancedInterleavedBuffer.prototype = Object.create(THREE.InterleavedBuffer.prototype),
THREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer,
THREE.InstancedInterleavedBuffer.prototype.copy = function(e) {
    return THREE.InterleavedBuffer.prototype.copy.call(this, e),
    this.meshPerAttribute = e.meshPerAttribute,
    this
},
THREE.InterleavedBufferAttribute = function(e, t, n) {
    this.uuid = THREE.Math.generateUUID(),
    this.data = e,
    this.itemSize = t,
    this.offset = n
},
THREE.InterleavedBufferAttribute.prototype = {
    constructor: THREE.InterleavedBufferAttribute,
    get length() {
        return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."),
        this.array.length
    },
    get count() {
        return this.data.count
    },
    setX: function(e, t) {
        return this.data.array[e * this.data.stride + this.offset] = t,
        this
    },
    setY: function(e, t) {
        return this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    },
    setZ: function(e, t) {
        return this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    },
    setW: function(e, t) {
        return this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    },
    getX: function(e) {
        return this.data.array[e * this.data.stride + this.offset]
    },
    getY: function(e) {
        return this.data.array[e * this.data.stride + this.offset + 1]
    },
    getZ: function(e) {
        return this.data.array[e * this.data.stride + this.offset + 2]
    },
    getW: function(e) {
        return this.data.array[e * this.data.stride + this.offset + 3]
    },
    setXY: function(e, t, n) {
        return e = e * this.data.stride + this.offset,
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this
    },
    setXYZ: function(e, t, n, r) {
        return e = e * this.data.stride + this.offset,
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = r,
        this
    },
    setXYZW: function(e, t, n, r, i) {
        return e = e * this.data.stride + this.offset,
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = r,
        this.data.array[e + 3] = i,
        this
    }
},
THREE.Geometry = function() {
    Object.defineProperty(this, "id", {
        value: THREE.GeometryIdCount++
    }),
    this.uuid = THREE.Math.generateUUID(),
    this.name = "",
    this.type = "Geometry",
    this.vertices = [],
    this.colors = [],
    this.faces = [],
    this.faceVertexUvs = [[]],
    this.morphTargets = [],
    this.morphNormals = [],
    this.skinWeights = [],
    this.skinIndices = [],
    this.lineDistances = [],
    this.boundingSphere = this.boundingBox = null,
    this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.elementsNeedUpdate = this.verticesNeedUpdate = !1
},
THREE.Geometry.prototype = {
    constructor: THREE.Geometry,
    applyMatrix: function(e) {
        for (var t = (new THREE.Matrix3).getNormalMatrix(e), n = 0, r = this.vertices.length; n < r; n++) this.vertices[n].applyMatrix4(e);
        n = 0;
        for (r = this.faces.length; n < r; n++) {
            e = this.faces[n],
            e.normal.applyMatrix3(t).normalize();
            for (var i = 0,
            s = e.vertexNormals.length; i < s; i++) e.vertexNormals[i].applyMatrix3(t).normalize()
        }
        return null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this.normalsNeedUpdate = this.verticesNeedUpdate = !0,
        this
    },
    rotateX: function() {
        var e;
        return function(t) {
            return void 0 === e && (e = new THREE.Matrix4),
            e.makeRotationX(t),
            this.applyMatrix(e),
            this
        }
    } (),
    rotateY: function() {
        var e;
        return function(t) {
            return void 0 === e && (e = new THREE.Matrix4),
            e.makeRotationY(t),
            this.applyMatrix(e),
            this
        }
    } (),
    rotateZ: function() {
        var e;
        return function(t) {
            return void 0 === e && (e = new THREE.Matrix4),
            e.makeRotationZ(t),
            this.applyMatrix(e),
            this
        }
    } (),
    translate: function() {
        var e;
        return function(t, n, r) {
            return void 0 === e && (e = new THREE.Matrix4),
            e.makeTranslation(t, n, r),
            this.applyMatrix(e),
            this
        }
    } (),
    scale: function() {
        var e;
        return function(t, n, r) {
            return void 0 === e && (e = new THREE.Matrix4),
            e.makeScale(t, n, r),
            this.applyMatrix(e),
            this
        }
    } (),
    lookAt: function() {
        var e;
        return function(t) {
            void 0 === e && (e = new THREE.Object3D),
            e.lookAt(t),
            e.updateMatrix(),
            this.applyMatrix(e.matrix)
        }
    } (),
    fromBufferGeometry: function(e) {
        function t(e, t, r, i) {
            var s = void 0 !== o ? [l[e].clone(), l[t].clone(), l[r].clone()] : [],
            p = void 0 !== u ? [n.colors[e].clone(), n.colors[t].clone(), n.colors[r].clone()] : [];
            i = new THREE.Face3(e, t, r, s, p, i),
            n.faces.push(i),
            void 0 !== a && n.faceVertexUvs[0].push([c[e].clone(), c[t].clone(), c[r].clone()]),
            void 0 !== f && n.faceVertexUvs[1].push([h[e].clone(), h[t].clone(), h[r].clone()])
        }
        var n = this,
        r = null !== e.index ? e.index.array: void 0,
        i = e.attributes,
        s = i.position.array,
        o = void 0 !== i.normal ? i.normal.array: void 0,
        u = void 0 !== i.color ? i.color.array: void 0,
        a = void 0 !== i.uv ? i.uv.array: void 0,
        f = void 0 !== i.uv2 ? i.uv2.array: void 0;
        void 0 !== f && (this.faceVertexUvs[1] = []);
        for (var l = [], c = [], h = [], p = i = 0; i < s.length; i += 3, p += 2) n.vertices.push(new THREE.Vector3(s[i], s[i + 1], s[i + 2])),
        void 0 !== o && l.push(new THREE.Vector3(o[i], o[i + 1], o[i + 2])),
        void 0 !== u && n.colors.push(new THREE.Color(u[i], u[i + 1], u[i + 2])),
        void 0 !== a && c.push(new THREE.Vector2(a[p], a[p + 1])),
        void 0 !== f && h.push(new THREE.Vector2(f[p], f[p + 1]));
        if (void 0 !== r) if (s = e.groups, 0 < s.length) for (i = 0; i < s.length; i++) for (var d = s[i], v = d.start, m = d.count, p = v, v = v + m; p < v; p += 3) t(r[p], r[p + 1], r[p + 2], d.materialIndex);
        else for (i = 0; i < r.length; i += 3) t(r[i], r[i + 1], r[i + 2]);
        else for (i = 0; i < s.length / 3; i += 3) t(i, i + 1, i + 2);
        return this.computeFaceNormals(),
        null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
        this
    },
    center: function() {
        this.computeBoundingBox();
        var e = this.boundingBox.center().negate();
        return this.translate(e.x, e.y, e.z),
        e
    },
    normalize: function() {
        this.computeBoundingSphere();
        var e = this.boundingSphere.center,
        t = this.boundingSphere.radius,
        t = 0 === t ? 1 : 1 / t,
        n = new THREE.Matrix4;
        return n.set(t, 0, 0, -t * e.x, 0, t, 0, -t * e.y, 0, 0, t, -t * e.z, 0, 0, 0, 1),
        this.applyMatrix(n),
        this
    },
    computeFaceNormals: function() {
        for (var e = new THREE.Vector3,
        t = new THREE.Vector3,
        n = 0,
        r = this.faces.length; n < r; n++) {
            var i = this.faces[n],
            s = this.vertices[i.a],
            o = this.vertices[i.b];
            e.subVectors(this.vertices[i.c], o),
            t.subVectors(s, o),
            e.cross(t),
            e.normalize(),
            i.normal.copy(e)
        }
    },
    computeVertexNormals: function(e) {
        void 0 === e && (e = !0);
        var t, n, r;
        r = Array(this.vertices.length),
        t = 0;
        for (n = this.vertices.length; t < n; t++) r[t] = new THREE.Vector3;
        if (e) {
            var i, s, o, u = new THREE.Vector3,
            a = new THREE.Vector3;
            e = 0;
            for (t = this.faces.length; e < t; e++) n = this.faces[e],
            i = this.vertices[n.a],
            s = this.vertices[n.b],
            o = this.vertices[n.c],
            u.subVectors(o, s),
            a.subVectors(i, s),
            u.cross(a),
            r[n.a].add(u),
            r[n.b].add(u),
            r[n.c].add(u)
        } else for (e = 0, t = this.faces.length; e < t; e++) n = this.faces[e],
        r[n.a].add(n.normal),
        r[n.b].add(n.normal),
        r[n.c].add(n.normal);
        t = 0;
        for (n = this.vertices.length; t < n; t++) r[t].normalize();
        e = 0;
        for (t = this.faces.length; e < t; e++) n = this.faces[e],
        i = n.vertexNormals,
        3 === i.length ? (i[0].copy(r[n.a]), i[1].copy(r[n.b]), i[2].copy(r[n.c])) : (i[0] = r[n.a].clone(), i[1] = r[n.b].clone(), i[2] = r[n.c].clone());
        0 < this.faces.length && (this.normalsNeedUpdate = !0)
    },
    computeMorphNormals: function() {
        var e, t, n, r, i;
        n = 0;
        for (r = this.faces.length; n < r; n++) for (i = this.faces[n], i.__originalFaceNormal ? i.__originalFaceNormal.copy(i.normal) : i.__originalFaceNormal = i.normal.clone(), i.__originalVertexNormals || (i.__originalVertexNormals = []), e = 0, t = i.vertexNormals.length; e < t; e++) i.__originalVertexNormals[e] ? i.__originalVertexNormals[e].copy(i.vertexNormals[e]) : i.__originalVertexNormals[e] = i.vertexNormals[e].clone();
        var s = new THREE.Geometry;
        s.faces = this.faces,
        e = 0;
        for (t = this.morphTargets.length; e < t; e++) {
            if (!this.morphNormals[e]) {
                this.morphNormals[e] = {},
                this.morphNormals[e].faceNormals = [],
                this.morphNormals[e].vertexNormals = [],
                i = this.morphNormals[e].faceNormals;
                var o = this.morphNormals[e].vertexNormals,
                u,
                a;
                n = 0;
                for (r = this.faces.length; n < r; n++) u = new THREE.Vector3,
                a = {
                    a: new THREE.Vector3,
                    b: new THREE.Vector3,
                    c: new THREE.Vector3
                },
                i.push(u),
                o.push(a)
            }
            o = this.morphNormals[e],
            s.vertices = this.morphTargets[e].vertices,
            s.computeFaceNormals(),
            s.computeVertexNormals(),
            n = 0;
            for (r = this.faces.length; n < r; n++) i = this.faces[n],
            u = o.faceNormals[n],
            a = o.vertexNormals[n],
            u.copy(i.normal),
            a.a.copy(i.vertexNormals[0]),
            a.b.copy(i.vertexNormals[1]),
            a.c.copy(i.vertexNormals[2])
        }
        n = 0;
        for (r = this.faces.length; n < r; n++) i = this.faces[n],
        i.normal = i.__originalFaceNormal,
        i.vertexNormals = i.__originalVertexNormals
    },
    computeTangents: function() {
        console.warn("THREE.Geometry: .computeTangents() has been removed.")
    },
    computeLineDistances: function() {
        for (var e = 0,
        t = this.vertices,
        n = 0,
        r = t.length; n < r; n++) 0 < n && (e += t[n].distanceTo(t[n - 1])),
        this.lineDistances[n] = e
    },
    computeBoundingBox: function() {
        null === this.boundingBox && (this.boundingBox = new THREE.Box3),
        this.boundingBox.setFromPoints(this.vertices)
    },
    computeBoundingSphere: function() {
        null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere),
        this.boundingSphere.setFromPoints(this.vertices)
    },
    merge: function(e, t, n) {
        if (0 == e instanceof THREE.Geometry) console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", e);
        else {
            var r, i = this.vertices.length,
            s = this.vertices,
            o = e.vertices,
            u = this.faces,
            a = e.faces,
            f = this.faceVertexUvs[0];
            e = e.faceVertexUvs[0],
            void 0 === n && (n = 0),
            void 0 !== t && (r = (new THREE.Matrix3).getNormalMatrix(t));
            for (var l = 0,
            c = o.length; l < c; l++) {
                var h = o[l].clone();
                void 0 !== t && h.applyMatrix4(t),
                s.push(h)
            }
            l = 0;
            for (c = a.length; l < c; l++) {
                var o = a[l],
                p,
                d = o.vertexNormals,
                v = o.vertexColors,
                h = new THREE.Face3(o.a + i, o.b + i, o.c + i);
                h.normal.copy(o.normal),
                void 0 !== r && h.normal.applyMatrix3(r).normalize(),
                t = 0;
                for (s = d.length; t < s; t++) p = d[t].clone(),
                void 0 !== r && p.applyMatrix3(r).normalize(),
                h.vertexNormals.push(p);
                h.color.copy(o.color),
                t = 0;
                for (s = v.length; t < s; t++) p = v[t],
                h.vertexColors.push(p.clone());
                h.materialIndex = o.materialIndex + n,
                u.push(h)
            }
            l = 0;
            for (c = e.length; l < c; l++) if (n = e[l], r = [], void 0 !== n) {
                t = 0;
                for (s = n.length; t < s; t++) r.push(n[t].clone());
                f.push(r)
            }
        }
    },
    mergeMesh: function(e) {
        0 == e instanceof THREE.Mesh ? console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", e) : (e.matrixAutoUpdate && e.updateMatrix(), this.merge(e.geometry, e.matrix))
    },
    mergeVertices: function() {
        var e = {},
        t = [],
        n = [],
        r,
        i = Math.pow(10, 4),
        s,
        o;
        s = 0;
        for (o = this.vertices.length; s < o; s++) r = this.vertices[s],
        r = Math.round(r.x * i) + "_" + Math.round(r.y * i) + "_" + Math.round(r.z * i),
        void 0 === e[r] ? (e[r] = s, t.push(this.vertices[s]), n[s] = t.length - 1) : n[s] = n[e[r]];
        e = [],
        s = 0;
        for (o = this.faces.length; s < o; s++) for (i = this.faces[s], i.a = n[i.a], i.b = n[i.b], i.c = n[i.c], i = [i.a, i.b, i.c], r = 0; 3 > r; r++) if (i[r] === i[(r + 1) % 3]) {
            e.push(s);
            break
        }
        for (s = e.length - 1; 0 <= s; s--) for (i = e[s], this.faces.splice(i, 1), n = 0, o = this.faceVertexUvs.length; n < o; n++) this.faceVertexUvs[n].splice(i, 1);
        return s = this.vertices.length - t.length,
        this.vertices = t,
        s
    },
    sortFacesByMaterialIndex: function() {
        for (var e = this.faces,
        t = e.length,
        n = 0; n < t; n++) e[n]._id = n;
        e.sort(function(e, t) {
            return e.materialIndex - t.materialIndex
        });
        var r = this.faceVertexUvs[0],
        i = this.faceVertexUvs[1],
        s,
        o;
        r && r.length === t && (s = []),
        i && i.length === t && (o = []);
        for (n = 0; n < t; n++) {
            var u = e[n]._id;
            s && s.push(r[u]),
            o && o.push(i[u])
        }
        s && (this.faceVertexUvs[0] = s),
        o && (this.faceVertexUvs[1] = o)
    },
    toJSON: function() {
        function e(e, t, n) {
            return n ? e | 1 << t: e & ~ (1 << t)
        }
        function t(e) {
            var t = e.x.toString() + e.y.toString() + e.z.toString();
            return void 0 !== f[t] ? f[t] : (f[t] = a.length / 3, a.push(e.x, e.y, e.z), f[t])
        }
        function n(e) {
            var t = e.r.toString() + e.g.toString() + e.b.toString();
            return void 0 !== c[t] ? c[t] : (c[t] = l.length, l.push(e.getHex()), c[t])
        }
        function r(e) {
            var t = e.x.toString() + e.y.toString();
            return void 0 !== p[t] ? p[t] : (p[t] = h.length / 2, h.push(e.x, e.y), p[t])
        }
        var i = {
            metadata: {
                version: 4.4,
                type: "Geometry",
                generator: "Geometry.toJSON"
            }
        };
        i.uuid = this.uuid,
        i.type = this.type,
        "" !== this.name && (i.name = this.name);
        if (void 0 !== this.parameters) {
            var s = this.parameters,
            o;
            for (o in s) void 0 !== s[o] && (i[o] = s[o]);
            return i
        }
        s = [];
        for (o = 0; o < this.vertices.length; o++) {
            var u = this.vertices[o];
            s.push(u.x, u.y, u.z)
        }
        var u = [],
        a = [],
        f = {},
        l = [],
        c = {},
        h = [],
        p = {};
        for (o = 0; o < this.faces.length; o++) {
            var d = this.faces[o],
            v = void 0 !== this.faceVertexUvs[0][o],
            m = 0 < d.normal.length(),
            g = 0 < d.vertexNormals.length,
            y = 1 !== d.color.r || 1 !== d.color.g || 1 !== d.color.b,
            b = 0 < d.vertexColors.length,
            w = 0,
            w = e(w, 0, 0),
            w = e(w, 1, !0),
            w = e(w, 2, !1),
            w = e(w, 3, v),
            w = e(w, 4, m),
            w = e(w, 5, g),
            w = e(w, 6, y),
            w = e(w, 7, b);
            u.push(w),
            u.push(d.a, d.b, d.c),
            u.push(d.materialIndex),
            v && (v = this.faceVertexUvs[0][o], u.push(r(v[0]), r(v[1]), r(v[2]))),
            m && u.push(t(d.normal)),
            g && (m = d.vertexNormals, u.push(t(m[0]), t(m[1]), t(m[2]))),
            y && u.push(n(d.color)),
            b && (d = d.vertexColors, u.push(n(d[0]), n(d[1]), n(d[2])))
        }
        return i.data = {},
        i.data.vertices = s,
        i.data.normals = a,
        0 < l.length && (i.data.colors = l),
        0 < h.length && (i.data.uvs = [h]),
        i.data.faces = u,
        i
    },
    clone: function() {
        return (new THREE.Geometry).copy(this)
    },
    copy: function(e) {
        this.vertices = [],
        this.faces = [],
        this.faceVertexUvs = [[]];
        for (var t = e.vertices,
        n = 0,
        r = t.length; n < r; n++) this.vertices.push(t[n].clone());
        t = e.faces,
        n = 0;
        for (r = t.length; n < r; n++) this.faces.push(t[n].clone());
        n = 0;
        for (r = e.faceVertexUvs.length; n < r; n++) {
            t = e.faceVertexUvs[n],
            void 0 === this.faceVertexUvs[n] && (this.faceVertexUvs[n] = []);
            for (var i = 0,
            s = t.length; i < s; i++) {
                for (var o = t[i], u = [], a = 0, f = o.length; a < f; a++) u.push(o[a].clone());
                this.faceVertexUvs[n].push(u)
            }
        }
        return this
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
},
THREE.EventDispatcher.prototype.apply(THREE.Geometry.prototype),
THREE.GeometryIdCount = 0,
THREE.DirectGeometry = function() {
    Object.defineProperty(this, "id", {
        value: THREE.GeometryIdCount++
    }),
    this.uuid = THREE.Math.generateUUID(),
    this.name = "",
    this.type = "DirectGeometry",
    this.indices = [],
    this.vertices = [],
    this.normals = [],
    this.colors = [],
    this.uvs = [],
    this.uvs2 = [],
    this.groups = [],
    this.morphTargets = {},
    this.skinWeights = [],
    this.skinIndices = [],
    this.boundingSphere = this.boundingBox = null,
    this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
},
THREE.DirectGeometry.prototype = {
    constructor: THREE.DirectGeometry,
    computeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,
    computeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,
    computeFaceNormals: function() {
        console.warn("THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.")
    },
    computeVertexNormals: function() {
        console.warn("THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.")
    },
    computeGroups: function(e) {
        var t, n = [],
        r;
        e = e.faces;
        for (var i = 0; i < e.length; i++) {
            var s = e[i];
            s.materialIndex !== r && (r = s.materialIndex, void 0 !== t && (t.count = 3 * i - t.start, n.push(t)), t = {
                start: 3 * i,
                materialIndex: r
            })
        }
        void 0 !== t && (t.count = 3 * i - t.start, n.push(t)),
        this.groups = n
    },
    fromGeometry: function(e) {
        var t = e.faces,
        n = e.vertices,
        r = e.faceVertexUvs,
        i = r[0] && 0 < r[0].length,
        s = r[1] && 0 < r[1].length,
        o = e.morphTargets,
        u = o.length,
        a;
        if (0 < u) {
            a = [];
            for (var f = 0; f < u; f++) a[f] = [];
            this.morphTargets.position = a
        }
        var l = e.morphNormals,
        c = l.length,
        h;
        if (0 < c) {
            h = [];
            for (f = 0; f < c; f++) h[f] = [];
            this.morphTargets.normal = h
        }
        for (var p = e.skinIndices,
        d = e.skinWeights,
        v = p.length === n.length,
        m = d.length === n.length,
        f = 0; f < t.length; f++) {
            var g = t[f];
            this.vertices.push(n[g.a], n[g.b], n[g.c]);
            var y = g.vertexNormals;
            3 === y.length ? this.normals.push(y[0], y[1], y[2]) : (y = g.normal, this.normals.push(y, y, y)),
            y = g.vertexColors,
            3 === y.length ? this.colors.push(y[0], y[1], y[2]) : (y = g.color, this.colors.push(y, y, y)),
            !0 === i && (y = r[0][f], void 0 !== y ? this.uvs.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", f), this.uvs.push(new THREE.Vector2, new THREE.Vector2, new THREE.Vector2))),
            !0 === s && (y = r[1][f], void 0 !== y ? this.uvs2.push(y[0], y[1], y[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", f), this.uvs2.push(new THREE.Vector2, new THREE.Vector2, new THREE.Vector2)));
            for (y = 0; y < u; y++) {
                var b = o[y].vertices;
                a[y].push(b[g.a], b[g.b], b[g.c])
            }
            for (y = 0; y < c; y++) b = l[y].vertexNormals[f],
            h[y].push(b.a, b.b, b.c);
            v && this.skinIndices.push(p[g.a], p[g.b], p[g.c]),
            m && this.skinWeights.push(d[g.a], d[g.b], d[g.c])
        }
        return this.computeGroups(e),
        this.verticesNeedUpdate = e.verticesNeedUpdate,
        this.normalsNeedUpdate = e.normalsNeedUpdate,
        this.colorsNeedUpdate = e.colorsNeedUpdate,
        this.uvsNeedUpdate = e.uvsNeedUpdate,
        this.groupsNeedUpdate = e.groupsNeedUpdate,
        this
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
},
THREE.EventDispatcher.prototype.apply(THREE.DirectGeometry.prototype),
THREE.BufferGeometry = function() {
    Object.defineProperty(this, "id", {
        value: THREE.GeometryIdCount++
    }),
    this.uuid = THREE.Math.generateUUID(),
    this.name = "",
    this.type = "BufferGeometry",
    this.index = null,
    this.attributes = {},
    this.morphAttributes = {},
    this.groups = [],
    this.boundingSphere = this.boundingBox = null,
    this.drawRange = {
        start: 0,
        count: Infinity
    }
},
THREE.BufferGeometry.prototype = {
    constructor: THREE.BufferGeometry,
    getIndex: function() {
        return this.index
    },
    setIndex: function(e) {
        this.index = e
    },
    addAttribute: function(e, t, n) {
        if (0 == t instanceof THREE.BufferAttribute && 0 == t instanceof THREE.InterleavedBufferAttribute) console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."),
        this.addAttribute(e, new THREE.BufferAttribute(t, n));
        else {
            if ("index" !== e) return this.attributes[e] = t,
            this;
            console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."),
            this.setIndex(t)
        }
    },
    getAttribute: function(e) {
        return this.attributes[e]
    },
    removeAttribute: function(e) {
        return delete this.attributes[e],
        this
    },
    addGroup: function(e, t, n) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: void 0 !== n ? n: 0
        })
    },
    clearGroups: function() {
        this.groups = []
    },
    setDrawRange: function(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    },
    applyMatrix: function(e) {
        var t = this.attributes.position;
        return void 0 !== t && (e.applyToVector3Array(t.array), t.needsUpdate = !0),
        t = this.attributes.normal,
        void 0 !== t && ((new THREE.Matrix3).getNormalMatrix(e).applyToVector3Array(t.array), t.needsUpdate = !0),
        null !== this.boundingBox && this.computeBoundingBox(),
        null !== this.boundingSphere && this.computeBoundingSphere(),
        this
    },
    rotateX: function() {
        var e;
        return function(t) {
            return void 0 === e && (e = new THREE.Matrix4),
            e.makeRotationX(t),
            this.applyMatrix(e),
            this
        }
    } (),
    rotateY: function() {
        var e;
        return function(t) {
            return void 0 === e && (e = new THREE.Matrix4),
            e.makeRotationY(t),
            this.applyMatrix(e),
            this
        }
    } (),
    rotateZ: function() {
        var e;
        return function(t) {
            return void 0 === e && (e = new THREE.Matrix4),
            e.makeRotationZ(t),
            this.applyMatrix(e),
            this
        }
    } (),
    translate: function() {
        var e;
        return function(t, n, r) {
            return void 0 === e && (e = new THREE.Matrix4),
            e.makeTranslation(t, n, r),
            this.applyMatrix(e),
            this
        }
    } (),
    scale: function() {
        var e;
        return function(t, n, r) {
            return void 0 === e && (e = new THREE.Matrix4),
            e.makeScale(t, n, r),
            this.applyMatrix(e),
            this
        }
    } (),
    lookAt: function() {
        var e;
        return function(t) {
            void 0 === e && (e = new THREE.Object3D),
            e.lookAt(t),
            e.updateMatrix(),
            this.applyMatrix(e.matrix)
        }
    } (),
    center: function() {
        this.computeBoundingBox();
        var e = this.boundingBox.center().negate();
        return this.translate(e.x, e.y, e.z),
        e
    },
    setFromObject: function(e) {
        var t = e.geometry;
        if (e instanceof THREE.Points || e instanceof THREE.Line) {
            e = new THREE.Float32Attribute(3 * t.vertices.length, 3);
            var n = new THREE.Float32Attribute(3 * t.colors.length, 3);
            this.addAttribute("position", e.copyVector3sArray(t.vertices)),
            this.addAttribute("color", n.copyColorsArray(t.colors)),
            t.lineDistances && t.lineDistances.length === t.vertices.length && (e = new THREE.Float32Attribute(t.lineDistances.length, 1), this.addAttribute("lineDistance", e.copyArray(t.lineDistances))),
            null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()),
            null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone())
        } else e instanceof THREE.Mesh && t instanceof THREE.Geometry && this.fromGeometry(t);
        return this
    },
    updateFromObject: function(e) {
        var t = e.geometry;
        if (e instanceof THREE.Mesh) {
            var n = t.__directGeometry;
            if (void 0 === n) return this.fromGeometry(t);
            n.verticesNeedUpdate = t.verticesNeedUpdate,
            n.normalsNeedUpdate = t.normalsNeedUpdate,
            n.colorsNeedUpdate = t.colorsNeedUpdate,
            n.uvsNeedUpdate = t.uvsNeedUpdate,
            n.groupsNeedUpdate = t.groupsNeedUpdate,
            t.verticesNeedUpdate = !1,
            t.normalsNeedUpdate = !1,
            t.colorsNeedUpdate = !1,
            t.uvsNeedUpdate = !1,
            t.groupsNeedUpdate = !1,
            t = n
        }
        return ! 0 === t.verticesNeedUpdate && (n = this.attributes.position, void 0 !== n && (n.copyVector3sArray(t.vertices), n.needsUpdate = !0), t.verticesNeedUpdate = !1),
        !0 === t.normalsNeedUpdate && (n = this.attributes.normal, void 0 !== n && (n.copyVector3sArray(t.normals), n.needsUpdate = !0), t.normalsNeedUpdate = !1),
        !0 === t.colorsNeedUpdate && (n = this.attributes.color, void 0 !== n && (n.copyColorsArray(t.colors), n.needsUpdate = !0), t.colorsNeedUpdate = !1),
        t.uvsNeedUpdate && (n = this.attributes.uv, void 0 !== n && (n.copyVector2sArray(t.uvs), n.needsUpdate = !0), t.uvsNeedUpdate = !1),
        t.lineDistancesNeedUpdate && (n = this.attributes.lineDistance, void 0 !== n && (n.copyArray(t.lineDistances), n.needsUpdate = !0), t.lineDistancesNeedUpdate = !1),
        t.groupsNeedUpdate && (t.computeGroups(e.geometry), this.groups = t.groups, t.groupsNeedUpdate = !1),
        this
    },
    fromGeometry: function(e) {
        return e.__directGeometry = (new THREE.DirectGeometry).fromGeometry(e),
        this.fromDirectGeometry(e.__directGeometry)
    },
    fromDirectGeometry: function(e) {
        var t = new Float32Array(3 * e.vertices.length);
        this.addAttribute("position", (new THREE.BufferAttribute(t, 3)).copyVector3sArray(e.vertices)),
        0 < e.normals.length && (t = new Float32Array(3 * e.normals.length), this.addAttribute("normal", (new THREE.BufferAttribute(t, 3)).copyVector3sArray(e.normals))),
        0 < e.colors.length && (t = new Float32Array(3 * e.colors.length), this.addAttribute("color", (new THREE.BufferAttribute(t, 3)).copyColorsArray(e.colors))),
        0 < e.uvs.length && (t = new Float32Array(2 * e.uvs.length), this.addAttribute("uv", (new THREE.BufferAttribute(t, 2)).copyVector2sArray(e.uvs))),
        0 < e.uvs2.length && (t = new Float32Array(2 * e.uvs2.length), this.addAttribute("uv2", (new THREE.BufferAttribute(t, 2)).copyVector2sArray(e.uvs2))),
        0 < e.indices.length && (t = new(65535 < e.vertices.length ? Uint32Array: Uint16Array)(3 * e.indices.length), this.setIndex((new THREE.BufferAttribute(t, 1)).copyIndicesArray(e.indices))),
        this.groups = e.groups;
        for (var n in e.morphTargets) {
            for (var t = [], r = e.morphTargets[n], i = 0, s = r.length; i < s; i++) {
                var o = r[i],
                u = new THREE.Float32Attribute(3 * o.length, 3);
                t.push(u.copyVector3sArray(o))
            }
            this.morphAttributes[n] = t
        }
        return 0 < e.skinIndices.length && (n = new THREE.Float32Attribute(4 * e.skinIndices.length, 4), this.addAttribute("skinIndex", n.copyVector4sArray(e.skinIndices))),
        0 < e.skinWeights.length && (n = new THREE.Float32Attribute(4 * e.skinWeights.length, 4), this.addAttribute("skinWeight", n.copyVector4sArray(e.skinWeights))),
        null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()),
        null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
        this
    },
    computeBoundingBox: function() {
        return new THREE.Vector3,
        function() {
            null === this.boundingBox && (this.boundingBox = new THREE.Box3);
            var e = this.attributes.position.array;
            e && this.boundingBox.setFromArray(e);
            if (void 0 === e || 0 === e.length) this.boundingBox.min.set(0, 0, 0),
            this.boundingBox.max.set(0, 0, 0); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        }
    } (),
    computeBoundingSphere: function() {
        var e = new THREE.Box3,
        t = new THREE.Vector3;
        return function() {
            null === this.boundingSphere && (this.boundingSphere = new THREE.Sphere);
            var n = this.attributes.position.array;
            if (n) {
                var r = this.boundingSphere.center;
                e.setFromArray(n),
                e.center(r);
                for (var i = 0,
                s = 0,
                o = n.length; s < o; s += 3) t.fromArray(n, s),
                i = Math.max(i, r.distanceToSquared(t));
                this.boundingSphere.radius = Math.sqrt(i),
                isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
            }
        }
    } (),
    computeFaceNormals: function() {},
    computeVertexNormals: function() {
        var e = this.index,
        t = this.attributes,
        n = this.groups;
        if (t.position) {
            var r = t.position.array;
            if (void 0 === t.normal) this.addAttribute("normal", new THREE.BufferAttribute(new Float32Array(r.length), 3));
            else for (var i = t.normal.array,
            s = 0,
            o = i.length; s < o; s++) i[s] = 0;
            var i = t.normal.array,
            u, a, f, l = new THREE.Vector3,
            c = new THREE.Vector3,
            h = new THREE.Vector3,
            p = new THREE.Vector3,
            d = new THREE.Vector3;
            if (e) {
                e = e.array,
                0 === n.length && this.addGroup(0, e.length);
                for (var v = 0,
                m = n.length; v < m; ++v) for (s = n[v], o = s.start, u = s.count, s = o, o += u; s < o; s += 3) u = 3 * e[s + 0],
                a = 3 * e[s + 1],
                f = 3 * e[s + 2],
                l.fromArray(r, u),
                c.fromArray(r, a),
                h.fromArray(r, f),
                p.subVectors(h, c),
                d.subVectors(l, c),
                p.cross(d),
                i[u] += p.x,
                i[u + 1] += p.y,
                i[u + 2] += p.z,
                i[a] += p.x,
                i[a + 1] += p.y,
                i[a + 2] += p.z,
                i[f] += p.x,
                i[f + 1] += p.y,
                i[f + 2] += p.z
            } else for (s = 0, o = r.length; s < o; s += 9) l.fromArray(r, s),
            c.fromArray(r, s + 3),
            h.fromArray(r, s + 6),
            p.subVectors(h, c),
            d.subVectors(l, c),
            p.cross(d),
            i[s] = p.x,
            i[s + 1] = p.y,
            i[s + 2] = p.z,
            i[s + 3] = p.x,
            i[s + 4] = p.y,
            i[s + 5] = p.z,
            i[s + 6] = p.x,
            i[s + 7] = p.y,
            i[s + 8] = p.z;
            this.normalizeNormals(),
            t.normal.needsUpdate = !0
        }
    },
    merge: function(e, t) {
        if (0 != e instanceof THREE.BufferGeometry) {
            void 0 === t && (t = 0);
            var n = this.attributes,
            r;
            for (r in n) if (void 0 !== e.attributes[r]) for (var i = n[r].array, s = e.attributes[r], o = s.array, u = 0, s = s.itemSize * t; u < o.length; u++, s++) i[s] = o[u];
            return this
        }
        console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", e)
    },
    normalizeNormals: function() {
        for (var e = this.attributes.normal.array,
        t, n, r, i = 0,
        s = e.length; i < s; i += 3) t = e[i],
        n = e[i + 1],
        r = e[i + 2],
        t = 1 / Math.sqrt(t * t + n * n + r * r),
        e[i] *= t,
        e[i + 1] *= t,
        e[i + 2] *= t
    },
    toNonIndexed: function() {
        if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."),
        this;
        var e = new THREE.BufferGeometry,
        t = this.index.array,
        n = this.attributes,
        r;
        for (r in n) {
            for (var i = n[r], s = i.array, i = i.itemSize, o = new s.constructor(t.length * i), u = 0, a = 0, f = 0, l = t.length; f < l; f++) for (var u = t[f] * i, c = 0; c < i; c++) o[a++] = s[u++];
            e.addAttribute(r, new THREE.BufferAttribute(o, i))
        }
        return e
    },
    toJSON: function() {
        var e = {
            metadata: {
                version: 4.4,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        e.uuid = this.uuid,
        e.type = this.type,
        "" !== this.name && (e.name = this.name);
        if (void 0 !== this.parameters) {
            var t = this.parameters,
            n;
            for (n in t) void 0 !== t[n] && (e[n] = t[n]);
            return e
        }
        e.data = {
            attributes: {}
        };
        var r = this.index;
        null !== r && (t = Array.prototype.slice.call(r.array), e.data.index = {
            type: r.array.constructor.name,
            array: t
        }),
        r = this.attributes;
        for (n in r) {
            var i = r[n],
            t = Array.prototype.slice.call(i.array);
            e.data.attributes[n] = {
                itemSize: i.itemSize,
                type: i.array.constructor.name,
                array: t
            }
        }
        return n = this.groups,
        0 < n.length && (e.data.groups = JSON.parse(JSON.stringify(n))),
        n = this.boundingSphere,
        null !== n && (e.data.boundingSphere = {
            center: n.center.toArray(),
            radius: n.radius
        }),
        e
    },
    clone: function() {
        return (new THREE.BufferGeometry).copy(this)
    },
    copy: function(e) {
        var t = e.index;
        null !== t && this.setIndex(t.clone());
        var t = e.attributes,
        n;
        for (n in t) this.addAttribute(n, t[n].clone());
        e = e.groups,
        n = 0;
        for (t = e.length; n < t; n++) {
            var r = e[n];
            this.addGroup(r.start, r.count)
        }
        return this
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
},
THREE.EventDispatcher.prototype.apply(THREE.BufferGeometry.prototype),
THREE.BufferGeometry.MaxIndex = 65535,
THREE.InstancedBufferGeometry = function() {
    THREE.BufferGeometry.call(this),
    this.type = "InstancedBufferGeometry",
    this.maxInstancedCount = void 0
},
THREE.InstancedBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
THREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry,
THREE.InstancedBufferGeometry.prototype.addGroup = function(e, t, n) {
    this.groups.push({
        start: e,
        count: t,
        instances: n
    })
},
THREE.InstancedBufferGeometry.prototype.copy = function(e) {
    var t = e.index;
    null !== t && this.setIndex(t.clone());
    var t = e.attributes,
    n;
    for (n in t) this.addAttribute(n, t[n].clone());
    e = e.groups,
    n = 0;
    for (t = e.length; n < t; n++) {
        var r = e[n];
        this.addGroup(r.start, r.count, r.instances)
    }
    return this
},
THREE.EventDispatcher.prototype.apply(THREE.InstancedBufferGeometry.prototype),
THREE.Uniform = function(e, t) {
    this.type = e,
    this.value = t,
    this.dynamic = !1
},
THREE.Uniform.prototype = {
    constructor: THREE.Uniform,
    onUpdate: function(e) {
        return this.dynamic = !0,
        this.onUpdateCallback = e,
        this
    }
},
THREE.AnimationClip = function(e, t, n) {
    this.name = e || THREE.Math.generateUUID(),
    this.tracks = n,
    this.duration = void 0 !== t ? t: -1,
    0 > this.duration && this.resetDuration(),
    this.trim(),
    this.optimize()
},
THREE.AnimationClip.prototype = {
    constructor: THREE.AnimationClip,
    resetDuration: function() {
        for (var e = 0,
        t = 0,
        n = this.tracks.length; t !== n; ++t) var r = this.tracks[t],
        e = Math.max(e, r.times[r.times.length - 1]);
        this.duration = e
    },
    trim: function() {
        for (var e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
        return this
    },
    optimize: function() {
        for (var e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this
    }
},
Object.assign(THREE.AnimationClip, {
    parse: function(e) {
        for (var t = [], n = e.tracks, r = 1 / (e.fps || 1), i = 0, s = n.length; i !== s; ++i) t.push(THREE.KeyframeTrack.parse(n[i]).scale(r));
        return new THREE.AnimationClip(e.name, e.duration, t)
    },
    toJSON: function(e) {
        var t = [],
        n = e.tracks;
        e = {
            name: e.name,
            duration: e.duration,
            tracks: t
        };
        for (var r = 0,
        i = n.length; r !== i; ++r) t.push(THREE.KeyframeTrack.toJSON(n[r]));
        return e
    },
    CreateFromMorphTargetSequence: function(e, t, n) {
        for (var r = t.length,
        i = [], s = 0; s < r; s++) {
            var o = [],
            u = [];
            o.push((s + r - 1) % r, s, (s + 1) % r),
            u.push(0, 1, 0);
            var a = THREE.AnimationUtils.getKeyframeOrder(o),
            o = THREE.AnimationUtils.sortedArray(o, 1, a),
            u = THREE.AnimationUtils.sortedArray(u, 1, a);
            0 === o[0] && (o.push(r), u.push(u[0])),
            i.push((new THREE.NumberKeyframeTrack(".morphTargetInfluences[" + t[s].name + "]", o, u)).scale(1 / n))
        }
        return new THREE.AnimationClip(e, -1, i)
    },
    findByName: function(e, t) {
        for (var n = 0; n < e.length; n++) if (e[n].name === t) return e[n];
        return null
    },
    CreateClipsFromMorphTargetSequences: function(e, t) {
        for (var n = {},
        r = /^([\w-]*?)([\d]+)$/,
        i = 0,
        s = e.length; i < s; i++) {
            var o = e[i],
            u = o.name.match(r);
            if (u && 1 < u.length) {
                var a = u[1]; (u = n[a]) || (n[a] = u = []),
                u.push(o)
            }
        }
        r = [];
        for (a in n) r.push(THREE.AnimationClip.CreateFromMorphTargetSequence(a, n[a], t));
        return r
    },
    parseAnimation: function(e, t, n) {
        if (!e) return console.error("  no animation in JSONLoader data"),
        null;
        n = function(e, t, n, r, i) {
            if (0 !== n.length) {
                var s = [],
                o = [];
                THREE.AnimationUtils.flattenJSON(n, s, o, r),
                0 !== s.length && i.push(new e(t, s, o))
            }
        };
        var r = [],
        i = e.name || "default",
        s = e.length || -1,
        o = e.fps || 30;
        e = e.hierarchy || [];
        for (var u = 0; u < e.length; u++) {
            var a = e[u].keys;
            if (a && 0 != a.length) if (a[0].morphTargets) {
                for (var s = {},
                f = 0; f < a.length; f++) if (a[f].morphTargets) for (var l = 0; l < a[f].morphTargets.length; l++) s[a[f].morphTargets[l]] = -1;
                for (var c in s) {
                    for (var h = [], p = [], l = 0; l !== a[f].morphTargets.length; ++l) {
                        var d = a[f];
                        h.push(d.time),
                        p.push(d.morphTarget === c ? 1 : 0)
                    }
                    r.push(new THREE.NumberKeyframeTrack(".morphTargetInfluence[" + c + "]", h, p))
                }
                s = s.length * (o || 1)
            } else f = ".bones[" + t[u].name + "]",
            n(THREE.VectorKeyframeTrack, f + ".position", a, "pos", r),
            n(THREE.QuaternionKeyframeTrack, f + ".quaternion", a, "rot", r),
            n(THREE.VectorKeyframeTrack, f + ".scale", a, "scl", r)
        }
        return 0 === r.length ? null: new THREE.AnimationClip(i, s, r)
    }
}),
THREE.AnimationMixer = function(e) {
    this._root = e,
    this._initMemoryManager(),
    this.time = this._accuIndex = 0,
    this.timeScale = 1
},
THREE.AnimationMixer.prototype = {
    constructor: THREE.AnimationMixer,
    clipAction: function(e, t) {
        var n = (t || this._root).uuid,
        r = "string" == typeof e ? e: e.name,
        i = e !== r ? e: null,
        s = this._actionsByClip[r],
        o;
        if (void 0 !== s) {
            o = s.actionByRoot[n];
            if (void 0 !== o) return o;
            o = s.knownActions[0],
            i = o._clip;
            if (e !== r && e !== i) throw Error("Different clips with the same name detected!")
        }
        return null === i ? null: (s = new THREE.AnimationMixer._Action(this, i, t), this._bindAction(s, o), this._addInactiveAction(s, r, n), s)
    },
    existingAction: function(e, t) {
        var n = (t || this._root).uuid,
        r = this._actionsByClip["string" == typeof e ? e: e.name];
        return void 0 !== r ? r.actionByRoot[n] || null: null
    },
    stopAllAction: function() {
        for (var e = this._actions,
        t = this._nActiveActions,
        n = this._bindings,
        r = this._nActiveBindings,
        i = this._nActiveBindings = this._nActiveActions = 0; i !== t; ++i) e[i].reset();
        for (i = 0; i !== r; ++i) n[i].useCount = 0;
        return this
    },
    update: function(e) {
        e *= this.timeScale;
        for (var t = this._actions,
        n = this._nActiveActions,
        r = this.time += e,
        i = Math.sign(e), s = this._accuIndex ^= 1, o = 0; o !== n; ++o) {
            var u = t[o];
            u.enabled && u._update(r, e, i, s)
        }
        e = this._bindings,
        t = this._nActiveBindings;
        for (o = 0; o !== t; ++o) e[o].apply(s);
        return this
    },
    getRoot: function() {
        return this._root
    },
    uncacheClip: function(e) {
        var t = this._actions;
        e = e.name;
        var n = this._actionsByClip,
        r = n[e];
        if (void 0 !== r) {
            for (var r = r.knownActions,
            i = 0,
            s = r.length; i !== s; ++i) {
                var o = r[i];
                this._deactivateAction(o);
                var u = o._cacheIndex,
                a = t[t.length - 1];
                o._cacheIndex = null,
                o._byClipCacheIndex = null,
                a._cacheIndex = u,
                t[u] = a,
                t.pop(),
                this._removeInactiveBindingsForAction(o)
            }
            delete n[e]
        }
    },
    uncacheRoot: function(e) {
        e = e.uuid;
        var t = this._actionsByClip,
        n;
        for (n in t) {
            var r = t[n].actionByRoot[e];
            void 0 !== r && (this._deactivateAction(r), this._removeInactiveAction(r))
        }
        n = this._bindingsByRootAndName[e];
        if (void 0 !== n) for (var i in n) e = n[i],
        e.restoreOriginalState(),
        this._removeInactiveBinding(e)
    },
    uncacheAction: function(e, t) {
        var n = this.existingAction(e, t);
        null !== n && (this._deactivateAction(n), this._removeInactiveAction(n))
    }
},
THREE.EventDispatcher.prototype.apply(THREE.AnimationMixer.prototype),
THREE.AnimationMixer._Action = function(e, t, n) {
    this._mixer = e,
    this._clip = t,
    this._localRoot = n || null,
    e = t.tracks,
    t = e.length,
    n = Array(t);
    for (var r = {
        endingStart: THREE.ZeroCurvatureEnding,
        endingEnd: THREE.ZeroCurvatureEnding
    },
    i = 0; i !== t; ++i) {
        var s = e[i].createInterpolant(null);
        n[i] = s,
        s.settings = r
    }
    this._interpolantSettings = r,
    this._interpolants = n,
    this._propertyBindings = Array(t),
    this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null,
    this.loop = THREE.LoopRepeat,
    this._loopCount = -1,
    this._startTime = null,
    this.time = 0,
    this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1,
    this.repetitions = Infinity,
    this.paused = !1,
    this.enabled = !0,
    this.clampWhenFinished = !1,
    this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
},
THREE.AnimationMixer._Action.prototype = {
    constructor: THREE.AnimationMixer._Action,
    play: function() {
        return this._mixer._activateAction(this),
        this
    },
    stop: function() {
        return this._mixer._deactivateAction(this),
        this.reset()
    },
    reset: function() {
        return this.paused = !1,
        this.enabled = !0,
        this.time = 0,
        this._loopCount = -1,
        this._startTime = null,
        this.stopFading().stopWarping()
    },
    isRunning: function() {
        return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
    },
    isScheduled: function() {
        return this._mixer._isActiveAction(this)
    },
    startAt: function(e) {
        return this._startTime = e,
        this
    },
    setLoop: function(e, t) {
        return this.loop = e,
        this.repetitions = t,
        this
    },
    setEffectiveWeight: function(e) {
        return this.weight = e,
        this._effectiveWeight = this.enabled ? e: 0,
        this.stopFading()
    },
    getEffectiveWeight: function() {
        return this._effectiveWeight
    },
    fadeIn: function(e) {
        return this._scheduleFading(e, 0, 1)
    },
    fadeOut: function(e) {
        return this._scheduleFading(e, 1, 0)
    },
    crossFadeFrom: function(e, t, n) {
        e.fadeOut(t),
        this.fadeIn(t);
        if (n) {
            n = this._clip.duration;
            var r = e._clip.duration,
            i = n / r;
            e.warp(1, r / n, t),
            this.warp(i, 1, t)
        }
        return this
    },
    crossFadeTo: function(e, t, n) {
        return e.crossFadeFrom(this, t, n)
    },
    stopFading: function() {
        var e = this._weightInterpolant;
        return null !== e && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)),
        this
    },
    setEffectiveTimeScale: function(e) {
        return this.timeScale = e,
        this._effectiveTimeScale = this.paused ? 0 : e,
        this.stopWarping()
    },
    getEffectiveTimeScale: function() {
        return this._effectiveTimeScale
    },
    setDuration: function(e) {
        return this.timeScale = this._clip.duration / e,
        this.stopWarping()
    },
    syncWith: function(e) {
        return this.time = e.time,
        this.timeScale = e.timeScale,
        this.stopWarping()
    },
    halt: function(e) {
        return this.warp(this._currentTimeScale, 0, e)
    },
    warp: function(e, t, n) {
        var r = this._mixer,
        i = r.time,
        s = this._timeScaleInterpolant,
        o = this.timeScale;
        return null === s && (this._timeScaleInterpolant = s = r._lendControlInterpolant()),
        r = s.parameterPositions,
        s = s.sampleValues,
        r[0] = i,
        r[1] = i + n,
        s[0] = e / o,
        s[1] = t / o,
        this
    },
    stopWarping: function() {
        var e = this._timeScaleInterpolant;
        return null !== e && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)),
        this
    },
    getMixer: function() {
        return this._mixer
    },
    getClip: function() {
        return this._clip
    },
    getRoot: function() {
        return this._localRoot || this._mixer._root
    },
    _update: function(e, t, n, r) {
        var i = this._startTime;
        if (null !== i) {
            t = (e - i) * n;
            if (0 > t || 0 === n) return;
            this._startTime = null,
            t *= n
        }
        t *= this._updateTimeScale(e),
        n = this._updateTime(t),
        e = this._updateWeight(e);
        if (0 < e) {
            t = this._interpolants;
            for (var i = this._propertyBindings,
            s = 0,
            o = t.length; s !== o; ++s) t[s].evaluate(n),
            i[s].accumulate(r, e)
        }
    },
    _updateWeight: function(e) {
        var t = 0;
        if (this.enabled) {
            var t = this.weight,
            n = this._weightInterpolant;
            if (null !== n) {
                var r = n.evaluate(e)[0],
                t = t * r;
                e > n.parameterPositions[1] && (this.stopFading(), 0 === r && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t
    },
    _updateTimeScale: function(e) {
        var t = 0;
        if (!this.paused) {
            var t = this.timeScale,
            n = this._timeScaleInterpolant;
            if (null !== n) {
                var r = n.evaluate(e)[0],
                t = t * r;
                e > n.parameterPositions[1] && (this.stopWarping(), 0 === t ? this.pause = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t
    },
    _updateTime: function(e) {
        var t = this.time + e;
        if (0 === e) return t;
        var n = this._clip.duration,
        r = this.loop,
        i = this._loopCount,
        s = !1;
        switch (r) {
        case THREE.LoopOnce:
            -1 === i && (this.loopCount = 0, this._setEndings(!0, !0, !1));
            if (t >= n) t = n;
            else {
                if (! (0 > t)) break;
                t = 0
            }
            this.clampWhenFinished ? this.pause = !0 : this.enabled = !1,
            this._mixer.dispatchEvent({
                type: "finished",
                action: this,
                direction: 0 > e ? -1 : 1
            });
            break;
        case THREE.LoopPingPong:
            s = !0;
        case THREE.LoopRepeat:
            -1 === i && (0 < e ? (i = 0, this._setEndings(!0, 0 === this.repetitions, s)) : this._setEndings(0 === this.repetitions, !0, s));
            if (t >= n || 0 > t) {
                var o = Math.floor(t / n),
                t = t - n * o,
                i = i + Math.abs(o),
                u = this.repetitions - i;
                if (0 > u) {
                    this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                    t = 0 < e ? n: 0,
                    this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 < e ? 1 : -1
                    });
                    break
                }
                0 === u ? (e = 0 > e, this._setEndings(e, !e, s)) : this._setEndings(!1, !1, s),
                this._loopCount = i,
                this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: o
                })
            }
            if (r === THREE.LoopPingPong && 1 === (i & 1)) return this.time = t,
            n - t
        }
        return this.time = t
    },
    _setEndings: function(e, t, n) {
        var r = this._interpolantSettings;
        n ? (r.endingStart = THREE.ZeroSlopeEnding, r.endingEnd = THREE.ZeroSlopeEnding) : (r.endingStart = e ? this.zeroSlopeAtStart ? THREE.ZeroSlopeEnding: THREE.ZeroCurvatureEnding: THREE.WrapAroundEnding, r.endingEnd = t ? this.zeroSlopeAtEnd ? THREE.ZeroSlopeEnding: THREE.ZeroCurvatureEnding: THREE.WrapAroundEnding)
    },
    _scheduleFading: function(e, t, n) {
        var r = this._mixer,
        i = r.time,
        s = this._weightInterpolant;
        return null === s && (this._weightInterpolant = s = r._lendControlInterpolant()),
        r = s.parameterPositions,
        s = s.sampleValues,
        r[0] = i,
        s[0] = t,
        r[1] = i + e,
        s[1] = n,
        this
    }
},
Object.assign(THREE.AnimationMixer.prototype, {
    _bindAction: function(e, t) {
        var n = e._localRoot || this._root,
        r = e._clip.tracks,
        i = r.length,
        s = e._propertyBindings,
        o = e._interpolants,
        u = n.uuid,
        a = this._bindingsByRootAndName,
        f = a[u];
        void 0 === f && (f = {},
        a[u] = f);
        for (a = 0; a !== i; ++a) {
            var l = r[a],
            c = l.name,
            h = f[c];
            if (void 0 === h) {
                h = s[a];
                if (void 0 !== h) {
                    null === h._cacheIndex && (++h.referenceCount, this._addInactiveBinding(h, u, c));
                    continue
                }
                h = new THREE.PropertyMixer(THREE.PropertyBinding.create(n, c, t && t._propertyBindings[a].binding.parsedPath), l.ValueTypeName, l.getValueSize()),
                ++h.referenceCount,
                this._addInactiveBinding(h, u, c)
            }
            s[a] = h,
            o[a].resultBuffer = h.buffer
        }
    },
    _activateAction: function(e) {
        if (!this._isActiveAction(e)) {
            if (null === e._cacheIndex) {
                var t = (e._localRoot || this._root).uuid,
                n = e._clip.name,
                r = this._actionsByClip[n];
                this._bindAction(e, r && r.knownActions[0]),
                this._addInactiveAction(e, n, t)
            }
            t = e._propertyBindings,
            n = 0;
            for (r = t.length; n !== r; ++n) {
                var i = t[n];
                0 === i.useCount++&&(this._lendBinding(i), i.saveOriginalState())
            }
            this._lendAction(e)
        }
    },
    _deactivateAction: function(e) {
        if (this._isActiveAction(e)) {
            for (var t = e._propertyBindings,
            n = 0,
            r = t.length; n !== r; ++n) {
                var i = t[n];
                0 === --i.useCount && (i.restoreOriginalState(), this._takeBackBinding(i))
            }
            this._takeBackAction(e)
        }
    },
    _initMemoryManager: function() {
        this._actions = [],
        this._nActiveActions = 0,
        this._actionsByClip = {},
        this._bindings = [],
        this._nActiveBindings = 0,
        this._bindingsByRootAndName = {},
        this._controlInterpolants = [],
        this._nActiveControlInterpolants = 0;
        var e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    },
    _isActiveAction: function(e) {
        return e = e._cacheIndex,
        null !== e && e < this._nActiveActions
    },
    _addInactiveAction: function(e, t, n) {
        var r = this._actions,
        i = this._actionsByClip,
        s = i[t];
        void 0 === s ? (s = {
            knownActions: [e],
            actionByRoot: {}
        },
        e._byClipCacheIndex = 0, i[t] = s) : (t = s.knownActions, e._byClipCacheIndex = t.length, t.push(e)),
        e._cacheIndex = r.length,
        r.push(e),
        s.actionByRoot[n] = e
    },
    _removeInactiveAction: function(e) {
        var t = this._actions,
        n = t[t.length - 1],
        r = e._cacheIndex;
        n._cacheIndex = r,
        t[r] = n,
        t.pop(),
        e._cacheIndex = null;
        var n = e._clip.name,
        r = this._actionsByClip,
        i = r[n],
        s = i.knownActions,
        o = s[s.length - 1],
        u = e._byClipCacheIndex;
        o._byClipCacheIndex = u,
        s[u] = o,
        s.pop(),
        e._byClipCacheIndex = null,
        delete i.actionByRoot[(t._localRoot || this._root).uuid],
        0 === s.length && delete r[n],
        this._removeInactiveBindingsForAction(e)
    },
    _removeInactiveBindingsForAction: function(e) {
        e = e._propertyBindings;
        for (var t = 0,
        n = e.length; t !== n; ++t) {
            var r = e[t];
            0 === --r.referenceCount && this._removeInactiveBinding(r)
        }
    },
    _lendAction: function(e) {
        var t = this._actions,
        n = e._cacheIndex,
        r = this._nActiveActions++,
        i = t[r];
        e._cacheIndex = r,
        t[r] = e,
        i._cacheIndex = n,
        t[n] = i
    },
    _takeBackAction: function(e) {
        var t = this._actions,
        n = e._cacheIndex,
        r = --this._nActiveActions,
        i = t[r];
        e._cacheIndex = r,
        t[r] = e,
        i._cacheIndex = n,
        t[n] = i
    },
    _addInactiveBinding: function(e, t, n) {
        var r = this._bindingsByRootAndName,
        i = r[t],
        s = this._bindings;
        void 0 === i && (i = {},
        r[t] = i),
        i[n] = e,
        e._cacheIndex = s.length,
        s.push(e)
    },
    _removeInactiveBinding: function(e) {
        var t = this._bindings,
        n = e.binding,
        r = n.rootNode.uuid,
        n = n.path,
        i = this._bindingsByRootAndName,
        s = i[r],
        o = t[t.length - 1];
        e = e._cacheIndex,
        o._cacheIndex = e,
        t[e] = o,
        t.pop(),
        delete s[n];
        e: {
            for (var u in s) break e;
            delete i[r]
        }
    },
    _lendBinding: function(e) {
        var t = this._bindings,
        n = e._cacheIndex,
        r = this._nActiveBindings++,
        i = t[r];
        e._cacheIndex = r,
        t[r] = e,
        i._cacheIndex = n,
        t[n] = i
    },
    _takeBackBinding: function(e) {
        var t = this._bindings,
        n = e._cacheIndex,
        r = --this._nActiveBindings,
        i = t[r];
        e._cacheIndex = r,
        t[r] = e,
        i._cacheIndex = n,
        t[n] = i
    },
    _lendControlInterpolant: function() {
        var e = this._controlInterpolants,
        t = this._nActiveControlInterpolants++,
        n = e[t];
        return void 0 === n && (n = new THREE.LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), n.__cacheIndex = t, e[t] = n),
        n
    },
    _takeBackControlInterpolant: function(e) {
        var t = this._controlInterpolants,
        n = e.__cacheIndex,
        r = --this._nActiveControlInterpolants,
        i = t[r];
        e.__cacheIndex = r,
        t[r] = e,
        i.__cacheIndex = n,
        t[n] = i
    },
    _controlInterpolantsResultBuffer: new Float32Array(1)
}),
THREE.AnimationObjectGroup = function(e) {
    this.uuid = THREE.Math.generateUUID(),
    this._objects = Array.prototype.slice.call(arguments),
    this.nCachedObjects_ = 0;
    var t = {};
    this._indicesByUUID = t;
    for (var n = 0,
    r = arguments.length; n !== r; ++n) t[arguments[n].uuid] = n;
    this._paths = [],
    this._parsedPaths = [],
    this._bindings = [],
    this._bindingsIndicesByPath = {};
    var i = this;
    this.stats = {
        objects: {
            get total() {
                return i._objects.length
            },
            get inUse() {
                return this.total - i.nCachedObjects_
            }
        },
        get bindingsPerObject() {
            return i._bindings.length
        }
    }
},
THREE.AnimationObjectGroup.prototype = {
    constructor: THREE.AnimationObjectGroup,
    add: function(e) {
        for (var t = this._objects,
        n = t.length,
        r = this.nCachedObjects_,
        i = this._indicesByUUID,
        s = this._paths,
        o = this._parsedPaths,
        u = this._bindings,
        a = u.length,
        f = 0,
        l = arguments.length; f !== l; ++f) {
            var c = arguments[f],
            h = c.uuid,
            p = i[h];
            if (void 0 === p) {
                p = n++,
                i[h] = p,
                t.push(c);
                for (var h = 0,
                d = a; h !== d; ++h) u[h].push(new THREE.PropertyBinding(c, s[h], o[h]))
            } else if (p < r) {
                var v = t[p],
                m = --r,
                d = t[m];
                i[d.uuid] = p,
                t[p] = d,
                i[h] = m,
                t[m] = c,
                h = 0;
                for (d = a; h !== d; ++h) {
                    var g = u[h],
                    y = g[p];
                    g[p] = g[m],
                    void 0 === y && (y = new THREE.PropertyBinding(c, s[h], o[h])),
                    g[m] = y
                }
            } else t[p] !== v && console.error("Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes...")
        }
        this.nCachedObjects_ = r
    },
    remove: function(e) {
        for (var t = this._objects,
        n = this.nCachedObjects_,
        r = this._indicesByUUID,
        i = this._bindings,
        s = i.length,
        o = 0,
        u = arguments.length; o !== u; ++o) {
            var a = arguments[o],
            f = a.uuid,
            l = r[f];
            if (void 0 !== l && l >= n) {
                var c = n++,
                h = t[c];
                r[h.uuid] = l,
                t[l] = h,
                r[f] = c,
                t[c] = a,
                a = 0;
                for (f = s; a !== f; ++a) {
                    var h = i[a],
                    p = h[l];
                    h[l] = h[c],
                    h[c] = p
                }
            }
        }
        this.nCachedObjects_ = n
    },
    uncache: function(e) {
        for (var t = this._objects,
        n = t.length,
        r = this.nCachedObjects_,
        i = this._indicesByUUID,
        s = this._bindings,
        o = s.length,
        u = 0,
        a = arguments.length; u !== a; ++u) {
            var f = arguments[u].uuid,
            l = i[f];
            if (void 0 !== l) if (delete i[f], l < r) {
                var f = --r,
                c = t[f],
                h = --n,
                p = t[h];
                i[c.uuid] = l,
                t[l] = c,
                i[p.uuid] = f,
                t[f] = p,
                t.pop(),
                c = 0;
                for (p = o; c !== p; ++c) {
                    var d = s[c],
                    v = d[h];
                    d[l] = d[f],
                    d[f] = v,
                    d.pop()
                }
            } else for (h = --n, p = t[h], i[p.uuid] = l, t[l] = p, t.pop(), c = 0, p = o; c !== p; ++c) d = s[c],
            d[l] = d[h],
            d.pop()
        }
        this.nCachedObjects_ = r
    },
    subscribe_: function(e, t) {
        var n = this._bindingsIndicesByPath,
        r = n[e],
        i = this._bindings;
        if (void 0 !== r) return i[r];
        var s = this._paths,
        o = this._parsedPaths,
        u = this._objects,
        a = this.nCachedObjects_,
        f = Array(u.length),
        r = i.length;
        n[e] = r,
        s.push(e),
        o.push(t),
        i.push(f),
        n = a;
        for (r = u.length; n !== r; ++n) f[n] = new THREE.PropertyBinding(u[n], e, t);
        return f
    },
    unsubscribe_: function(e) {
        var t = this._bindingsIndicesByPath,
        n = t[e];
        if (void 0 !== n) {
            var r = this._paths,
            i = this._parsedPaths,
            s = this._bindings,
            o = s.length - 1,
            u = s[o];
            t[e[o]] = n,
            s[n] = u,
            s.pop(),
            i[n] = i[o],
            i.pop(),
            r[n] = r[o],
            r.pop()
        }
    }
},
THREE.AnimationUtils = {
    arraySlice: function(e, t, n) {
        return THREE.AnimationUtils.isTypedArray(e) ? new e.constructor(e.subarray(t, n)) : e.slice(t, n)
    },
    convertArray: function(e, t, n) {
        return ! e || !n && e.constructor === t ? e: "number" == typeof t.BYTES_PER_ELEMENT ? new t(e) : Array.prototype.slice.call(e)
    },
    isTypedArray: function(e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView)
    },
    getKeyframeOrder: function(e) {
        for (var t = e.length,
        n = Array(t), r = 0; r !== t; ++r) n[r] = r;
        return n.sort(function(t, n) {
            return e[t] - e[n]
        }),
        n
    },
    sortedArray: function(e, t, n) {
        for (var r = e.length,
        i = new e.constructor(r), s = 0, o = 0; o !== r; ++s) for (var u = n[s] * t, a = 0; a !== t; ++a) i[o++] = e[u + a];
        return i
    },
    flattenJSON: function(e, t, n, r) {
        for (var i = 1,
        s = e[0]; void 0 !== s && void 0 === s[r];) s = e[i++];
        if (void 0 !== s) {
            var o = s[r];
            if (void 0 !== o) if (Array.isArray(o)) {
                do o = s[r],
                void 0 !== o && (t.push(s.time), n.push.apply(n, o)),
                s = e[i++];
                while (void 0 !== s)
            } else if (void 0 !== o.toArray) {
                do o = s[r],
                void 0 !== o && (t.push(s.time), o.toArray(n, n.length)),
                s = e[i++];
                while (void 0 !== s)
            } else do o = s[r],
            void 0 !== o && (t.push(s.time), n.push(o)),
            s = e[i++];
            while (void 0 !== s)
        }
    }
},
THREE.KeyframeTrack = function(e, t, n, r) {
    if (void 0 === e) throw Error("track name is undefined");
    if (void 0 === t || 0 === t.length) throw Error("no keyframes in track named " + e);
    this.name = e,
    this.times = THREE.AnimationUtils.convertArray(t, this.TimeBufferType),
    this.values = THREE.AnimationUtils.convertArray(n, this.ValueBufferType),
    this.setInterpolation(r || this.DefaultInterpolation),
    this.validate(),
    this.optimize()
},
THREE.KeyframeTrack.prototype = {
    constructor: THREE.KeyframeTrack,
    TimeBufferType: Float32Array,
    ValueBufferType: Float32Array,
    DefaultInterpolation: THREE.InterpolateLinear,
    InterpolantFactoryMethodDiscrete: function(e) {
        return new THREE.DiscreteInterpolant(this.times, this.values, this.getValueSize(), e)
    },
    InterpolantFactoryMethodLinear: function(e) {
        return new THREE.LinearInterpolant(this.times, this.values, this.getValueSize(), e)
    },
    InterpolantFactoryMethodSmooth: function(e) {
        return new THREE.CubicInterpolant(this.times, this.values, this.getValueSize(), e)
    },
    setInterpolation: function(e) {
        var t = void 0;
        switch (e) {
        case THREE.InterpolateDiscrete:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case THREE.InterpolateLinear:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case THREE.InterpolateSmooth:
            t = this.InterpolantFactoryMethodSmooth
        }
        if (void 0 === t) {
            t = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (void 0 === this.createInterpolant) {
                if (e === this.DefaultInterpolation) throw Error(t);
                this.setInterpolation(this.DefaultInterpolation)
            }
            console.warn(t)
        } else this.createInterpolant = t
    },
    getInterpolation: function() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return THREE.InterpolateDiscrete;
        case this.InterpolantFactoryMethodLinear:
            return THREE.InterpolateLinear;
        case this.InterpolantFactoryMethodSmooth:
            return THREE.InterpolateSmooth
        }
    },
    getValueSize: function() {
        return this.values.length / this.times.length
    },
    shift: function(e) {
        if (0 !== e) for (var t = this.times,
        n = 0,
        r = t.length; n !== r; ++n) t[n] += e;
        return this
    },
    scale: function(e) {
        if (1 !== e) for (var t = this.times,
        n = 0,
        r = t.length; n !== r; ++n) t[n] *= e;
        return this
    },
    trim: function(e, t) {
        for (var n = this.times,
        r = n.length,
        i = 0,
        s = r - 1; i !== r && n[i] < e;)++i;
        for (; - 1 !== s && n[s] > t;)--s; ++s;
        if (0 !== i || s !== r) i >= s && (s = Math.max(s, 1), i = s - 1),
        r = this.getValueSize(),
        this.times = THREE.AnimationUtils.arraySlice(n, i, s),
        this.values = THREE.AnimationUtils.arraySlice(this.values, i * r, s * r);
        return this
    },
    validate: function() {
        var e = !0,
        t = this.getValueSize();
        0 !== t - Math.floor(t) && (console.error("invalid value size in track", this), e = !1);
        var n = this.times,
        t = this.values,
        r = n.length;
        0 === r && (console.error("track is empty", this), e = !1);
        for (var i = null,
        s = 0; s !== r; s++) {
            var o = n[s];
            if ("number" == typeof o && isNaN(o)) {
                console.error("time is not a valid number", this, s, o),
                e = !1;
                break
            }
            if (null !== i && i > o) {
                console.error("out of order keys", this, s, o, i),
                e = !1;
                break
            }
            i = o
        }
        if (void 0 !== t && THREE.AnimationUtils.isTypedArray(t)) for (s = 0, n = t.length; s !== n; ++s) if (r = t[s], isNaN(r)) {
            console.error("value is not a valid number", this, s, r),
            e = !1;
            break
        }
        return e
    },
    optimize: function() {
        for (var e = this.times,
        t = this.values,
        n = this.getValueSize(), r = 1, i = 1, s = e.length - 1; i <= s; ++i) {
            var o = !1,
            u = e[i];
            if (u !== e[i + 1] && (1 !== i || u !== u[0])) for (var a = i * n,
            f = a - n,
            l = a + n,
            u = 0; u !== n; ++u) {
                var c = t[a + u];
                if (c !== t[f + u] || c !== t[l + u]) {
                    o = !0;
                    break
                }
            }
            if (o) {
                if (i !== r) for (e[r] = e[i], o = i * n, a = r * n, u = 0; u !== n; ++u) t[a + u] = t[o + u]; ++r
            }
        }
        return r !== e.length && (this.times = THREE.AnimationUtils.arraySlice(e, 0, r), this.values = THREE.AnimationUtils.arraySlice(t, 0, r * n)),
        this
    }
},
Object.assign(THREE.KeyframeTrack, {
    parse: function(e) {
        if (void 0 === e.type) throw Error("track type undefined, can not parse");
        var t = THREE.KeyframeTrack._getTrackTypeForValueTypeName(e.type);
        if (void 0 === e.times) {
            console.warn("legacy JSON format detected, converting");
            var n = [],
            r = [];
            THREE.AnimationUtils.flattenJSON(e.keys, n, r, "value"),
            e.times = n,
            e.values = r
        }
        return void 0 !== t.parse ? t.parse(e) : new t(e.name, e.times, e.values, e.interpolation)
    },
    toJSON: function(e) {
        var t = e.constructor;
        if (void 0 !== t.toJSON) t = t.toJSON(e);
        else {
            var t = {
                name: e.name,
                times: THREE.AnimationUtils.convertArray(e.times, Array),
                values: THREE.AnimationUtils.convertArray(e.values, Array)
            },
            n = e.getInterpolation();
            n !== e.DefaultInterpolation && (t.interpolation = n)
        }
        return t.type = e.ValueTypeName,
        t
    },
    _getTrackTypeForValueTypeName: function(e) {
        switch (e.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return THREE.NumberKeyframeTrack;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return THREE.VectorKeyframeTrack;
        case "color":
            return THREE.ColorKeyframeTrack;
        case "quaternion":
            return THREE.QuaternionKeyframeTrack;
        case "bool":
        case "boolean":
            return THREE.BooleanKeyframeTrack;
        case "string":
            return THREE.StringKeyframeTrack
        }
        throw Error("Unsupported typeName: " + e)
    }
}),
THREE.PropertyBinding = function(e, t, n) {
    this.path = t,
    this.parsedPath = n || THREE.PropertyBinding.parseTrackName(t),
    this.node = THREE.PropertyBinding.findNode(e, this.parsedPath.nodeName) || e,
    this.rootNode = e
},
THREE.PropertyBinding.prototype = {
    constructor: THREE.PropertyBinding,
    getValue: function(e, t) {
        this.bind(),
        this.getValue(e, t)
    },
    setValue: function(e, t) {
        this.bind(),
        this.setValue(e, t)
    },
    bind: function() {
        var e = this.node,
        t = this.parsedPath,
        n = t.objectName,
        r = t.propertyName,
        i = t.propertyIndex;
        e || (this.node = e = THREE.PropertyBinding.findNode(this.rootNode, t.nodeName) || this.rootNode),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable;
        if (e) {
            if (n) {
                var s = t.objectIndex;
                switch (n) {
                case "materials":
                    if (!e.material) {
                        console.error("  can not bind to material as node does not have a material", this);
                        return
                    }
                    if (!e.material.materials) {
                        console.error("  can not bind to material.materials as node.material does not have a materials array", this);
                        return
                    }
                    e = e.material.materials;
                    break;
                case "bones":
                    if (!e.skeleton) {
                        console.error("  can not bind to bones as node does not have a skeleton", this);
                        return
                    }
                    e = e.skeleton.bones;
                    for (n = 0; n < e.length; n++) if (e[n].name === s) {
                        s = n;
                        break
                    }
                    break;
                default:
                    if (void 0 === e[n]) {
                        console.error("  can not bind to objectName of node, undefined", this);
                        return
                    }
                    e = e[n]
                }
                if (void 0 !== s) {
                    if (void 0 === e[s]) {
                        console.error("  trying to bind to objectIndex of objectName, but is undefined:", this, e);
                        return
                    }
                    e = e[s]
                }
            }
            if (s = e[r]) {
                t = this.Versioning.None,
                void 0 !== e.needsUpdate ? (t = this.Versioning.NeedsUpdate, this.targetObject = e) : void 0 !== e.matrixWorldNeedsUpdate && (t = this.Versioning.MatrixWorldNeedsUpdate, this.targetObject = e),
                n = this.BindingType.Direct;
                if (void 0 !== i) {
                    if ("morphTargetInfluences" === r) {
                        if (!e.geometry) {
                            console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry", this);
                            return
                        }
                        if (!e.geometry.morphTargets) {
                            console.error("  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets", this);
                            return
                        }
                        for (n = 0; n < this.node.geometry.morphTargets.length; n++) if (e.geometry.morphTargets[n].name === i) {
                            i = n;
                            break
                        }
                    }
                    n = this.BindingType.ArrayElement,
                    this.resolvedProperty = s,
                    this.propertyIndex = i
                } else void 0 !== s.fromArray && void 0 !== s.toArray ? (n = this.BindingType.HasFromToArray, this.resolvedProperty = s) : void 0 !== s.length ? (n = this.BindingType.EntireArray, this.resolvedProperty = s) : this.propertyName = r;
                this.getValue = this.GetterByBindingType[n],
                this.setValue = this.SetterByBindingTypeAndVersioning[n][t]
            } else console.error("  trying to update property for track: " + t.nodeName + "." + r + " but it wasn't found.", e)
        } else console.error("  trying to update node for track: " + this.path + " but it wasn't found.")
    },
    unbind: function() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
},
Object.assign(THREE.PropertyBinding.prototype, {
    _getValue_unavailable: function() {},
    _setValue_unavailable: function() {},
    _getValue_unbound: THREE.PropertyBinding.prototype.getValue,
    _setValue_unbound: THREE.PropertyBinding.prototype.setValue,
    BindingType: {
        Direct: 0,
        EntireArray: 1,
        ArrayElement: 2,
        HasFromToArray: 3
    },
    Versioning: {
        None: 0,
        NeedsUpdate: 1,
        MatrixWorldNeedsUpdate: 2
    },
    GetterByBindingType: [function(e, t) {
        e[t] = this.node[this.propertyName]
    },
    function(e, t) {
        for (var n = this.resolvedProperty,
        r = 0,
        i = n.length; r !== i; ++r) e[t++] = n[r]
    },
    function(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    },
    function(e, t) {
        this.resolvedProperty.toArray(e, t)
    }],
    SetterByBindingTypeAndVersioning: [[function(e, t) {
        this.node[this.propertyName] = e[t]
    },
    function(e, t) {
        this.node[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    },
    function(e, t) {
        this.node[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }], [function(e, t) {
        for (var n = this.resolvedProperty,
        r = 0,
        i = n.length; r !== i; ++r) n[r] = e[t++]
    },
    function(e, t) {
        for (var n = this.resolvedProperty,
        r = 0,
        i = n.length; r !== i; ++r) n[r] = e[t++];
        this.targetObject.needsUpdate = !0
    },
    function(e, t) {
        for (var n = this.resolvedProperty,
        r = 0,
        i = n.length; r !== i; ++r) n[r] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }], [function(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    },
    function(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    },
    function(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }], [function(e, t) {
        this.resolvedProperty.fromArray(e, t)
    },
    function(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    },
    function(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }]]
}),
THREE.PropertyBinding.Composite = function(e, t, n) {
    n = n || THREE.PropertyBinding.parseTrackName(t),
    this._targetGroup = e,
    this._bindings = e.subscribe_(t, n)
},
THREE.PropertyBinding.Composite.prototype = {
    constructor: THREE.PropertyBinding.Composite,
    getValue: function(e, t) {
        this.bind();
        var n = this._bindings[this._targetGroup.nCachedObjects_];
        void 0 !== n && n.getValue(e, t)
    },
    setValue: function(e, t) {
        for (var n = this._bindings,
        r = this._targetGroup.nCachedObjects_,
        i = n.length; r !== i; ++r) n[r].setValue(e, t)
    },
    bind: function() {
        for (var e = this._bindings,
        t = this._targetGroup.nCachedObjects_,
        n = e.length; t !== n; ++t) e[t].bind()
    },
    unbind: function() {
        for (var e = this._bindings,
        t = this._targetGroup.nCachedObjects_,
        n = e.length; t !== n; ++t) e[t].unbind()
    }
},
THREE.PropertyBinding.create = function(e, t, n) {
    return e instanceof THREE.AnimationObjectGroup ? new THREE.PropertyBinding.Composite(e, t, n) : new THREE.PropertyBinding(e, t, n)
},
THREE.PropertyBinding.parseTrackName = function(e) {
    var t = /^(([\w]+\/)*)([\w-\d]+)?(\.([\w]+)(\[([\w\d\[\]\_.:\- ]+)\])?)?(\.([\w.]+)(\[([\w\d\[\]\_. ]+)\])?)$/,
    n = t.exec(e);
    if (!n) throw Error("cannot parse trackName at all: " + e);
    n.index === t.lastIndex && t.lastIndex++,
    t = {
        nodeName: n[3],
        objectName: n[5],
        objectIndex: n[7],
        propertyName: n[9],
        propertyIndex: n[11]
    };
    if (null === t.propertyName || 0 === t.propertyName.length) throw Error("can not parse propertyName from trackName: " + e);
    return t
},
THREE.PropertyBinding.findNode = function(e, t) {
    if (!t || "" === t || "root" === t || "." === t || -1 === t || t === e.name || t === e.uuid) return e;
    if (e.skeleton) {
        var n = function(e) {
            for (var n = 0; n < e.bones.length; n++) {
                var r = e.bones[n];
                if (r.name === t) return r
            }
            return null
        } (e.skeleton);
        if (n) return n
    }
    if (e.children) {
        var r = function(e) {
            for (var n = 0; n < e.length; n++) {
                var i = e[n];
                if (i.name === t || i.uuid === t || (i = r(i.children))) return i
            }
            return null
        };
        if (n = r(e.children)) return n
    }
    return null
},
THREE.PropertyMixer = function(e, t, n) {
    this.binding = e,
    this.valueSize = n,
    e = Float64Array;
    switch (t) {
    case "quaternion":
        t = this._slerp;
        break;
    case "string":
    case "bool":
        e = Array,
        t = this._select;
        break;
    default:
        t = this._lerp
    }
    this.buffer = new e(4 * n),
    this._mixBufferRegion = t,
    this.referenceCount = this.useCount = this.cumulativeWeight = 0
},
THREE.PropertyMixer.prototype = {
    constructor: THREE.PropertyMixer,
    accumulate: function(e, t) {
        var n = this.buffer,
        r = this.valueSize,
        i = e * r + r,
        s = this.cumulativeWeight;
        if (0 === s) {
            for (s = 0; s !== r; ++s) n[i + s] = n[s];
            s = t
        } else s += t,
        this._mixBufferRegion(n, i, 0, t / s, r);
        this.cumulativeWeight = s
    },
    apply: function(e) {
        var t = this.valueSize,
        n = this.buffer;
        e = e * t + t;
        var r = this.cumulativeWeight,
        i = this.binding;
        this.cumulativeWeight = 0,
        1 > r && this._mixBufferRegion(n, e, 3 * t, 1 - r, t);
        for (var r = t,
        s = t + t; r !== s; ++r) if (n[r] !== n[r + t]) {
            i.setValue(n, e);
            break
        }
    },
    saveOriginalState: function() {
        var e = this.buffer,
        t = this.valueSize,
        n = 3 * t;
        this.binding.getValue(e, n);
        for (var r = t; r !== n; ++r) e[r] = e[n + r % t];
        this.cumulativeWeight = 0
    },
    restoreOriginalState: function() {
        this.binding.setValue(this.buffer, 3 * this.valueSize)
    },
    _select: function(e, t, n, r, i) {
        if (.5 <= r) for (r = 0; r !== i; ++r) e[t + r] = e[n + r]
    },
    _slerp: function(e, t, n, r, i) {
        THREE.Quaternion.slerpFlat(e, t, e, t, e, n, r)
    },
    _lerp: function(e, t, n, r, i) {
        for (var s = 1 - r,
        o = 0; o !== i; ++o) {
            var u = t + o;
            e[u] = e[u] * s + e[n + o] * r
        }
    }
},
THREE.BooleanKeyframeTrack = function(e, t, n) {
    THREE.KeyframeTrack.call(this, e, t, n)
},
THREE.BooleanKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.BooleanKeyframeTrack,
    ValueTypeName: "bool",
    ValueBufferType: Array,
    DefaultInterpolation: THREE.IntepolateDiscrete,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
}),
THREE.NumberKeyframeTrack = function(e, t, n, r) {
    THREE.KeyframeTrack.call(this, e, t, n, r)
},
THREE.NumberKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.NumberKeyframeTrack,
    ValueTypeName: "number"
}),
THREE.QuaternionKeyframeTrack = function(e, t, n, r) {
    THREE.KeyframeTrack.call(this, e, t, n, r)
},
THREE.QuaternionKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.QuaternionKeyframeTrack,
    ValueTypeName: "quaternion",
    DefaultInterpolation: THREE.InterpolateLinear,
    InterpolantFactoryMethodLinear: function(e) {
        return new THREE.QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), e)
    },
    InterpolantFactoryMethodSmooth: void 0
}),
THREE.StringKeyframeTrack = function(e, t, n, r) {
    THREE.KeyframeTrack.call(this, e, t, n, r)
},
THREE.StringKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.StringKeyframeTrack,
    ValueTypeName: "string",
    ValueBufferType: Array,
    DefaultInterpolation: THREE.IntepolateDiscrete,
    InterpolantFactoryMethodLinear: void 0,
    InterpolantFactoryMethodSmooth: void 0
}),
THREE.VectorKeyframeTrack = function(e, t, n, r) {
    THREE.KeyframeTrack.call(this, e, t, n, r)
},
THREE.VectorKeyframeTrack.prototype = Object.assign(Object.create(THREE.KeyframeTrack.prototype), {
    constructor: THREE.VectorKeyframeTrack,
    ValueTypeName: "vector"
}),
THREE.Audio = function(e) {
    THREE.Object3D.call(this),
    this.type = "Audio",
    this.context = e.context,
    this.source = this.context.createBufferSource(),
    this.source.onended = this.onEnded.bind(this),
    this.gain = this.context.createGain(),
    this.gain.connect(e.getInput()),
    this.autoplay = !1,
    this.startTime = 0,
    this.playbackRate = 1,
    this.isPlaying = !1,
    this.hasPlaybackControl = !0,
    this.sourceType = "empty",
    this.filter = null
},
THREE.Audio.prototype = Object.create(THREE.Object3D.prototype),
THREE.Audio.prototype.constructor = THREE.Audio,
THREE.Audio.prototype.getOutput = function() {
    return this.gain
},
THREE.Audio.prototype.load = function(e) {
    var t = new THREE.AudioBuffer(this.context);
    return t.load(e),
    this.setBuffer(t),
    this
},
THREE.Audio.prototype.setNodeSource = function(e) {
    return this.hasPlaybackControl = !1,
    this.sourceType = "audioNode",
    this.source = e,
    this.connect(),
    this
},
THREE.Audio.prototype.setBuffer = function(e) {
    var t = this;
    return e.onReady(function(e) {
        t.source.buffer = e,
        t.sourceType = "buffer",
        t.autoplay && t.play()
    }),
    this
},
THREE.Audio.prototype.play = function() {
    if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing.");
    else if (!1 === this.hasPlaybackControl) console.warn("THREE.Audio: this Audio has no playback control.");
    else {
        var e = this.context.createBufferSource();
        e.buffer = this.source.buffer,
        e.loop = this.source.loop,
        e.onended = this.source.onended,
        e.start(0, this.startTime),
        e.playbackRate.value = this.playbackRate,
        this.isPlaying = !0,
        this.source = e,
        this.connect()
    }
},
THREE.Audio.prototype.pause = function() { ! 1 === this.hasPlaybackControl ? console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), this.startTime = this.context.currentTime)
},
THREE.Audio.prototype.stop = function() { ! 1 === this.hasPlaybackControl ? console.warn("THREE.Audio: this Audio has no playback control.") : (this.source.stop(), this.startTime = 0)
},
THREE.Audio.prototype.connect = function() {
    null !== this.filter ? (this.source.connect(this.filter), this.filter.connect(this.getOutput())) : this.source.connect(this.getOutput())
},
THREE.Audio.prototype.disconnect = function() {
    null !== this.filter ? (this.source.disconnect(this.filter), this.filter.disconnect(this.getOutput())) : this.source.disconnect(this.getOutput())
},
THREE.Audio.prototype.getFilter = function() {
    return this.filter
},
THREE.Audio.prototype.setFilter = function(e) {
    void 0 === e && (e = null),
    !0 === this.isPlaying ? (this.disconnect(), this.filter = e, this.connect()) : this.filter = e
},
THREE.Audio.prototype.setPlaybackRate = function(e) { ! 1 === this.hasPlaybackControl ? console.warn("THREE.Audio: this Audio has no playback control.") : (this.playbackRate = e, !0 === this.isPlaying && (this.source.playbackRate.value = this.playbackRate))
},
THREE.Audio.prototype.getPlaybackRate = function() {
    return this.playbackRate
},
THREE.Audio.prototype.onEnded = function() {
    this.isPlaying = !1
},
THREE.Audio.prototype.setLoop = function(e) { ! 1 === this.hasPlaybackControl ? console.warn("THREE.Audio: this Audio has no playback control.") : this.source.loop = e
},
THREE.Audio.prototype.getLoop = function() {
    return ! 1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.source.loop
},
THREE.Audio.prototype.setVolume = function(e) {
    this.gain.gain.value = e
},
THREE.Audio.prototype.getVolume = function() {
    return this.gain.gain.value
},
THREE.AudioAnalyser = function(e, t) {
    this.analyser = e.context.createAnalyser(),
    this.analyser.fftSize = void 0 !== t ? t: 2048,
    this.data = new Uint8Array(this.analyser.frequencyBinCount),
    e.getOutput().connect(this.analyser)
},
THREE.AudioAnalyser.prototype = {
    constructor: THREE.AudioAnalyser,
    getData: function() {
        return this.analyser.getByteFrequencyData(this.data),
        this.data
    }
},
THREE.AudioBuffer = function(e) {
    this.context = e,
    this.ready = !1,
    this.readyCallbacks = []
},
THREE.AudioBuffer.prototype.load = function(e) {
    var t = this,
    n = new XMLHttpRequest;
    return n.open("GET", e, !0),
    n.responseType = "arraybuffer",
    n.onload = function(e) {
        t.context.decodeAudioData(this.response,
        function(e) {
            t.buffer = e,
            t.ready = !0;
            for (e = 0; e < t.readyCallbacks.length; e++) t.readyCallbacks[e](t.buffer);
            t.readyCallbacks = []
        })
    },
    n.send(),
    this
},
THREE.AudioBuffer.prototype.onReady = function(e) {
    this.ready ? e(this.buffer) : this.readyCallbacks.push(e)
},
THREE.PositionalAudio = function(e) {
    THREE.Audio.call(this, e),
    this.panner = this.context.createPanner(),
    this.panner.connect(this.gain)
},
THREE.PositionalAudio.prototype = Object.create(THREE.Audio.prototype),
THREE.PositionalAudio.prototype.constructor = THREE.PositionalAudio,
THREE.PositionalAudio.prototype.getOutput = function() {
    return this.panner
},
THREE.PositionalAudio.prototype.setRefDistance = function(e) {
    this.panner.refDistance = e
},
THREE.PositionalAudio.prototype.getRefDistance = function() {
    return this.panner.refDistance
},
THREE.PositionalAudio.prototype.setRolloffFactor = function(e) {
    this.panner.rolloffFactor = e
},
THREE.PositionalAudio.prototype.getRolloffFactor = function() {
    return this.panner.rolloffFactor
},
THREE.PositionalAudio.prototype.setDistanceModel = function(e) {
    this.panner.distanceModel = e
},
THREE.PositionalAudio.prototype.getDistanceModel = function() {
    return this.panner.distanceModel
},
THREE.PositionalAudio.prototype.setMaxDistance = function(e) {
    this.panner.maxDistance = e
},
THREE.PositionalAudio.prototype.getMaxDistance = function() {
    return this.panner.maxDistance
},
THREE.PositionalAudio.prototype.updateMatrixWorld = function() {
    var e = new THREE.Vector3;
    return function(t) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, t),
        e.setFromMatrixPosition(this.matrixWorld),
        this.panner.setPosition(e.x, e.y, e.z)
    }
} (),
THREE.AudioListener = function() {
    THREE.Object3D.call(this),
    this.type = "AudioListener",
    this.context = new(window.AudioContext || window.webkitAudioContext),
    this.gain = this.context.createGain(),
    this.gain.connect(this.context.destination),
    this.filter = null
},
THREE.AudioListener.prototype = Object.create(THREE.Object3D.prototype),
THREE.AudioListener.prototype.constructor = THREE.AudioListener,
THREE.AudioListener.prototype.getInput = function() {
    return this.gain
},
THREE.AudioListener.prototype.removeFilter = function() {
    null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null)
},
THREE.AudioListener.prototype.setFilter = function(e) {
    null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination),
    this.filter = e,
    this.gain.connect(this.filter),
    this.filter.connect(this.context.destination)
},
THREE.AudioListener.prototype.getFilter = function() {
    return this.filter
},
THREE.AudioListener.prototype.setMasterVolume = function(e) {
    this.gain.gain.value = e
},
THREE.AudioListener.prototype.getMasterVolume = function() {
    return this.gain.gain.value
},
THREE.AudioListener.prototype.updateMatrixWorld = function() {
    var e = new THREE.Vector3,
    t = new THREE.Quaternion,
    n = new THREE.Vector3,
    r = new THREE.Vector3;
    return function(i) {
        THREE.Object3D.prototype.updateMatrixWorld.call(this, i),
        i = this.context.listener;
        var s = this.up;
        this.matrixWorld.decompose(e, t, n),
        r.set(0, 0, -1).applyQuaternion(t),
        i.setPosition(e.x, e.y, e.z),
        i.setOrientation(r.x, r.y, r.z, s.x, s.y, s.z)
    }
} (),
THREE.Camera = function() {
    THREE.Object3D.call(this),
    this.type = "Camera",
    this.matrixWorldInverse = new THREE.Matrix4,
    this.projectionMatrix = new THREE.Matrix4
},
THREE.Camera.prototype = Object.create(THREE.Object3D.prototype),
THREE.Camera.prototype.constructor = THREE.Camera,
THREE.Camera.prototype.getWorldDirection = function() {
    var e = new THREE.Quaternion;
    return function(t) {
        return t = t || new THREE.Vector3,
        this.getWorldQuaternion(e),
        t.set(0, 0, -1).applyQuaternion(e)
    }
} (),
THREE.Camera.prototype.lookAt = function() {
    var e = new THREE.Matrix4;
    return function(t) {
        e.lookAt(this.position, t, this.up),
        this.quaternion.setFromRotationMatrix(e)
    }
} (),
THREE.Camera.prototype.clone = function() {
    return (new this.constructor).copy(this)
},
THREE.Camera.prototype.copy = function(e) {
    return THREE.Object3D.prototype.copy.call(this, e),
    this.matrixWorldInverse.copy(e.matrixWorldInverse),
    this.projectionMatrix.copy(e.projectionMatrix),
    this
},
THREE.CubeCamera = function(e, t, n) {
    THREE.Object3D.call(this),
    this.type = "CubeCamera";
    var r = new THREE.PerspectiveCamera(90, 1, e, t);
    r.up.set(0, -1, 0),
    r.lookAt(new THREE.Vector3(1, 0, 0)),
    this.add(r);
    var i = new THREE.PerspectiveCamera(90, 1, e, t);
    i.up.set(0, -1, 0),
    i.lookAt(new THREE.Vector3( - 1, 0, 0)),
    this.add(i);
    var s = new THREE.PerspectiveCamera(90, 1, e, t);
    s.up.set(0, 0, 1),
    s.lookAt(new THREE.Vector3(0, 1, 0)),
    this.add(s);
    var o = new THREE.PerspectiveCamera(90, 1, e, t);
    o.up.set(0, 0, -1),
    o.lookAt(new THREE.Vector3(0, -1, 0)),
    this.add(o);
    var u = new THREE.PerspectiveCamera(90, 1, e, t);
    u.up.set(0, -1, 0),
    u.lookAt(new THREE.Vector3(0, 0, 1)),
    this.add(u);
    var a = new THREE.PerspectiveCamera(90, 1, e, t);
    a.up.set(0, -1, 0),
    a.lookAt(new THREE.Vector3(0, 0, -1)),
    this.add(a),
    this.renderTarget = new THREE.WebGLRenderTargetCube(n, n, {
        format: THREE.RGBFormat,
        magFilter: THREE.LinearFilter,
        minFilter: THREE.LinearFilter
    }),
    this.updateCubeMap = function(e, t) {
        null === this.parent && this.updateMatrixWorld();
        var n = this.renderTarget,
        l = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1,
        n.activeCubeFace = 0,
        e.render(t, r, n),
        n.activeCubeFace = 1,
        e.render(t, i, n),
        n.activeCubeFace = 2,
        e.render(t, s, n),
        n.activeCubeFace = 3,
        e.render(t, o, n),
        n.activeCubeFace = 4,
        e.render(t, u, n),
        n.texture.generateMipmaps = l,
        n.activeCubeFace = 5,
        e.render(t, a, n),
        e.setRenderTarget(null)
    }
},
THREE.CubeCamera.prototype = Object.create(THREE.Object3D.prototype),
THREE.CubeCamera.prototype.constructor = THREE.CubeCamera,
THREE.OrthographicCamera = function(e, t, n, r, i, s) {
    THREE.Camera.call(this),
    this.type = "OrthographicCamera",
    this.zoom = 1,
    this.left = e,
    this.right = t,
    this.top = n,
    this.bottom = r,
    this.near = void 0 !== i ? i: .1,
    this.far = void 0 !== s ? s: 2e3,
    this.updateProjectionMatrix()
},
THREE.OrthographicCamera.prototype = Object.create(THREE.Camera.prototype),
THREE.OrthographicCamera.prototype.constructor = THREE.OrthographicCamera,
THREE.OrthographicCamera.prototype.updateProjectionMatrix = function() {
    var e = (this.right - this.left) / (2 * this.zoom),
    t = (this.top - this.bottom) / (2 * this.zoom),
    n = (this.right + this.left) / 2,
    r = (this.top + this.bottom) / 2;
    this.projectionMatrix.makeOrthographic(n - e, n + e, r + t, r - t, this.near, this.far)
},
THREE.OrthographicCamera.prototype.copy = function(e) {
    return THREE.Camera.prototype.copy.call(this, e),
    this.left = e.left,
    this.right = e.right,
    this.top = e.top,
    this.bottom = e.bottom,
    this.near = e.near,
    this.far = e.far,
    this.zoom = e.zoom,
    this
},
THREE.OrthographicCamera.prototype.toJSON = function(e) {
    return e = THREE.Object3D.prototype.toJSON.call(this, e),
    e.object.zoom = this.zoom,
    e.object.left = this.left,
    e.object.right = this.right,
    e.object.top = this.top,
    e.object.bottom = this.bottom,
    e.object.near = this.near,
    e.object.far = this.far,
    e
},
THREE.PerspectiveCamera = function(e, t, n, r) {
    THREE.Camera.call(this),
    this.type = "PerspectiveCamera",
    this.focalLength = 10,
    this.zoom = 1,
    this.fov = void 0 !== e ? e: 50,
    this.aspect = void 0 !== t ? t: 1,
    this.near = void 0 !== n ? n: .1,
    this.far = void 0 !== r ? r: 2e3,
    this.updateProjectionMatrix()
},
THREE.PerspectiveCamera.prototype = Object.create(THREE.Camera.prototype),
THREE.PerspectiveCamera.prototype.constructor = THREE.PerspectiveCamera,
THREE.PerspectiveCamera.prototype.setLens = function(e, t) {
    void 0 === t && (t = 24),
    this.fov = 2 * THREE.Math.radToDeg(Math.atan(t / (2 * e))),
    this.updateProjectionMatrix()
},
THREE.PerspectiveCamera.prototype.setViewOffset = function(e, t, n, r, i, s) {
    this.fullWidth = e,
    this.fullHeight = t,
    this.x = n,
    this.y = r,
    this.width = i,
    this.height = s,
    this.updateProjectionMatrix()
},
THREE.PerspectiveCamera.prototype.updateProjectionMatrix = function() {
    var e = THREE.Math.radToDeg(2 * Math.atan(Math.tan(.5 * THREE.Math.degToRad(this.fov)) / this.zoom));
    if (this.fullWidth) {
        var t = this.fullWidth / this.fullHeight,
        e = Math.tan(THREE.Math.degToRad(.5 * e)) * this.near,
        n = -e,
        r = t * n,
        t = Math.abs(t * e - r),
        n = Math.abs(e - n);
        this.projectionMatrix.makeFrustum(r + this.x * t / this.fullWidth, r + (this.x + this.width) * t / this.fullWidth, e - (this.y + this.height) * n / this.fullHeight, e - this.y * n / this.fullHeight, this.near, this.far)
    } else this.projectionMatrix.makePerspective(e, this.aspect, this.near, this.far)
},
THREE.PerspectiveCamera.prototype.copy = function(e) {
    return THREE.Camera.prototype.copy.call(this, e),
    this.focalLength = e.focalLength,
    this.zoom = e.zoom,
    this.fov = e.fov,
    this.aspect = e.aspect,
    this.near = e.near,
    this.far = e.far,
    this
},
THREE.PerspectiveCamera.prototype.toJSON = function(e) {
    return e = THREE.Object3D.prototype.toJSON.call(this, e),
    e.object.focalLength = this.focalLength,
    e.object.zoom = this.zoom,
    e.object.fov = this.fov,
    e.object.aspect = this.aspect,
    e.object.near = this.near,
    e.object.far = this.far,
    e
},
THREE.StereoCamera = function() {
    this.type = "StereoCamera",
    this.aspect = 1,
    this.cameraL = new THREE.PerspectiveCamera,
    this.cameraL.layers.enable(1),
    this.cameraL.matrixAutoUpdate = !1,
    this.cameraR = new THREE.PerspectiveCamera,
    this.cameraR.layers.enable(2),
    this.cameraR.matrixAutoUpdate = !1
},
THREE.StereoCamera.prototype = {
    constructor: THREE.StereoCamera,
    update: function() {
        var e, t, n, r, i, s = new THREE.Matrix4,
        o = new THREE.Matrix4;
        return function(u) {
            if (e !== u.focalLength || t !== u.fov || n !== u.aspect * this.aspect || r !== u.near || i !== u.far) {
                e = u.focalLength,
                t = u.fov,
                n = u.aspect * this.aspect,
                r = u.near,
                i = u.far;
                var l = u.projectionMatrix.clone(),
                h = .032 * r / e,
                p = r * Math.tan(THREE.Math.degToRad(.5 * t)),
                v,
                m;
                o.elements[12] = -0.032,
                s.elements[12] = .032,
                v = -p * n + h,
                m = p * n + h,
                l.elements[0] = 2 * r / (m - v),
                l.elements[8] = (m + v) / (m - v),
                this.cameraL.projectionMatrix.copy(l),
                v = -p * n - h,
                m = p * n - h,
                l.elements[0] = 2 * r / (m - v),
                l.elements[8] = (m + v) / (m - v),
                this.cameraR.projectionMatrix.copy(l)
            }
            this.cameraL.matrixWorld.copy(u.matrixWorld).multiply(o),
            this.cameraR.matrixWorld.copy(u.matrixWorld).multiply(s)
        }
    } ()
},
THREE.Light = function(e, t) {
    THREE.Object3D.call(this),
    this.type = "Light",
    this.color = new THREE.Color(e),
    this.intensity = void 0 !== t ? t: 1,
    this.receiveShadow = void 0
},
THREE.Light.prototype = Object.create(THREE.Object3D.prototype),
THREE.Light.prototype.constructor = THREE.Light,
THREE.Light.prototype.copy = function(e) {
    return THREE.Object3D.prototype.copy.call(this, e),
    this.color.copy(e.color),
    this.intensity = e.intensity,
    this
},
THREE.Light.prototype.toJSON = function(e) {
    return e = THREE.Object3D.prototype.toJSON.call(this, e),
    e.object.color = this.color.getHex(),
    e.object.intensity = this.intensity,
    void 0 !== this.groundColor && (e.object.groundColor = this.groundColor.getHex()),
    void 0 !== this.distance && (e.object.distance = this.distance),
    void 0 !== this.angle && (e.object.angle = this.angle),
    void 0 !== this.decay && (e.object.decay = this.decay),
    void 0 !== this.penumbra && (e.object.penumbra = this.penumbra),
    e
},
THREE.LightShadow = function(e) {
    this.camera = e,
    this.bias = 0,
    this.radius = 1,
    this.mapSize = new THREE.Vector2(512, 512),
    this.map = null,
    this.matrix = new THREE.Matrix4
},
THREE.LightShadow.prototype = {
    constructor: THREE.LightShadow,
    copy: function(e) {
        return this.camera = e.camera.clone(),
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    },
    clone: function() {
        return (new this.constructor).copy(this)
    }
},
THREE.AmbientLight = function(e, t) {
    THREE.Light.call(this, e, t),
    this.type = "AmbientLight",
    this.castShadow = void 0
},
THREE.AmbientLight.prototype = Object.create(THREE.Light.prototype),
THREE.AmbientLight.prototype.constructor = THREE.AmbientLight,
THREE.DirectionalLight = function(e, t) {
    THREE.Light.call(this, e, t),
    this.type = "DirectionalLight",
    this.position.set(0, 1, 0),
    this.updateMatrix(),
    this.target = new THREE.Object3D,
    this.shadow = new THREE.LightShadow(new THREE.OrthographicCamera( - 5, 5, 5, -5, .5, 500))
},
THREE.DirectionalLight.prototype = Object.create(THREE.Light.prototype),
THREE.DirectionalLight.prototype.constructor = THREE.DirectionalLight,
THREE.DirectionalLight.prototype.copy = function(e) {
    return THREE.Light.prototype.copy.call(this, e),
    this.target = e.target.clone(),
    this.shadow = e.shadow.clone(),
    this
},
THREE.HemisphereLight = function(e, t, n) {
    THREE.Light.call(this, e, n),
    this.type = "HemisphereLight",
    this.castShadow = void 0,
    this.position.set(0, 1, 0),
    this.updateMatrix(),
    this.groundColor = new THREE.Color(t)
},
THREE.HemisphereLight.prototype = Object.create(THREE.Light.prototype),
THREE.HemisphereLight.prototype.constructor = THREE.HemisphereLight,
THREE.HemisphereLight.prototype.copy = function(e) {
    return THREE.Light.prototype.copy.call(this, e),
    this.groundColor.copy(e.groundColor),
    this
},
THREE.PointLight = function(e, t, n, r) {
    THREE.Light.call(this, e, t),
    this.type = "PointLight",
    this.distance = void 0 !== n ? n: 0,
    this.decay = void 0 !== r ? r: 1,
    this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(90, 1, .5, 500))
},
THREE.PointLight.prototype = Object.create(THREE.Light.prototype),
THREE.PointLight.prototype.constructor = THREE.PointLight,
Object.defineProperty(THREE.PointLight.prototype, "power", {
    get: function() {
        return 4 * this.intensity * Math.PI
    },
    set: function(e) {
        this.intensity = e / (4 * Math.PI)
    }
}),
THREE.PointLight.prototype.copy = function(e) {
    return THREE.Light.prototype.copy.call(this, e),
    this.distance = e.distance,
    this.decay = e.decay,
    this.shadow = e.shadow.clone(),
    this
},
THREE.SpotLight = function(e, t, n, r, i, s) {
    THREE.Light.call(this, e, t),
    this.type = "SpotLight",
    this.position.set(0, 1, 0),
    this.updateMatrix(),
    this.target = new THREE.Object3D,
    this.distance = void 0 !== n ? n: 0,
    this.angle = void 0 !== r ? r: Math.PI / 3,
    this.penumbra = void 0 !== i ? i: 0,
    this.decay = void 0 !== s ? s: 1,
    this.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(50, 1, .5, 500))
},
THREE.SpotLight.prototype = Object.create(THREE.Light.prototype),
THREE.SpotLight.prototype.constructor = THREE.SpotLight,
Object.defineProperty(THREE.SpotLight.prototype, "power", {
    get: function() {
        return this.intensity * Math.PI
    },
    set: function(e) {
        this.intensity = e / Math.PI
    }
}),
THREE.SpotLight.prototype.copy = function(e) {
    return THREE.Light.prototype.copy.call(this, e),
    this.distance = e.distance,
    this.angle = e.angle,
    this.penumbra = e.penumbra,
    this.decay = e.decay,
    this.target = e.target.clone(),
    this.shadow = e.shadow.clone(),
    this
},
THREE.Cache = {
    enabled: !1,
    files: {},
    add: function(e, t) { ! 1 !== this.enabled && (this.files[e] = t)
    },
    get: function(e) {
        if (!1 !== this.enabled) return this.files[e]
    },
    remove: function(e) {
        delete this.files[e]
    },
    clear: function() {
        this.files = {}
    }
},
THREE.Loader = function() {
    this.onLoadStart = function() {},
    this.onLoadProgress = function() {},
    this.onLoadComplete = function() {}
},
THREE.Loader.prototype = {
    constructor: THREE.Loader,
    crossOrigin: void 0,
    extractUrlBase: function(e) {
        return e = e.split("/"),
        1 === e.length ? "./": (e.pop(), e.join("/") + "/")
    },
    initMaterials: function(e, t, n) {
        for (var r = [], i = 0; i < e.length; ++i) r[i] = this.createMaterial(e[i], t, n);
        return r
    },
    createMaterial: function() {
        var e, t, n;
        return function(r, i, s) {
            function o(e, n, r, o, a) {
                e = i + e;
                var f = THREE.Loader.Handlers.get(e);
                return null !== f ? e = f.load(e) : (t.setCrossOrigin(s), e = t.load(e)),
                void 0 !== n && (e.repeat.fromArray(n), 1 !== n[0] && (e.wrapS = THREE.RepeatWrapping), 1 !== n[1] && (e.wrapT = THREE.RepeatWrapping)),
                void 0 !== r && e.offset.fromArray(r),
                void 0 !== o && ("repeat" === o[0] && (e.wrapS = THREE.RepeatWrapping), "mirror" === o[0] && (e.wrapS = THREE.MirroredRepeatWrapping), "repeat" === o[1] && (e.wrapT = THREE.RepeatWrapping), "mirror" === o[1] && (e.wrapT = THREE.MirroredRepeatWrapping)),
                void 0 !== a && (e.anisotropy = a),
                n = THREE.Math.generateUUID(),
                u[n] = e,
                n
            }
            void 0 === e && (e = new THREE.Color),
            void 0 === t && (t = new THREE.TextureLoader),
            void 0 === n && (n = new THREE.MaterialLoader);
            var u = {},
            f = {
                uuid: THREE.Math.generateUUID(),
                type: "MeshLambertMaterial"
            },
            l;
            for (l in r) {
                var h = r[l];
                switch (l) {
                case "DbgColor":
                case "DbgIndex":
                case "opticalDensity":
                case "illumination":
                    break;
                case "DbgName":
                    f.name = h;
                    break;
                case "blending":
                    f.blending = THREE[h];
                    break;
                case "colorAmbient":
                case "mapAmbient":
                    console.warn("THREE.Loader.createMaterial:", l, "is no longer supported.");
                    break;
                case "colorDiffuse":
                    f.color = e.fromArray(h).getHex();
                    break;
                case "colorSpecular":
                    f.specular = e.fromArray(h).getHex();
                    break;
                case "colorEmissive":
                    f.emissive = e.fromArray(h).getHex();
                    break;
                case "specularCoef":
                    f.shininess = h;
                    break;
                case "shading":
                    "basic" === h.toLowerCase() && (f.type = "MeshBasicMaterial"),
                    "phong" === h.toLowerCase() && (f.type = "MeshPhongMaterial");
                    break;
                case "mapDiffuse":
                    f.map = o(h, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                    break;
                case "mapDiffuseRepeat":
                case "mapDiffuseOffset":
                case "mapDiffuseWrap":
                case "mapDiffuseAnisotropy":
                    break;
                case "mapLight":
                    f.lightMap = o(h, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                    break;
                case "mapLightRepeat":
                case "mapLightOffset":
                case "mapLightWrap":
                case "mapLightAnisotropy":
                    break;
                case "mapAO":
                    f.aoMap = o(h, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                    break;
                case "mapAORepeat":
                case "mapAOOffset":
                case "mapAOWrap":
                case "mapAOAnisotropy":
                    break;
                case "mapBump":
                    f.bumpMap = o(h, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                    break;
                case "mapBumpScale":
                    f.bumpScale = h;
                    break;
                case "mapBumpRepeat":
                case "mapBumpOffset":
                case "mapBumpWrap":
                case "mapBumpAnisotropy":
                    break;
                case "mapNormal":
                    f.normalMap = o(h, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                    break;
                case "mapNormalFactor":
                    f.normalScale = [h, h];
                    break;
                case "mapNormalRepeat":
                case "mapNormalOffset":
                case "mapNormalWrap":
                case "mapNormalAnisotropy":
                    break;
                case "mapSpecular":
                    f.specularMap = o(h, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                    break;
                case "mapSpecularRepeat":
                case "mapSpecularOffset":
                case "mapSpecularWrap":
                case "mapSpecularAnisotropy":
                    break;
                case "mapAlpha":
                    f.alphaMap = o(h, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                    break;
                case "mapAlphaRepeat":
                case "mapAlphaOffset":
                case "mapAlphaWrap":
                case "mapAlphaAnisotropy":
                    break;
                case "flipSided":
                    f.side = THREE.BackSide;
                    break;
                case "doubleSided":
                    f.side = THREE.DoubleSide;
                    break;
                case "transparency":
                    console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"),
                    f.opacity = h;
                    break;
                case "depthTest":
                case "depthWrite":
                case "colorWrite":
                case "opacity":
                case "reflectivity":
                case "transparent":
                case "visible":
                case "wireframe":
                    f[l] = h;
                    break;
                case "vertexColors":
                    !0 === h && (f.vertexColors = THREE.VertexColors),
                    "face" === h && (f.vertexColors = THREE.FaceColors);
                    break;
                default:
                    console.error("THREE.Loader.createMaterial: Unsupported", l, h)
                }
            }
            return "MeshBasicMaterial" === f.type && delete f.emissive,
            "MeshPhongMaterial" !== f.type && delete f.specular,
            1 > f.opacity && (f.transparent = !0),
            n.setTextures(u),
            n.parse(f)
        }
    } ()
},
THREE.Loader.Handlers = {
    handlers: [],
    add: function(e, t) {
        this.handlers.push(e, t)
    },
    get: function(e) {
        for (var t = this.handlers,
        n = 0,
        r = t.length; n < r; n += 2) {
            var i = t[n + 1];
            if (t[n].test(e)) return i
        }
        return null
    }
},
THREE.XHRLoader = function(e) {
    this.manager = void 0 !== e ? e: THREE.DefaultLoadingManager
},
THREE.XHRLoader.prototype = {
    constructor: THREE.XHRLoader,
    load: function(e, t, n, r) {
        void 0 !== this.path && (e = this.path + e);
        var i = this,
        s = THREE.Cache.get(e);
        if (void 0 !== s) return t && setTimeout(function() {
            t(s)
        },
        0),
        s;
        var o = new XMLHttpRequest;
        return o.overrideMimeType("text/plain"),
        o.open("GET", e, !0),
        o.addEventListener("load",
        function(n) {
            var s = n.target.response;
            THREE.Cache.add(e, s),
            200 === this.status ? (t && t(s), i.manager.itemEnd(e)) : 0 === this.status ? (console.warn("THREE.XHRLoader: HTTP Status 0 received."), t && t(s), i.manager.itemEnd(e)) : (r && r(n), i.manager.itemError(e))
        },
        !1),
        void 0 !== n && o.addEventListener("progress",
        function(e) {
            n(e)
        },
        !1),
        o.addEventListener("error",
        function(t) {
            r && r(t),
            i.manager.itemError(e)
        },
        !1),
        void 0 !== this.responseType && (o.responseType = this.responseType),
        void 0 !== this.withCredentials && (o.withCredentials = this.withCredentials),
        o.send(null),
        i.manager.itemStart(e),
        o
    },
    setPath: function(e) {
        this.path = e
    },
    setResponseType: function(e) {
        this.responseType = e
    },
    setWithCredentials: function(e) {
        this.withCredentials = e
    }
},
THREE.FontLoader = function(e) {
    this.manager = void 0 !== e ? e: THREE.DefaultLoadingManager
},
THREE.FontLoader.prototype = {
    constructor: THREE.FontLoader,
    load: function(e, t, n, r) { (new THREE.XHRLoader(this.manager)).load(e,
        function(e) {
            t(new THREE.Font(JSON.parse(e.substring(65, e.length - 2))))
        },
        n, r)
    }
},
THREE.ImageLoader = function(e) {
    this.manager = void 0 !== e ? e: THREE.DefaultLoadingManager
},
THREE.ImageLoader.prototype = {
    constructor: THREE.ImageLoader,
    load: function(e, t, n, r) {
        void 0 !== this.path && (e = this.path + e);
        var i = this,
        s = THREE.Cache.get(e);
        if (void 0 !== s) return i.manager.itemStart(e),
        t ? setTimeout(function() {
            t(s),
            i.manager.itemEnd(e)
        },
        0) : i.manager.itemEnd(e),
        s;
        var o = document.createElement("img");
        return o.addEventListener("load",
        function(n) {
            THREE.Cache.add(e, this),
            t && t(this),
            i.manager.itemEnd(e)
        },
        !1),
        void 0 !== n && o.addEventListener("progress",
        function(e) {
            n(e)
        },
        !1),
        o.addEventListener("error",
        function(t) {
            r && r(t),
            i.manager.itemError(e)
        },
        !1),
        void 0 !== this.crossOrigin && (o.crossOrigin = this.crossOrigin),
        i.manager.itemStart(e),
        o.src = e,
        o
    },
    setCrossOrigin: function(e) {
        this.crossOrigin = e
    },
    setPath: function(e) {
        this.path = e
    }
},
THREE.JSONLoader = function(e) {
    "boolean" == typeof e && (console.warn("THREE.JSONLoader: showStatus parameter has been removed from constructor."), e = void 0),
    this.manager = void 0 !== e ? e: THREE.DefaultLoadingManager,
    this.withCredentials = !1
},
THREE.JSONLoader.prototype = {
    constructor: THREE.JSONLoader,
    get statusDomElement() {
        return void 0 === this._statusDomElement && (this._statusDomElement = document.createElement("div")),
        console.warn("THREE.JSONLoader: .statusDomElement has been removed."),
        this._statusDomElement
    },
    load: function(e, t, n, r) {
        var i = this,
        s = this.texturePath && "string" == typeof this.texturePath ? this.texturePath: THREE.Loader.prototype.extractUrlBase(e),
        o = new THREE.XHRLoader(this.manager);
        o.setWithCredentials(this.withCredentials),
        o.load(e,
        function(n) {
            n = JSON.parse(n);
            var r = n.metadata;
            if (void 0 !== r && (r = r.type, void 0 !== r)) {
                if ("object" === r.toLowerCase()) {
                    console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.ObjectLoader instead.");
                    return
                }
                if ("scene" === r.toLowerCase()) {
                    console.error("THREE.JSONLoader: " + e + " should be loaded with THREE.SceneLoader instead.");
                    return
                }
            }
            n = i.parse(n, s),
            t(n.geometry, n.materials)
        },
        n, r)
    },
    setTexturePath: function(e) {
        this.texturePath = e
    },
    parse: function(e, t) {
        var n = new THREE.Geometry,
        r = void 0 !== e.scale ? 1 / e.scale: 1;
        return function(t) {
            var r, i, s, o, u, f, l, h, p, d, v, m, g, y = e.faces;
            f = e.vertices;
            var b = e.normals,
            w = e.colors,
            E = 0;
            if (void 0 !== e.uvs) {
                for (r = 0; r < e.uvs.length; r++) e.uvs[r].length && E++;
                for (r = 0; r < E; r++) n.faceVertexUvs[r] = []
            }
            o = 0;
            for (u = f.length; o < u;) r = new THREE.Vector3,
            r.x = f[o++] * t,
            r.y = f[o++] * t,
            r.z = f[o++] * t,
            n.vertices.push(r);
            o = 0;
            for (u = y.length; o < u;) if (t = y[o++], p = t & 1, s = t & 2, r = t & 8, l = t & 16, d = t & 32, f = t & 64, t &= 128, p) {
                p = new THREE.Face3,
                p.a = y[o],
                p.b = y[o + 1],
                p.c = y[o + 3],
                v = new THREE.Face3,
                v.a = y[o + 1],
                v.b = y[o + 2],
                v.c = y[o + 3],
                o += 4,
                s && (s = y[o++], p.materialIndex = s, v.materialIndex = s),
                s = n.faces.length;
                if (r) for (r = 0; r < E; r++) for (m = e.uvs[r], n.faceVertexUvs[r][s] = [], n.faceVertexUvs[r][s + 1] = [], i = 0; 4 > i; i++) h = y[o++],
                g = m[2 * h],
                h = m[2 * h + 1],
                g = new THREE.Vector2(g, h),
                2 !== i && n.faceVertexUvs[r][s].push(g),
                0 !== i && n.faceVertexUvs[r][s + 1].push(g);
                l && (l = 3 * y[o++], p.normal.set(b[l++], b[l++], b[l]), v.normal.copy(p.normal));
                if (d) for (r = 0; 4 > r; r++) l = 3 * y[o++],
                d = new THREE.Vector3(b[l++], b[l++], b[l]),
                2 !== r && p.vertexNormals.push(d),
                0 !== r && v.vertexNormals.push(d);
                f && (f = y[o++], f = w[f], p.color.setHex(f), v.color.setHex(f));
                if (t) for (r = 0; 4 > r; r++) f = y[o++],
                f = w[f],
                2 !== r && p.vertexColors.push(new THREE.Color(f)),
                0 !== r && v.vertexColors.push(new THREE.Color(f));
                n.faces.push(p),
                n.faces.push(v)
            } else {
                p = new THREE.Face3,
                p.a = y[o++],
                p.b = y[o++],
                p.c = y[o++],
                s && (s = y[o++], p.materialIndex = s),
                s = n.faces.length;
                if (r) for (r = 0; r < E; r++) for (m = e.uvs[r], n.faceVertexUvs[r][s] = [], i = 0; 3 > i; i++) h = y[o++],
                g = m[2 * h],
                h = m[2 * h + 1],
                g = new THREE.Vector2(g, h),
                n.faceVertexUvs[r][s].push(g);
                l && (l = 3 * y[o++], p.normal.set(b[l++], b[l++], b[l]));
                if (d) for (r = 0; 3 > r; r++) l = 3 * y[o++],
                d = new THREE.Vector3(b[l++], b[l++], b[l]),
                p.vertexNormals.push(d);
                f && (f = y[o++], p.color.setHex(w[f]));
                if (t) for (r = 0; 3 > r; r++) f = y[o++],
                p.vertexColors.push(new THREE.Color(w[f]));
                n.faces.push(p)
            }
        } (r),
        function() {
            var t = void 0 !== e.influencesPerVertex ? e.influencesPerVertex: 2;
            if (e.skinWeights) for (var r = 0,
            i = e.skinWeights.length; r < i; r += t) n.skinWeights.push(new THREE.Vector4(e.skinWeights[r], 1 < t ? e.skinWeights[r + 1] : 0, 2 < t ? e.skinWeights[r + 2] : 0, 3 < t ? e.skinWeights[r + 3] : 0));
            if (e.skinIndices) for (r = 0, i = e.skinIndices.length; r < i; r += t) n.skinIndices.push(new THREE.Vector4(e.skinIndices[r], 1 < t ? e.skinIndices[r + 1] : 0, 2 < t ? e.skinIndices[r + 2] : 0, 3 < t ? e.skinIndices[r + 3] : 0));
            n.bones = e.bones,
            n.bones && 0 < n.bones.length && (n.skinWeights.length !== n.skinIndices.length || n.skinIndices.length !== n.vertices.length) && console.warn("When skinning, number of vertices (" + n.vertices.length + "), skinIndices (" + n.skinIndices.length + "), and skinWeights (" + n.skinWeights.length + ") should match.")
        } (),
        function(t) {
            if (void 0 !== e.morphTargets) for (var r = 0,
            i = e.morphTargets.length; r < i; r++) {
                n.morphTargets[r] = {},
                n.morphTargets[r].name = e.morphTargets[r].name,
                n.morphTargets[r].vertices = [];
                for (var s = n.morphTargets[r].vertices, o = e.morphTargets[r].vertices, u = 0, f = o.length; u < f; u += 3) {
                    var l = new THREE.Vector3;
                    l.x = o[u] * t,
                    l.y = o[u + 1] * t,
                    l.z = o[u + 2] * t,
                    s.push(l)
                }
            }
            if (void 0 !== e.morphColors && 0 < e.morphColors.length) for (console.warn('THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.'), t = n.faces, s = e.morphColors[0].colors, r = 0, i = t.length; r < i; r++) t[r].color.fromArray(s, 3 * r)
        } (r),
        function() {
            var t = [],
            r = [];
            void 0 !== e.animation && r.push(e.animation),
            void 0 !== e.animations && (e.animations.length ? r = r.concat(e.animations) : r.push(e.animations));
            for (var i = 0; i < r.length; i++) {
                var s = THREE.AnimationClip.parseAnimation(r[i], n.bones);
                s && t.push(s)
            }
            n.morphTargets && (r = THREE.AnimationClip.CreateClipsFromMorphTargetSequences(n.morphTargets, 10), t = t.concat(r)),
            0 < t.length && (n.animations = t)
        } (),
        n.computeFaceNormals(),
        n.computeBoundingSphere(),
        void 0 === e.materials || 0 === e.materials.length ? {
            geometry: n
        }: (r = THREE.Loader.prototype.initMaterials(e.materials, t, this.crossOrigin), {
            geometry: n,
            materials: r
        })
    }
},
THREE.LoadingManager = function(e, t, n) {
    var r = this,
    i = !1,
    s = 0,
    o = 0;
    this.onStart = void 0,
    this.onLoad = e,
    this.onProgress = t,
    this.onError = n,
    this.itemStart = function(e) {
        o++,
        !1 === i && void 0 !== r.onStart && r.onStart(e, s, o),
        i = !0
    },
    this.itemEnd = function(e) {
        s++,
        void 0 !== r.onProgress && r.onProgress(e, s, o),
        s === o && (i = !1, void 0 !== r.onLoad) && r.onLoad()
    },
    this.itemError = function(e) {
        void 0 !== r.onError && r.onError(e)
    }
},
THREE.DefaultLoadingManager = new THREE.LoadingManager,
THREE.BufferGeometryLoader = function(e) {
    this.manager = void 0 !== e ? e: THREE.DefaultLoadingManager
},
THREE.BufferGeometryLoader.prototype = {
    constructor: THREE.BufferGeometryLoader,
    load: function(e, t, n, r) {
        var i = this; (new THREE.XHRLoader(i.manager)).load(e,
        function(e) {
            t(i.parse(JSON.parse(e)))
        },
        n, r)
    },
    parse: function(e) {
        var t = new THREE.BufferGeometry,
        n = e.data.index,
        r = {
            Int8Array: Int8Array,
            Uint8Array: Uint8Array,
            Uint8ClampedArray: Uint8ClampedArray,
            Int16Array: Int16Array,
            Uint16Array: Uint16Array,
            Int32Array: Int32Array,
            Uint32Array: Uint32Array,
            Float32Array: Float32Array,
            Float64Array: Float64Array
        };
        void 0 !== n && (n = new r[n.type](n.array), t.setIndex(new THREE.BufferAttribute(n, 1)));
        var i = e.data.attributes,
        s;
        for (s in i) {
            var o = i[s],
            n = new r[o.type](o.array);
            t.addAttribute(s, new THREE.BufferAttribute(n, o.itemSize))
        }
        r = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (void 0 !== r) for (s = 0, n = r.length; s !== n; ++s) i = r[s],
        t.addGroup(i.start, i.count, i.materialIndex);
        return e = e.data.boundingSphere,
        void 0 !== e && (r = new THREE.Vector3, void 0 !== e.center && r.fromArray(e.center), t.boundingSphere = new THREE.Sphere(r, e.radius)),
        t
    }
},
THREE.MaterialLoader = function(e) {
    this.manager = void 0 !== e ? e: THREE.DefaultLoadingManager,
    this.textures = {}
},
THREE.MaterialLoader.prototype = {
    constructor: THREE.MaterialLoader,
    load: function(e, t, n, r) {
        var i = this; (new THREE.XHRLoader(i.manager)).load(e,
        function(e) {
            t(i.parse(JSON.parse(e)))
        },
        n, r)
    },
    setTextures: function(e) {
        this.textures = e
    },
    getTexture: function(e) {
        var t = this.textures;
        return void 0 === t[e] && console.warn("THREE.MaterialLoader: Undefined texture", e),
        t[e]
    },
    parse: function(e) {
        var t = new THREE[e.type];
        void 0 !== e.uuid && (t.uuid = e.uuid),
        void 0 !== e.name && (t.name = e.name),
        void 0 !== e.color && t.color.setHex(e.color),
        void 0 !== e.roughness && (t.roughness = e.roughness),
        void 0 !== e.metalness && (t.metalness = e.metalness),
        void 0 !== e.emissive && t.emissive.setHex(e.emissive),
        void 0 !== e.specular && t.specular.setHex(e.specular),
        void 0 !== e.shininess && (t.shininess = e.shininess),
        void 0 !== e.uniforms && (t.uniforms = e.uniforms),
        void 0 !== e.vertexShader && (t.vertexShader = e.vertexShader),
        void 0 !== e.fragmentShader && (t.fragmentShader = e.fragmentShader),
        void 0 !== e.vertexColors && (t.vertexColors = e.vertexColors),
        void 0 !== e.shading && (t.shading = e.shading),
        void 0 !== e.blending && (t.blending = e.blending),
        void 0 !== e.side && (t.side = e.side),
        void 0 !== e.opacity && (t.opacity = e.opacity),
        void 0 !== e.transparent && (t.transparent = e.transparent),
        void 0 !== e.alphaTest && (t.alphaTest = e.alphaTest),
        void 0 !== e.depthTest && (t.depthTest = e.depthTest),
        void 0 !== e.depthWrite && (t.depthWrite = e.depthWrite),
        void 0 !== e.colorWrite && (t.colorWrite = e.colorWrite),
        void 0 !== e.wireframe && (t.wireframe = e.wireframe),
        void 0 !== e.wireframeLinewidth && (t.wireframeLinewidth = e.wireframeLinewidth),
        void 0 !== e.size && (t.size = e.size),
        void 0 !== e.sizeAttenuation && (t.sizeAttenuation = e.sizeAttenuation),
        void 0 !== e.map && (t.map = this.getTexture(e.map)),
        void 0 !== e.alphaMap && (t.alphaMap = this.getTexture(e.alphaMap), t.transparent = !0),
        void 0 !== e.bumpMap && (t.bumpMap = this.getTexture(e.bumpMap)),
        void 0 !== e.bumpScale && (t.bumpScale = e.bumpScale),
        void 0 !== e.normalMap && (t.normalMap = this.getTexture(e.normalMap));
        if (void 0 !== e.normalScale) {
            var n = e.normalScale; ! 1 === Array.isArray(n) && (n = [n, n]),
            t.normalScale = (new THREE.Vector2).fromArray(n)
        }
        void 0 !== e.displacementMap && (t.displacementMap = this.getTexture(e.displacementMap)),
        void 0 !== e.displacementScale && (t.displacementScale = e.displacementScale),
        void 0 !== e.displacementBias && (t.displacementBias = e.displacementBias),
        void 0 !== e.roughnessMap && (t.roughnessMap = this.getTexture(e.roughnessMap)),
        void 0 !== e.metalnessMap && (t.metalnessMap = this.getTexture(e.metalnessMap)),
        void 0 !== e.emissiveMap && (t.emissiveMap = this.getTexture(e.emissiveMap)),
        void 0 !== e.emissiveIntensity && (t.emissiveIntensity = e.emissiveIntensity),
        void 0 !== e.specularMap && (t.specularMap = this.getTexture(e.specularMap)),
        void 0 !== e.envMap && (t.envMap = this.getTexture(e.envMap), t.combine = THREE.MultiplyOperation),
        e.reflectivity && (t.reflectivity = e.reflectivity),
        void 0 !== e.lightMap && (t.lightMap = this.getTexture(e.lightMap)),
        void 0 !== e.lightMapIntensity && (t.lightMapIntensity = e.lightMapIntensity),
        void 0 !== e.aoMap && (t.aoMap = this.getTexture(e.aoMap)),
        void 0 !== e.aoMapIntensity && (t.aoMapIntensity = e.aoMapIntensity);
        if (void 0 !== e.materials) for (var n = 0,
        r = e.materials.length; n < r; n++) t.materials.push(this.parse(e.materials[n]));
        return t
    }
},
THREE.ObjectLoader = function(e) {
    this.manager = void 0 !== e ? e: THREE.DefaultLoadingManager,
    this.texturePath = ""
},
THREE.ObjectLoader.prototype = {
    constructor: THREE.ObjectLoader,
    load: function(e, t, n, r) {
        "" === this.texturePath && (this.texturePath = e.substring(0, e.lastIndexOf("/") + 1));
        var i = this; (new THREE.XHRLoader(i.manager)).load(e,
        function(e) {
            i.parse(JSON.parse(e), t)
        },
        n, r)
    },
    setTexturePath: function(e) {
        this.texturePath = e
    },
    setCrossOrigin: function(e) {
        this.crossOrigin = e
    },
    parse: function(e, t) {
        var n = this.parseGeometries(e.geometries),
        r = this.parseImages(e.images,
        function() {
            void 0 !== t && t(i)
        }),
        r = this.parseTextures(e.textures, r),
        r = this.parseMaterials(e.materials, r),
        i = this.parseObject(e.object, n, r);
        return e.animations && (i.animations = this.parseAnimations(e.animations)),
        void 0 !== e.images && 0 !== e.images.length || void 0 === t || t(i),
        i
    },
    parseGeometries: function(e) {
        var t = {};
        if (void 0 !== e) for (var n = new THREE.JSONLoader,
        r = new THREE.BufferGeometryLoader,
        i = 0,
        s = e.length; i < s; i++) {
            var o, u = e[i];
            switch (u.type) {
            case "PlaneGeometry":
            case "PlaneBufferGeometry":
                o = new THREE[u.type](u.width, u.height, u.widthSegments, u.heightSegments);
                break;
            case "BoxGeometry":
            case "BoxBufferGeometry":
            case "CubeGeometry":
                o = new THREE[u.type](u.width, u.height, u.depth, u.widthSegments, u.heightSegments, u.depthSegments);
                break;
            case "CircleGeometry":
            case "CircleBufferGeometry":
                o = new THREE[u.type](u.radius, u.segments, u.thetaStart, u.thetaLength);
                break;
            case "CylinderGeometry":
            case "CylinderBufferGeometry":
                o = new THREE[u.type](u.radiusTop, u.radiusBottom, u.height, u.radialSegments, u.heightSegments, u.openEnded, u.thetaStart, u.thetaLength);
                break;
            case "SphereGeometry":
            case "SphereBufferGeometry":
                o = new THREE[u.type](u.radius, u.widthSegments, u.heightSegments, u.phiStart, u.phiLength, u.thetaStart, u.thetaLength);
                break;
            case "DodecahedronGeometry":
                o = new THREE.DodecahedronGeometry(u.radius, u.detail);
                break;
            case "IcosahedronGeometry":
                o = new THREE.IcosahedronGeometry(u.radius, u.detail);
                break;
            case "OctahedronGeometry":
                o = new THREE.OctahedronGeometry(u.radius, u.detail);
                break;
            case "TetrahedronGeometry":
                o = new THREE.TetrahedronGeometry(u.radius, u.detail);
                break;
            case "RingGeometry":
            case "RingBufferGeometry":
                o = new THREE[u.type](u.innerRadius, u.outerRadius, u.thetaSegments, u.phiSegments, u.thetaStart, u.thetaLength);
                break;
            case "TorusGeometry":
            case "TorusBufferGeometry":
                o = new THREE[u.type](u.radius, u.tube, u.radialSegments, u.tubularSegments, u.arc);
                break;
            case "TorusKnotGeometry":
            case "TorusKnotBufferGeometry":
                o = new THREE[u.type](u.radius, u.tube, u.tubularSegments, u.radialSegments, u.p, u.q);
                break;
            case "LatheGeometry":
                o = new THREE.LatheGeometry(u.points, u.segments, u.phiStart, u.phiLength);
                break;
            case "BufferGeometry":
                o = r.parse(u);
                break;
            case "Geometry":
                o = n.parse(u.data, this.texturePath).geometry;
                break;
            default:
                console.warn('THREE.ObjectLoader: Unsupported geometry type "' + u.type + '"');
                continue
            }
            o.uuid = u.uuid,
            void 0 !== u.name && (o.name = u.name),
            t[u.uuid] = o
        }
        return t
    },
    parseMaterials: function(e, t) {
        var n = {};
        if (void 0 !== e) {
            var r = new THREE.MaterialLoader;
            r.setTextures(t);
            for (var i = 0,
            s = e.length; i < s; i++) {
                var o = r.parse(e[i]);
                n[o.uuid] = o
            }
        }
        return n
    },
    parseAnimations: function(e) {
        for (var t = [], n = 0; n < e.length; n++) {
            var r = THREE.AnimationClip.parse(e[n]);
            t.push(r)
        }
        return t
    },
    parseImages: function(e, t) {
        function n(e) {
            return r.manager.itemStart(e),
            o.load(e,
            function() {
                r.manager.itemEnd(e)
            })
        }
        var r = this,
        i = {};
        if (void 0 !== e && 0 < e.length) {
            var s = new THREE.LoadingManager(t),
            o = new THREE.ImageLoader(s);
            o.setCrossOrigin(this.crossOrigin);
            for (var s = 0,
            u = e.length; s < u; s++) {
                var a = e[s],
                f = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a.url) ? a.url: r.texturePath + a.url;
                i[a.uuid] = n(f)
            }
        }
        return i
    },
    parseTextures: function(e, t) {
        function n(e) {
            return "number" == typeof e ? e: (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", e), THREE[e])
        }
        var r = {};
        if (void 0 !== e) for (var i = 0,
        s = e.length; i < s; i++) {
            var o = e[i];
            void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid),
            void 0 === t[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image);
            var u = new THREE.Texture(t[o.image]);
            u.needsUpdate = !0,
            u.uuid = o.uuid,
            void 0 !== o.name && (u.name = o.name),
            void 0 !== o.mapping && (u.mapping = n(o.mapping)),
            void 0 !== o.offset && (u.offset = new THREE.Vector2(o.offset[0], o.offset[1])),
            void 0 !== o.repeat && (u.repeat = new THREE.Vector2(o.repeat[0], o.repeat[1])),
            void 0 !== o.minFilter && (u.minFilter = n(o.minFilter)),
            void 0 !== o.magFilter && (u.magFilter = n(o.magFilter)),
            void 0 !== o.anisotropy && (u.anisotropy = o.anisotropy),
            Array.isArray(o.wrap) && (u.wrapS = n(o.wrap[0]), u.wrapT = n(o.wrap[1])),
            r[o.uuid] = u
        }
        return r
    },
    parseObject: function() {
        var e = new THREE.Matrix4;
        return function(t, n, r) {
            function i(e) {
                return void 0 === n[e] && console.warn("THREE.ObjectLoader: Undefined geometry", e),
                n[e]
            }
            function s(e) {
                if (void 0 !== e) return void 0 === r[e] && console.warn("THREE.ObjectLoader: Undefined material", e),
                r[e]
            }
            var o;
            switch (t.type) {
            case "Scene":
                o = new THREE.Scene;
                break;
            case "PerspectiveCamera":
                o = new THREE.PerspectiveCamera(t.fov, t.aspect, t.near, t.far);
                break;
            case "OrthographicCamera":
                o = new THREE.OrthographicCamera(t.left, t.right, t.top, t.bottom, t.near, t.far);
                break;
            case "AmbientLight":
                o = new THREE.AmbientLight(t.color, t.intensity);
                break;
            case "DirectionalLight":
                o = new THREE.DirectionalLight(t.color, t.intensity);
                break;
            case "PointLight":
                o = new THREE.PointLight(t.color, t.intensity, t.distance, t.decay);
                break;
            case "SpotLight":
                o = new THREE.SpotLight(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                break;
            case "HemisphereLight":
                o = new THREE.HemisphereLight(t.color, t.groundColor, t.intensity);
                break;
            case "Mesh":
                o = i(t.geometry);
                var u = s(t.material);
                o = o.bones && 0 < o.bones.length ? new THREE.SkinnedMesh(o, u) : new THREE.Mesh(o, u);
                break;
            case "LOD":
                o = new THREE.LOD;
                break;
            case "Line":
                o = new THREE.Line(i(t.geometry), s(t.material), t.mode);
                break;
            case "PointCloud":
            case "Points":
                o = new THREE.Points(i(t.geometry), s(t.material));
                break;
            case "Sprite":
                o = new THREE.Sprite(s(t.material));
                break;
            case "Group":
                o = new THREE.Group;
                break;
            default:
                o = new THREE.Object3D
            }
            o.uuid = t.uuid,
            void 0 !== t.name && (o.name = t.name),
            void 0 !== t.matrix ? (e.fromArray(t.matrix), e.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== t.position && o.position.fromArray(t.position), void 0 !== t.rotation && o.rotation.fromArray(t.rotation), void 0 !== t.scale && o.scale.fromArray(t.scale)),
            void 0 !== t.castShadow && (o.castShadow = t.castShadow),
            void 0 !== t.receiveShadow && (o.receiveShadow = t.receiveShadow),
            void 0 !== t.visible && (o.visible = t.visible),
            void 0 !== t.userData && (o.userData = t.userData);
            if (void 0 !== t.children) for (var f in t.children) o.add(this.parseObject(t.children[f], n, r));
            if ("LOD" === t.type) for (t = t.levels, u = 0; u < t.length; u++) {
                var l = t[u];
                f = o.getObjectByProperty("uuid", l.object),
                void 0 !== f && o.addLevel(f, l.distance)
            }
            return o
        }
    } ()
},
THREE.TextureLoader = function(e) {
    this.manager = void 0 !== e ? e: THREE.DefaultLoadingManager
},
THREE.TextureLoader.prototype = {
    constructor: THREE.TextureLoader,
    load: function(e, t, n, r) {
        var i = new THREE.Texture,
        s = new THREE.ImageLoader(this.manager);
        return s.setCrossOrigin(this.crossOrigin),
        s.setPath(this.path),
        s.load(e,
        function(e) {
            i.image = e,
            i.needsUpdate = !0,
            void 0 !== t && t(i)
        },
        n, r),
        i
    },
    setCrossOrigin: function(e) {
        this.crossOrigin = e
    },
    setPath: function(e) {
        this.path = e
    }
},
THREE.CubeTextureLoader = function(e) {
    this.manager = void 0 !== e ? e: THREE.DefaultLoadingManager
},
THREE.CubeTextureLoader.prototype = {
    constructor: THREE.CubeTextureLoader,
    load: function(e, t, n, r) {
        function i(n) {
            o.load(e[n],
            function(e) {
                s.images[n] = e,
                u++,
                6 === u && (s.needsUpdate = !0, t && t(s))
            },
            void 0, r)
        }
        var s = new THREE.CubeTexture,
        o = new THREE.ImageLoader(this.manager);
        o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path);
        var u = 0;
        for (n = 0; n < e.length; ++n) i(n);
        return s
    },
    setCrossOrigin: function(e) {
        this.crossOrigin = e
    },
    setPath: function(e) {
        this.path = e
    }
},
THREE.DataTextureLoader = THREE.BinaryTextureLoader = function(e) {
    this.manager = void 0 !== e ? e: THREE.DefaultLoadingManager,
    this._parser = null
},
THREE.BinaryTextureLoader.prototype = {
    constructor: THREE.BinaryTextureLoader,
    load: function(e, t, n, r) {
        var i = this,
        s = new THREE.DataTexture,
        o = new THREE.XHRLoader(this.manager);
        return o.setResponseType("arraybuffer"),
        o.load(e,
        function(e) {
            if (e = i._parser(e)) void 0 !== e.image ? s.image = e.image: void 0 !== e.data && (s.image.width = e.width, s.image.height = e.height, s.image.data = e.data),
            s.wrapS = void 0 !== e.wrapS ? e.wrapS: THREE.ClampToEdgeWrapping,
            s.wrapT = void 0 !== e.wrapT ? e.wrapT: THREE.ClampToEdgeWrapping,
            s.magFilter = void 0 !== e.magFilter ? e.magFilter: THREE.LinearFilter,
            s.minFilter = void 0 !== e.minFilter ? e.minFilter: THREE.LinearMipMapLinearFilter,
            s.anisotropy = void 0 !== e.anisotropy ? e.anisotropy: 1,
            void 0 !== e.format && (s.format = e.format),
            void 0 !== e.type && (s.type = e.type),
            void 0 !== e.mipmaps && (s.mipmaps = e.mipmaps),
            1 === e.mipmapCount && (s.minFilter = THREE.LinearFilter),
            s.needsUpdate = !0,
            t && t(s, e)
        },
        n, r),
        s
    }
},
THREE.CompressedTextureLoader = function(e) {
    this.manager = void 0 !== e ? e: THREE.DefaultLoadingManager,
    this._parser = null
},
THREE.CompressedTextureLoader.prototype = {
    constructor: THREE.CompressedTextureLoader,
    load: function(e, t, n, r) {
        function i(i) {
            a.load(e[i],
            function(e) {
                e = s._parser(e, !0),
                o[i] = {
                    width: e.width,
                    height: e.height,
                    format: e.format,
                    mipmaps: e.mipmaps
                },
                f += 1,
                6 === f && (1 === e.mipmapCount && (u.minFilter = THREE.LinearFilter), u.format = e.format, u.needsUpdate = !0, t && t(u))
            },
            n, r)
        }
        var s = this,
        o = [],
        u = new THREE.CompressedTexture;
        u.image = o;
        var a = new THREE.XHRLoader(this.manager);
        a.setPath(this.path),
        a.setResponseType("arraybuffer");
        if (Array.isArray(e)) for (var f = 0,
        l = 0,
        c = e.length; l < c; ++l) i(l);
        else a.load(e,
        function(e) {
            e = s._parser(e, !0);
            if (e.isCubemap) for (var n = e.mipmaps.length / e.mipmapCount,
            r = 0; r < n; r++) {
                o[r] = {
                    mipmaps: []
                };
                for (var i = 0; i < e.mipmapCount; i++) o[r].mipmaps.push(e.mipmaps[r * e.mipmapCount + i]),
                o[r].format = e.format,
                o[r].width = e.width,
                o[r].height = e.height
            } else u.image.width = e.width,
            u.image.height = e.height,
            u.mipmaps = e.mipmaps;
            1 === e.mipmapCount && (u.minFilter = THREE.LinearFilter),
            u.format = e.format,
            u.needsUpdate = !0,
            t && t(u)
        },
        n, r);
        return u
    },
    setPath: function(e) {
        this.path = e
    }
},
THREE.Material = function() {
    Object.defineProperty(this, "id", {
        value: THREE.MaterialIdCount++
    }),
    this.uuid = THREE.Math.generateUUID(),
    this.name = "",
    this.type = "Material",
    this.side = THREE.FrontSide,
    this.opacity = 1,
    this.transparent = !1,
    this.blending = THREE.NormalBlending,
    this.blendSrc = THREE.SrcAlphaFactor,
    this.blendDst = THREE.OneMinusSrcAlphaFactor,
    this.blendEquation = THREE.AddEquation,
    this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null,
    this.depthFunc = THREE.LessEqualDepth,
    this.colorWrite = this.depthWrite = this.depthTest = !0,
    this.precision = null,
    this.polygonOffset = !1,
    this.alphaTest = this.polygonOffsetUnits = this.polygonOffsetFactor = 0,
    this.premultipliedAlpha = !1,
    this.overdraw = 0,
    this._needsUpdate = this.visible = !0
},
THREE.Material.prototype = {
    constructor: THREE.Material,
    get needsUpdate() {
        return this._needsUpdate
    },
    set needsUpdate(e) { ! 0 === e && this.update(),
        this._needsUpdate = e
    },
    setValues: function(e) {
        if (void 0 !== e) for (var t in e) {
            var n = e[t];
            if (void 0 === n) console.warn("THREE.Material: '" + t + "' parameter is undefined.");
            else {
                var r = this[t];
                void 0 === r ? console.warn("THREE." + this.type + ": '" + t + "' is not a property of this material.") : r instanceof THREE.Color ? r.set(n) : r instanceof THREE.Vector3 && n instanceof THREE.Vector3 ? r.copy(n) : this[t] = "overdraw" === t ? Number(n) : n
            }
        }
    },
    toJSON: function(e) {
        function t(e) {
            var t = [],
            n;
            for (n in e) {
                var r = e[n];
                delete r.metadata,
                t.push(r)
            }
            return t
        }
        var n = void 0 === e;
        n && (e = {
            textures: {},
            images: {}
        });
        var r = {
            metadata: {
                version: 4.4,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        return r.uuid = this.uuid,
        r.type = this.type,
        "" !== this.name && (r.name = this.name),
        this.color instanceof THREE.Color && (r.color = this.color.getHex()),
        .5 !== this.roughness && (r.roughness = this.roughness),
        .5 !== this.metalness && (r.metalness = this.metalness),
        this.emissive instanceof THREE.Color && (r.emissive = this.emissive.getHex()),
        this.specular instanceof THREE.Color && (r.specular = this.specular.getHex()),
        void 0 !== this.shininess && (r.shininess = this.shininess),
        this.map instanceof THREE.Texture && (r.map = this.map.toJSON(e).uuid),
        this.alphaMap instanceof THREE.Texture && (r.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap instanceof THREE.Texture && (r.lightMap = this.lightMap.toJSON(e).uuid),
        this.bumpMap instanceof THREE.Texture && (r.bumpMap = this.bumpMap.toJSON(e).uuid, r.bumpScale = this.bumpScale),
        this.normalMap instanceof THREE.Texture && (r.normalMap = this.normalMap.toJSON(e).uuid, r.normalScale = this.normalScale.toArray()),
        this.displacementMap instanceof THREE.Texture && (r.displacementMap = this.displacementMap.toJSON(e).uuid, r.displacementScale = this.displacementScale, r.displacementBias = this.displacementBias),
        this.roughnessMap instanceof THREE.Texture && (r.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap instanceof THREE.Texture && (r.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap instanceof THREE.Texture && (r.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap instanceof THREE.Texture && (r.specularMap = this.specularMap.toJSON(e).uuid),
        this.envMap instanceof THREE.Texture && (r.envMap = this.envMap.toJSON(e).uuid, r.reflectivity = this.reflectivity),
        void 0 !== this.size && (r.size = this.size),
        void 0 !== this.sizeAttenuation && (r.sizeAttenuation = this.sizeAttenuation),
        void 0 !== this.vertexColors && this.vertexColors !== THREE.NoColors && (r.vertexColors = this.vertexColors),
        void 0 !== this.shading && this.shading !== THREE.SmoothShading && (r.shading = this.shading),
        void 0 !== this.blending && this.blending !== THREE.NormalBlending && (r.blending = this.blending),
        void 0 !== this.side && this.side !== THREE.FrontSide && (r.side = this.side),
        1 > this.opacity && (r.opacity = this.opacity),
        !0 === this.transparent && (r.transparent = this.transparent),
        0 < this.alphaTest && (r.alphaTest = this.alphaTest),
        !0 === this.premultipliedAlpha && (r.premultipliedAlpha = this.premultipliedAlpha),
        !0 === this.wireframe && (r.wireframe = this.wireframe),
        1 < this.wireframeLinewidth && (r.wireframeLinewidth = this.wireframeLinewidth),
        n && (n = t(e.textures), e = t(e.images), 0 < n.length && (r.textures = n), 0 < e.length && (r.images = e)),
        r
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(e) {
        return this.name = e.name,
        this.side = e.side,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blending = e.blending,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.alphaTest = e.alphaTest,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.overdraw = e.overdraw,
        this.visible = e.visible,
        this
    },
    update: function() {
        this.dispatchEvent({
            type: "update"
        })
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
},
THREE.EventDispatcher.prototype.apply(THREE.Material.prototype),
THREE.MaterialIdCount = 0,
THREE.LineBasicMaterial = function(e) {
    THREE.Material.call(this),
    this.type = "LineBasicMaterial",
    this.color = new THREE.Color(16777215),
    this.linewidth = 1,
    this.linejoin = this.linecap = "round",
    this.blending = THREE.NormalBlending,
    this.vertexColors = THREE.NoColors,
    this.fog = !0,
    this.setValues(e)
},
THREE.LineBasicMaterial.prototype = Object.create(THREE.Material.prototype),
THREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial,
THREE.LineBasicMaterial.prototype.copy = function(e) {
    return THREE.Material.prototype.copy.call(this, e),
    this.color.copy(e.color),
    this.linewidth = e.linewidth,
    this.linecap = e.linecap,
    this.linejoin = e.linejoin,
    this.vertexColors = e.vertexColors,
    this.fog = e.fog,
    this
},
THREE.LineDashedMaterial = function(e) {
    THREE.Material.call(this),
    this.type = "LineDashedMaterial",
    this.color = new THREE.Color(16777215),
    this.scale = this.linewidth = 1,
    this.dashSize = 3,
    this.gapSize = 1,
    this.blending = THREE.NormalBlending,
    this.vertexColors = THREE.NoColors,
    this.fog = !0,
    this.setValues(e)
},
THREE.LineDashedMaterial.prototype = Object.create(THREE.Material.prototype),
THREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial,
THREE.LineDashedMaterial.prototype.copy = function(e) {
    return THREE.Material.prototype.copy.call(this, e),
    this.color.copy(e.color),
    this.linewidth = e.linewidth,
    this.scale = e.scale,
    this.dashSize = e.dashSize,
    this.gapSize = e.gapSize,
    this.vertexColors = e.vertexColors,
    this.fog = e.fog,
    this
},
THREE.MeshBasicMaterial = function(e) {
    THREE.Material.call(this),
    this.type = "MeshBasicMaterial",
    this.color = new THREE.Color(16777215),
    this.aoMap = this.map = null,
    this.aoMapIntensity = 1,
    this.envMap = this.alphaMap = this.specularMap = null,
    this.combine = THREE.MultiplyOperation,
    this.reflectivity = 1,
    this.refractionRatio = .98,
    this.fog = !0,
    this.shading = THREE.SmoothShading,
    this.blending = THREE.NormalBlending,
    this.wireframe = !1,
    this.wireframeLinewidth = 1,
    this.wireframeLinejoin = this.wireframeLinecap = "round",
    this.vertexColors = THREE.NoColors,
    this.morphTargets = this.skinning = !1,
    this.setValues(e)
},
THREE.MeshBasicMaterial.prototype = Object.create(THREE.Material.prototype),
THREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial,
THREE.MeshBasicMaterial.prototype.copy = function(e) {
    return THREE.Material.prototype.copy.call(this, e),
    this.color.copy(e.color),
    this.map = e.map,
    this.aoMap = e.aoMap,
    this.aoMapIntensity = e.aoMapIntensity,
    this.specularMap = e.specularMap,
    this.alphaMap = e.alphaMap,
    this.envMap = e.envMap,
    this.combine = e.combine,
    this.reflectivity = e.reflectivity,
    this.refractionRatio = e.refractionRatio,
    this.fog = e.fog,
    this.shading = e.shading,
    this.wireframe = e.wireframe,
    this.wireframeLinewidth = e.wireframeLinewidth,
    this.wireframeLinecap = e.wireframeLinecap,
    this.wireframeLinejoin = e.wireframeLinejoin,
    this.vertexColors = e.vertexColors,
    this.skinning = e.skinning,
    this.morphTargets = e.morphTargets,
    this
},
THREE.MeshLambertMaterial = function(e) {
    THREE.Material.call(this),
    this.type = "MeshLambertMaterial",
    this.color = new THREE.Color(16777215),
    this.lightMap = this.map = null,
    this.lightMapIntensity = 1,
    this.aoMap = null,
    this.aoMapIntensity = 1,
    this.emissive = new THREE.Color(0),
    this.emissiveIntensity = 1,
    this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null,
    this.combine = THREE.MultiplyOperation,
    this.reflectivity = 1,
    this.refractionRatio = .98,
    this.fog = !0,
    this.blending = THREE.NormalBlending,
    this.wireframe = !1,
    this.wireframeLinewidth = 1,
    this.wireframeLinejoin = this.wireframeLinecap = "round",
    this.vertexColors = THREE.NoColors,
    this.morphNormals = this.morphTargets = this.skinning = !1,
    this.setValues(e)
},
THREE.MeshLambertMaterial.prototype = Object.create(THREE.Material.prototype),
THREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial,
THREE.MeshLambertMaterial.prototype.copy = function(e) {
    return THREE.Material.prototype.copy.call(this, e),
    this.color.copy(e.color),
    this.map = e.map,
    this.lightMap = e.lightMap,
    this.lightMapIntensity = e.lightMapIntensity,
    this.aoMap = e.aoMap,
    this.aoMapIntensity = e.aoMapIntensity,
    this.emissive.copy(e.emissive),
    this.emissiveMap = e.emissiveMap,
    this.emissiveIntensity = e.emissiveIntensity,
    this.specularMap = e.specularMap,
    this.alphaMap = e.alphaMap,
    this.envMap = e.envMap,
    this.combine = e.combine,
    this.reflectivity = e.reflectivity,
    this.refractionRatio = e.refractionRatio,
    this.fog = e.fog,
    this.wireframe = e.wireframe,
    this.wireframeLinewidth = e.wireframeLinewidth,
    this.wireframeLinecap = e.wireframeLinecap,
    this.wireframeLinejoin = e.wireframeLinejoin,
    this.vertexColors = e.vertexColors,
    this.skinning = e.skinning,
    this.morphTargets = e.morphTargets,
    this.morphNormals = e.morphNormals,
    this
},
THREE.MeshPhongMaterial = function(e) {
    THREE.Material.call(this),
    this.type = "MeshPhongMaterial",
    this.color = new THREE.Color(16777215),
    this.specular = new THREE.Color(1118481),
    this.shininess = 30,
    this.lightMap = this.map = null,
    this.lightMapIntensity = 1,
    this.aoMap = null,
    this.aoMapIntensity = 1,
    this.emissive = new THREE.Color(0),
    this.emissiveIntensity = 1,
    this.bumpMap = this.emissiveMap = null,
    this.bumpScale = 1,
    this.normalMap = null,
    this.normalScale = new THREE.Vector2(1, 1),
    this.displacementMap = null,
    this.displacementScale = 1,
    this.displacementBias = 0,
    this.envMap = this.alphaMap = this.specularMap = null,
    this.combine = THREE.MultiplyOperation,
    this.reflectivity = 1,
    this.refractionRatio = .98,
    this.fog = !0,
    this.shading = THREE.SmoothShading,
    this.blending = THREE.NormalBlending,
    this.wireframe = !1,
    this.wireframeLinewidth = 1,
    this.wireframeLinejoin = this.wireframeLinecap = "round",
    this.vertexColors = THREE.NoColors,
    this.morphNormals = this.morphTargets = this.skinning = !1,
    this.setValues(e)
},
THREE.MeshPhongMaterial.prototype = Object.create(THREE.Material.prototype),
THREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial,
THREE.MeshPhongMaterial.prototype.copy = function(e) {
    return THREE.Material.prototype.copy.call(this, e),
    this.color.copy(e.color),
    this.specular.copy(e.specular),
    this.shininess = e.shininess,
    this.map = e.map,
    this.lightMap = e.lightMap,
    this.lightMapIntensity = e.lightMapIntensity,
    this.aoMap = e.aoMap,
    this.aoMapIntensity = e.aoMapIntensity,
    this.emissive.copy(e.emissive),
    this.emissiveMap = e.emissiveMap,
    this.emissiveIntensity = e.emissiveIntensity,
    this.bumpMap = e.bumpMap,
    this.bumpScale = e.bumpScale,
    this.normalMap = e.normalMap,
    this.normalScale.copy(e.normalScale),
    this.displacementMap = e.displacementMap,
    this.displacementScale = e.displacementScale,
    this.displacementBias = e.displacementBias,
    this.specularMap = e.specularMap,
    this.alphaMap = e.alphaMap,
    this.envMap = e.envMap,
    this.combine = e.combine,
    this.reflectivity = e.reflectivity,
    this.refractionRatio = e.refractionRatio,
    this.fog = e.fog,
    this.shading = e.shading,
    this.wireframe = e.wireframe,
    this.wireframeLinewidth = e.wireframeLinewidth,
    this.wireframeLinecap = e.wireframeLinecap,
    this.wireframeLinejoin = e.wireframeLinejoin,
    this.vertexColors = e.vertexColors,
    this.skinning = e.skinning,
    this.morphTargets = e.morphTargets,
    this.morphNormals = e.morphNormals,
    this
},
THREE.MeshStandardMaterial = function(e) {
    THREE.Material.call(this),
    this.type = "MeshStandardMaterial",
    this.color = new THREE.Color(16777215),
    this.metalness = this.roughness = .5,
    this.lightMap = this.map = null,
    this.lightMapIntensity = 1,
    this.aoMap = null,
    this.aoMapIntensity = 1,
    this.emissive = new THREE.Color(0),
    this.emissiveIntensity = 1,
    this.bumpMap = this.emissiveMap = null,
    this.bumpScale = 1,
    this.normalMap = null,
    this.normalScale = new THREE.Vector2(1, 1),
    this.displacementMap = null,
    this.displacementScale = 1,
    this.displacementBias = 0,
    this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null,
    this.envMapIntensity = 1,
    this.refractionRatio = .98,
    this.fog = !0,
    this.shading = THREE.SmoothShading,
    this.blending = THREE.NormalBlending,
    this.wireframe = !1,
    this.wireframeLinewidth = 1,
    this.wireframeLinejoin = this.wireframeLinecap = "round",
    this.vertexColors = THREE.NoColors,
    this.morphNormals = this.morphTargets = this.skinning = !1,
    this.setValues(e)
},
THREE.MeshStandardMaterial.prototype = Object.create(THREE.Material.prototype),
THREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial,
THREE.MeshStandardMaterial.prototype.copy = function(e) {
    return THREE.Material.prototype.copy.call(this, e),
    this.color.copy(e.color),
    this.roughness = e.roughness,
    this.metalness = e.metalness,
    this.map = e.map,
    this.lightMap = e.lightMap,
    this.lightMapIntensity = e.lightMapIntensity,
    this.aoMap = e.aoMap,
    this.aoMapIntensity = e.aoMapIntensity,
    this.emissive.copy(e.emissive),
    this.emissiveMap = e.emissiveMap,
    this.emissiveIntensity = e.emissiveIntensity,
    this.bumpMap = e.bumpMap,
    this.bumpScale = e.bumpScale,
    this.normalMap = e.normalMap,
    this.normalScale.copy(e.normalScale),
    this.displacementMap = e.displacementMap,
    this.displacementScale = e.displacementScale,
    this.displacementBias = e.displacementBias,
    this.roughnessMap = e.roughnessMap,
    this.metalnessMap = e.metalnessMap,
    this.alphaMap = e.alphaMap,
    this.envMap = e.envMap,
    this.envMapIntensity = e.envMapIntensity,
    this.refractionRatio = e.refractionRatio,
    this.fog = e.fog,
    this.shading = e.shading,
    this.wireframe = e.wireframe,
    this.wireframeLinewidth = e.wireframeLinewidth,
    this.wireframeLinecap = e.wireframeLinecap,
    this.wireframeLinejoin = e.wireframeLinejoin,
    this.vertexColors = e.vertexColors,
    this.skinning = e.skinning,
    this.morphTargets = e.morphTargets,
    this.morphNormals = e.morphNormals,
    this
},
THREE.MeshDepthMaterial = function(e) {
    THREE.Material.call(this),
    this.type = "MeshDepthMaterial",
    this.wireframe = this.morphTargets = !1,
    this.wireframeLinewidth = 1,
    this.setValues(e)
},
THREE.MeshDepthMaterial.prototype = Object.create(THREE.Material.prototype),
THREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial,
THREE.MeshDepthMaterial.prototype.copy = function(e) {
    return THREE.Material.prototype.copy.call(this, e),
    this.wireframe = e.wireframe,
    this.wireframeLinewidth = e.wireframeLinewidth,
    this
},
THREE.MeshNormalMaterial = function(e) {
    THREE.Material.call(this, e),
    this.type = "MeshNormalMaterial",
    this.wireframe = !1,
    this.wireframeLinewidth = 1,
    this.morphTargets = !1,
    this.setValues(e)
},
THREE.MeshNormalMaterial.prototype = Object.create(THREE.Material.prototype),
THREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial,
THREE.MeshNormalMaterial.prototype.copy = function(e) {
    return THREE.Material.prototype.copy.call(this, e),
    this.wireframe = e.wireframe,
    this.wireframeLinewidth = e.wireframeLinewidth,
    this
},
THREE.MultiMaterial = function(e) {
    this.uuid = THREE.Math.generateUUID(),
    this.type = "MultiMaterial",
    this.materials = e instanceof Array ? e: [],
    this.visible = !0
},
THREE.MultiMaterial.prototype = {
    constructor: THREE.MultiMaterial,
    toJSON: function(e) {
        for (var t = {
            metadata: {
                version: 4.2,
                type: "material",
                generator: "MaterialExporter"
            },
            uuid: this.uuid,
            type: this.type,
            materials: []
        },
        n = this.materials, r = 0, i = n.length; r < i; r++) {
            var s = n[r].toJSON(e);
            delete s.metadata,
            t.materials.push(s)
        }
        return t.visible = this.visible,
        t
    },
    clone: function() {
        for (var e = new this.constructor,
        t = 0; t < this.materials.length; t++) e.materials.push(this.materials[t].clone());
        return e.visible = this.visible,
        e
    }
},
THREE.PointsMaterial = function(e) {
    THREE.Material.call(this),
    this.type = "PointsMaterial",
    this.color = new THREE.Color(16777215),
    this.map = null,
    this.size = 1,
    this.sizeAttenuation = !0,
    this.blending = THREE.NormalBlending,
    this.vertexColors = THREE.NoColors,
    this.fog = !0,
    this.setValues(e)
},
THREE.PointsMaterial.prototype = Object.create(THREE.Material.prototype),
THREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial,
THREE.PointsMaterial.prototype.copy = function(e) {
    return THREE.Material.prototype.copy.call(this, e),
    this.color.copy(e.color),
    this.map = e.map,
    this.size = e.size,
    this.sizeAttenuation = e.sizeAttenuation,
    this.vertexColors = e.vertexColors,
    this.fog = e.fog,
    this
},
THREE.ShaderMaterial = function(e) {
    THREE.Material.call(this),
    this.type = "ShaderMaterial",
    this.defines = {},
    this.uniforms = {},
    this.vertexShader = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}",
    this.fragmentShader = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}",
    this.shading = THREE.SmoothShading,
    this.linewidth = 1,
    this.wireframe = !1,
    this.wireframeLinewidth = 1,
    this.lights = this.fog = !1,
    this.vertexColors = THREE.NoColors,
    this.morphNormals = this.morphTargets = this.skinning = !1,
    this.extensions = {
        derivatives: !1,
        fragDepth: !1,
        drawBuffers: !1,
        shaderTextureLOD: !1
    },
    this.defaultAttributeValues = {
        color: [1, 1, 1],
        uv: [0, 0],
        uv2: [0, 0]
    },
    this.index0AttributeName = void 0,
    void 0 !== e && (void 0 !== e.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(e))
},
THREE.ShaderMaterial.prototype = Object.create(THREE.Material.prototype),
THREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial,
THREE.ShaderMaterial.prototype.copy = function(e) {
    return THREE.Material.prototype.copy.call(this, e),
    this.fragmentShader = e.fragmentShader,
    this.vertexShader = e.vertexShader,
    this.uniforms = THREE.UniformsUtils.clone(e.uniforms),
    this.defines = e.defines,
    this.shading = e.shading,
    this.wireframe = e.wireframe,
    this.wireframeLinewidth = e.wireframeLinewidth,
    this.fog = e.fog,
    this.lights = e.lights,
    this.vertexColors = e.vertexColors,
    this.skinning = e.skinning,
    this.morphTargets = e.morphTargets,
    this.morphNormals = e.morphNormals,
    this.extensions = e.extensions,
    this
},
THREE.ShaderMaterial.prototype.toJSON = function(e) {
    return e = THREE.Material.prototype.toJSON.call(this, e),
    e.uniforms = this.uniforms,
    e.vertexShader = this.vertexShader,
    e.fragmentShader = this.fragmentShader,
    e
},
THREE.RawShaderMaterial = function(e) {
    THREE.ShaderMaterial.call(this, e),
    this.type = "RawShaderMaterial"
},
THREE.RawShaderMaterial.prototype = Object.create(THREE.ShaderMaterial.prototype),
THREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial,
THREE.SpriteMaterial = function(e) {
    THREE.Material.call(this),
    this.type = "SpriteMaterial",
    this.color = new THREE.Color(16777215),
    this.map = null,
    this.rotation = 0,
    this.fog = !1,
    this.setValues(e)
},
THREE.SpriteMaterial.prototype = Object.create(THREE.Material.prototype),
THREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial,
THREE.SpriteMaterial.prototype.copy = function(e) {
    return THREE.Material.prototype.copy.call(this, e),
    this.color.copy(e.color),
    this.map = e.map,
    this.rotation = e.rotation,
    this.fog = e.fog,
    this
},
THREE.Texture = function(e, t, n, r, i, s, o, u, a) {
    Object.defineProperty(this, "id", {
        value: THREE.TextureIdCount++
    }),
    this.uuid = THREE.Math.generateUUID(),
    this.sourceFile = this.name = "",
    this.image = void 0 !== e ? e: THREE.Texture.DEFAULT_IMAGE,
    this.mipmaps = [],
    this.mapping = void 0 !== t ? t: THREE.Texture.DEFAULT_MAPPING,
    this.wrapS = void 0 !== n ? n: THREE.ClampToEdgeWrapping,
    this.wrapT = void 0 !== r ? r: THREE.ClampToEdgeWrapping,
    this.magFilter = void 0 !== i ? i: THREE.LinearFilter,
    this.minFilter = void 0 !== s ? s: THREE.LinearMipMapLinearFilter,
    this.anisotropy = void 0 !== a ? a: 1,
    this.format = void 0 !== o ? o: THREE.RGBAFormat,
    this.type = void 0 !== u ? u: THREE.UnsignedByteType,
    this.offset = new THREE.Vector2(0, 0),
    this.repeat = new THREE.Vector2(1, 1),
    this.generateMipmaps = !0,
    this.premultiplyAlpha = !1,
    this.flipY = !0,
    this.unpackAlignment = 4,
    this.encoding = THREE.LinearEncoding,
    this.version = 0,
    this.onUpdate = null
},
THREE.Texture.DEFAULT_IMAGE = void 0,
THREE.Texture.DEFAULT_MAPPING = THREE.UVMapping,
THREE.Texture.prototype = {
    constructor: THREE.Texture,
    set needsUpdate(e) { ! 0 === e && this.version++
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(e) {
        return this.image = e.image,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.encoding = e.encoding,
        this
    },
    toJSON: function(e) {
        if (void 0 !== e.textures[this.uuid]) return e.textures[this.uuid];
        var t = {
            metadata: {
                version: 4.4,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            mapping: this.mapping,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            wrap: [this.wrapS, this.wrapT],
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy
        };
        if (void 0 !== this.image) {
            var n = this.image;
            void 0 === n.uuid && (n.uuid = THREE.Math.generateUUID());
            if (void 0 === e.images[n.uuid]) {
                var r = e.images,
                i = n.uuid,
                s = n.uuid,
                o;
                void 0 !== n.toDataURL ? o = n: (o = document.createElement("canvas"), o.width = n.width, o.height = n.height, o.getContext("2d").drawImage(n, 0, 0, n.width, n.height)),
                o = 2048 < o.width || 2048 < o.height ? o.toDataURL("image/jpeg", .6) : o.toDataURL("image/png"),
                r[i] = {
                    uuid: s,
                    url: o
                }
            }
            t.image = n.uuid
        }
        return e.textures[this.uuid] = t
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    },
    transformUv: function(e) {
        if (this.mapping === THREE.UVMapping) {
            e.multiply(this.repeat),
            e.add(this.offset);
            if (0 > e.x || 1 < e.x) switch (this.wrapS) {
            case THREE.RepeatWrapping:
                e.x -= Math.floor(e.x);
                break;
            case THREE.ClampToEdgeWrapping:
                e.x = 0 > e.x ? 0 : 1;
                break;
            case THREE.MirroredRepeatWrapping:
                1 === Math.abs(Math.floor(e.x) % 2) ? e.x = Math.ceil(e.x) - e.x: e.x -= Math.floor(e.x)
            }
            if (0 > e.y || 1 < e.y) switch (this.wrapT) {
            case THREE.RepeatWrapping:
                e.y -= Math.floor(e.y);
                break;
            case THREE.ClampToEdgeWrapping:
                e.y = 0 > e.y ? 0 : 1;
                break;
            case THREE.MirroredRepeatWrapping:
                1 === Math.abs(Math.floor(e.y) % 2) ? e.y = Math.ceil(e.y) - e.y: e.y -= Math.floor(e.y)
            }
            this.flipY && (e.y = 1 - e.y)
        }
    }
},
THREE.EventDispatcher.prototype.apply(THREE.Texture.prototype),
THREE.TextureIdCount = 0,
THREE.CanvasTexture = function(e, t, n, r, i, s, o, u, a) {
    THREE.Texture.call(this, e, t, n, r, i, s, o, u, a),
    this.needsUpdate = !0
},
THREE.CanvasTexture.prototype = Object.create(THREE.Texture.prototype),
THREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture,
THREE.CubeTexture = function(e, t, n, r, i, s, o, u, a) {
    e = void 0 !== e ? e: [],
    t = void 0 !== t ? t: THREE.CubeReflectionMapping,
    THREE.Texture.call(this, e, t, n, r, i, s, o, u, a),
    this.flipY = !1
},
THREE.CubeTexture.prototype = Object.create(THREE.Texture.prototype),
THREE.CubeTexture.prototype.constructor = THREE.CubeTexture,
Object.defineProperty(THREE.CubeTexture.prototype, "images", {
    get: function() {
        return this.image
    },
    set: function(e) {
        this.image = e
    }
}),
THREE.CompressedTexture = function(e, t, n, r, i, s, o, u, a, f, l) {
    THREE.Texture.call(this, null, s, o, u, a, f, r, i, l),
    this.image = {
        width: t,
        height: n
    },
    this.mipmaps = e,
    this.generateMipmaps = this.flipY = !1
},
THREE.CompressedTexture.prototype = Object.create(THREE.Texture.prototype),
THREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture,
THREE.DataTexture = function(e, t, n, r, i, s, o, u, a, f, l) {
    THREE.Texture.call(this, null, s, o, u, a, f, r, i, l),
    this.image = {
        data: e,
        width: t,
        height: n
    },
    this.magFilter = void 0 !== a ? a: THREE.NearestFilter,
    this.minFilter = void 0 !== f ? f: THREE.NearestFilter,
    this.generateMipmaps = this.flipY = !1
},
THREE.DataTexture.prototype = Object.create(THREE.Texture.prototype),
THREE.DataTexture.prototype.constructor = THREE.DataTexture,
THREE.VideoTexture = function(e, t, n, r, i, s, o, u, a) {
    function f() {
        requestAnimationFrame(f),
        e.readyState === e.HAVE_ENOUGH_DATA && (l.needsUpdate = !0)
    }
    THREE.Texture.call(this, e, t, n, r, i, s, o, u, a),
    this.generateMipmaps = !1;
    var l = this;
    f()
},
THREE.VideoTexture.prototype = Object.create(THREE.Texture.prototype),
THREE.VideoTexture.prototype.constructor = THREE.VideoTexture,
THREE.Group = function() {
    THREE.Object3D.call(this),
    this.type = "Group"
},
THREE.Group.prototype = Object.create(THREE.Object3D.prototype),
THREE.Group.prototype.constructor = THREE.Group,
THREE.Points = function(e, t) {
    THREE.Object3D.call(this),
    this.type = "Points",
    this.geometry = void 0 !== e ? e: new THREE.Geometry,
    this.material = void 0 !== t ? t: new THREE.PointsMaterial({
        color: 16777215 * Math.random()
    })
},
THREE.Points.prototype = Object.create(THREE.Object3D.prototype),
THREE.Points.prototype.constructor = THREE.Points,
THREE.Points.prototype.raycast = function() {
    var e = new THREE.Matrix4,
    t = new THREE.Ray,
    n = new THREE.Sphere;
    return function(r, i) {
        function s(e, n) {
            var s = t.distanceSqToPoint(e);
            if (s < h) {
                var u = t.closestPointToPoint(e);
                u.applyMatrix4(f);
                var a = r.ray.origin.distanceTo(u);
                a < r.near || a > r.far || i.push({
                    distance: a,
                    distanceToRay: Math.sqrt(s),
                    point: u.clone(),
                    index: n,
                    face: null,
                    object: o
                })
            }
        }
        var o = this,
        u = this.geometry,
        f = this.matrixWorld,
        l = r.params.Points.threshold;
        null === u.boundingSphere && u.computeBoundingSphere(),
        n.copy(u.boundingSphere),
        n.applyMatrix4(f);
        if (!1 !== r.ray.intersectsSphere(n)) {
            e.getInverse(f),
            t.copy(r.ray).applyMatrix4(e);
            var l = l / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            h = l * l,
            l = new THREE.Vector3;
            if (u instanceof THREE.BufferGeometry) {
                var p = u.index,
                u = u.attributes.position.array;
                if (null !== p) for (var d = p.array,
                p = 0,
                v = d.length; p < v; p++) {
                    var m = d[p];
                    l.fromArray(u, 3 * m),
                    s(l, m)
                } else for (p = 0, d = u.length / 3; p < d; p++) l.fromArray(u, 3 * p),
                s(l, p)
            } else for (l = u.vertices, p = 0, d = l.length; p < d; p++) s(l[p], p)
        }
    }
} (),
THREE.Points.prototype.clone = function() {
    return (new this.constructor(this.geometry, this.material)).copy(this)
},
THREE.Line = function(e, t, n) {
    if (1 === n) return console.warn("THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead."),
    new THREE.LineSegments(e, t);
    THREE.Object3D.call(this),
    this.type = "Line",
    this.geometry = void 0 !== e ? e: new THREE.Geometry,
    this.material = void 0 !== t ? t: new THREE.LineBasicMaterial({
        color: 16777215 * Math.random()
    })
},
THREE.Line.prototype = Object.create(THREE.Object3D.prototype),
THREE.Line.prototype.constructor = THREE.Line,
THREE.Line.prototype.raycast = function() {
    var e = new THREE.Matrix4,
    t = new THREE.Ray,
    n = new THREE.Sphere;
    return function(r, i) {
        var s = r.linePrecision,
        s = s * s,
        o = this.geometry,
        u = this.matrixWorld;
        null === o.boundingSphere && o.computeBoundingSphere(),
        n.copy(o.boundingSphere),
        n.applyMatrix4(u);
        if (!1 !== r.ray.intersectsSphere(n)) {
            e.getInverse(u),
            t.copy(r.ray).applyMatrix4(e);
            var f = new THREE.Vector3,
            l = new THREE.Vector3,
            u = new THREE.Vector3,
            h = new THREE.Vector3,
            p = this instanceof THREE.LineSegments ? 2 : 1;
            if (o instanceof THREE.BufferGeometry) {
                var d = o.index,
                v = o.attributes.position.array;
                if (null !== d) for (var d = d.array,
                o = 0,
                m = d.length - 1; o < m; o += p) {
                    var g = d[o + 1];
                    f.fromArray(v, 3 * d[o]),
                    l.fromArray(v, 3 * g),
                    g = t.distanceSqToSegment(f, l, h, u),
                    g > s || (h.applyMatrix4(this.matrixWorld), g = r.ray.origin.distanceTo(h), g < r.near || g > r.far || i.push({
                        distance: g,
                        point: u.clone().applyMatrix4(this.matrixWorld),
                        index: o,
                        face: null,
                        faceIndex: null,
                        object: this
                    }))
                } else for (o = 0, m = v.length / 3 - 1; o < m; o += p) f.fromArray(v, 3 * o),
                l.fromArray(v, 3 * o + 3),
                g = t.distanceSqToSegment(f, l, h, u),
                g > s || (h.applyMatrix4(this.matrixWorld), g = r.ray.origin.distanceTo(h), g < r.near || g > r.far || i.push({
                    distance: g,
                    point: u.clone().applyMatrix4(this.matrixWorld),
                    index: o,
                    face: null,
                    faceIndex: null,
                    object: this
                }))
            } else if (o instanceof THREE.Geometry) for (f = o.vertices, l = f.length, o = 0; o < l - 1; o += p) g = t.distanceSqToSegment(f[o], f[o + 1], h, u),
            g > s || (h.applyMatrix4(this.matrixWorld), g = r.ray.origin.distanceTo(h), g < r.near || g > r.far || i.push({
                distance: g,
                point: u.clone().applyMatrix4(this.matrixWorld),
                index: o,
                face: null,
                faceIndex: null,
                object: this
            }))
        }
    }
} (),
THREE.Line.prototype.clone = function() {
    return (new this.constructor(this.geometry, this.material)).copy(this)
},
THREE.LineStrip = 0,
THREE.LinePieces = 1,
THREE.LineSegments = function(e, t) {
    THREE.Line.call(this, e, t),
    this.type = "LineSegments"
},
THREE.LineSegments.prototype = Object.create(THREE.Line.prototype),
THREE.LineSegments.prototype.constructor = THREE.LineSegments,
THREE.Mesh = function(e, t) {
    THREE.Object3D.call(this),
    this.type = "Mesh",
    this.geometry = void 0 !== e ? e: new THREE.Geometry,
    this.material = void 0 !== t ? t: new THREE.MeshBasicMaterial({
        color: 16777215 * Math.random()
    }),
    this.drawMode = THREE.TrianglesDrawMode,
    this.updateMorphTargets()
},
THREE.Mesh.prototype = Object.create(THREE.Object3D.prototype),
THREE.Mesh.prototype.constructor = THREE.Mesh,
THREE.Mesh.prototype.setDrawMode = function(e) {
    this.drawMode = e
},
THREE.Mesh.prototype.updateMorphTargets = function() {
    if (void 0 !== this.geometry.morphTargets && 0 < this.geometry.morphTargets.length) {
        this.morphTargetBase = -1,
        this.morphTargetInfluences = [],
        this.morphTargetDictionary = {};
        for (var e = 0,
        t = this.geometry.morphTargets.length; e < t; e++) this.morphTargetInfluences.push(0),
        this.morphTargetDictionary[this.geometry.morphTargets[e].name] = e
    }
},
THREE.Mesh.prototype.getMorphTargetIndexByName = function(e) {
    return void 0 !== this.morphTargetDictionary[e] ? this.morphTargetDictionary[e] : (console.warn("THREE.Mesh.getMorphTargetIndexByName: morph target " + e + " does not exist. Returning 0."), 0)
},
THREE.Mesh.prototype.raycast = function() {
    function e(e, t, n, r, i, s, o) {
        return THREE.Triangle.barycoordFromPoint(e, t, n, r, v),
        i.multiplyScalar(v.x),
        s.multiplyScalar(v.y),
        o.multiplyScalar(v.z),
        i.add(s).add(o),
        i.clone()
    }
    function t(e, t, n, r, i, s, o) {
        var u = e.material;
        return null === (u.side === THREE.BackSide ? n.intersectTriangle(s, i, r, !0, o) : n.intersectTriangle(r, i, s, u.side !== THREE.DoubleSide, o)) ? null: (g.copy(o), g.applyMatrix4(e.matrixWorld), n = t.ray.origin.distanceTo(g), n < t.near || n > t.far ? null: {
            distance: n,
            point: g.clone(),
            object: e
        })
    }
    function n(n, r, i, s, f, l, c, v) {
        o.fromArray(s, 3 * l),
        u.fromArray(s, 3 * c),
        a.fromArray(s, 3 * v);
        if (n = t(n, r, i, o, u, a, m)) f && (h.fromArray(f, 2 * l), p.fromArray(f, 2 * c), d.fromArray(f, 2 * v), n.uv = e(m, o, u, a, h, p, d)),
        n.face = new THREE.Face3(l, c, v, THREE.Triangle.normal(o, u, a)),
        n.faceIndex = l;
        return n
    }
    var r = new THREE.Matrix4,
    i = new THREE.Ray,
    s = new THREE.Sphere,
    o = new THREE.Vector3,
    u = new THREE.Vector3,
    a = new THREE.Vector3,
    f = new THREE.Vector3,
    l = new THREE.Vector3,
    c = new THREE.Vector3,
    h = new THREE.Vector2,
    p = new THREE.Vector2,
    d = new THREE.Vector2,
    v = new THREE.Vector3,
    m = new THREE.Vector3,
    g = new THREE.Vector3;
    return function(v, g) {
        var y = this.geometry,
        w = this.material,
        E = this.matrixWorld;
        if (void 0 !== w && (null === y.boundingSphere && y.computeBoundingSphere(), s.copy(y.boundingSphere), s.applyMatrix4(E), !1 !== v.ray.intersectsSphere(s) && (r.getInverse(E), i.copy(v.ray).applyMatrix4(r), null === y.boundingBox || !1 !== i.intersectsBox(y.boundingBox)))) {
            var S, x;
            if (y instanceof THREE.BufferGeometry) {
                var T, N, w = y.index,
                E = y.attributes,
                y = E.position.array;
                void 0 !== E.uv && (S = E.uv.array);
                if (null !== w) {
                    for (var E = w.array,
                    C = 0,
                    L = E.length; C < L; C += 3) if (w = E[C], T = E[C + 1], N = E[C + 2], x = n(this, v, i, y, S, w, T, N)) x.faceIndex = Math.floor(C / 3),
                    g.push(x)
                } else for (C = 0, L = y.length; C < L; C += 9) if (w = C / 3, T = w + 1, N = w + 2, x = n(this, v, i, y, S, w, T, N)) x.index = w,
                g.push(x)
            } else if (y instanceof THREE.Geometry) {
                var A, O, E = w instanceof THREE.MultiMaterial,
                C = !0 === E ? w.materials: null,
                L = y.vertices;
                T = y.faces,
                N = y.faceVertexUvs[0],
                0 < N.length && (S = N);
                for (var M = 0,
                _ = T.length; M < _; M++) {
                    var D = T[M];
                    x = !0 === E ? C[D.materialIndex] : w;
                    if (void 0 !== x) {
                        N = L[D.a],
                        A = L[D.b],
                        O = L[D.c];
                        if (!0 === x.morphTargets) {
                            x = y.morphTargets;
                            var P = this.morphTargetInfluences;
                            o.set(0, 0, 0),
                            u.set(0, 0, 0),
                            a.set(0, 0, 0);
                            for (var H = 0,
                            B = x.length; H < B; H++) {
                                var j = P[H];
                                if (0 !== j) {
                                    var F = x[H].vertices;
                                    o.addScaledVector(f.subVectors(F[D.a], N), j),
                                    u.addScaledVector(l.subVectors(F[D.b], A), j),
                                    a.addScaledVector(c.subVectors(F[D.c], O), j)
                                }
                            }
                            o.add(N),
                            u.add(A),
                            a.add(O),
                            N = o,
                            A = u,
                            O = a
                        }
                        if (x = t(this, v, i, N, A, O, m)) S && (P = S[M], h.copy(P[0]), p.copy(P[1]), d.copy(P[2]), x.uv = e(m, N, A, O, h, p, d)),
                        x.face = D,
                        x.faceIndex = M,
                        g.push(x)
                    }
                }
            }
        }
    }
} (),
THREE.Mesh.prototype.clone = function() {
    return (new this.constructor(this.geometry, this.material)).copy(this)
},
THREE.Bone = function(e) {
    THREE.Object3D.call(this),
    this.type = "Bone",
    this.skin = e
},
THREE.Bone.prototype = Object.create(THREE.Object3D.prototype),
THREE.Bone.prototype.constructor = THREE.Bone,
THREE.Bone.prototype.copy = function(e) {
    return THREE.Object3D.prototype.copy.call(this, e),
    this.skin = e.skin,
    this
},
THREE.Skeleton = function(e, t, n) {
    this.useVertexTexture = void 0 !== n ? n: !0,
    this.identityMatrix = new THREE.Matrix4,
    e = e || [],
    this.bones = e.slice(0),
    this.useVertexTexture ? (e = Math.sqrt(4 * this.bones.length), e = THREE.Math.nextPowerOfTwo(Math.ceil(e)), this.boneTextureHeight = this.boneTextureWidth = e = Math.max(e, 4), this.boneMatrices = new Float32Array(this.boneTextureWidth * this.boneTextureHeight * 4), this.boneTexture = new THREE.DataTexture(this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType)) : this.boneMatrices = new Float32Array(16 * this.bones.length);
    if (void 0 === t) this.calculateInverses();
    else if (this.bones.length === t.length) this.boneInverses = t.slice(0);
    else for (console.warn("THREE.Skeleton bonInverses is the wrong length."), this.boneInverses = [], t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new THREE.Matrix4)
},
THREE.Skeleton.prototype.calculateInverses = function() {
    this.boneInverses = [];
    for (var e = 0,
    t = this.bones.length; e < t; e++) {
        var n = new THREE.Matrix4;
        this.bones[e] && n.getInverse(this.bones[e].matrixWorld),
        this.boneInverses.push(n)
    }
},
THREE.Skeleton.prototype.pose = function() {
    for (var e, t = 0,
    n = this.bones.length; t < n; t++)(e = this.bones[t]) && e.matrixWorld.getInverse(this.boneInverses[t]);
    t = 0;
    for (n = this.bones.length; t < n; t++) if (e = this.bones[t]) e.parent ? (e.matrix.getInverse(e.parent.matrixWorld), e.matrix.multiply(e.matrixWorld)) : e.matrix.copy(e.matrixWorld),
    e.matrix.decompose(e.position, e.quaternion, e.scale)
},
THREE.Skeleton.prototype.update = function() {
    var e = new THREE.Matrix4;
    return function() {
        for (var t = 0,
        n = this.bones.length; t < n; t++) e.multiplyMatrices(this.bones[t] ? this.bones[t].matrixWorld: this.identityMatrix, this.boneInverses[t]),
        e.flattenToArrayOffset(this.boneMatrices, 16 * t);
        this.useVertexTexture && (this.boneTexture.needsUpdate = !0)
    }
} (),
THREE.Skeleton.prototype.clone = function() {
    return new THREE.Skeleton(this.bones, this.boneInverses, this.useVertexTexture)
},
THREE.SkinnedMesh = function(e, t, n) {
    THREE.Mesh.call(this, e, t),
    this.type = "SkinnedMesh",
    this.bindMode = "attached",
    this.bindMatrix = new THREE.Matrix4,
    this.bindMatrixInverse = new THREE.Matrix4,
    e = [];
    if (this.geometry && void 0 !== this.geometry.bones) {
        for (var r, i = 0,
        s = this.geometry.bones.length; i < s; ++i) r = this.geometry.bones[i],
        t = new THREE.Bone(this),
        e.push(t),
        t.name = r.name,
        t.position.fromArray(r.pos),
        t.quaternion.fromArray(r.rotq),
        void 0 !== r.scl && t.scale.fromArray(r.scl);
        i = 0;
        for (s = this.geometry.bones.length; i < s; ++i) r = this.geometry.bones[i],
        -1 !== r.parent && null !== r.parent ? e[r.parent].add(e[i]) : this.add(e[i])
    }
    this.normalizeSkinWeights(),
    this.updateMatrixWorld(!0),
    this.bind(new THREE.Skeleton(e, void 0, n), this.matrixWorld)
},
THREE.SkinnedMesh.prototype = Object.create(THREE.Mesh.prototype),
THREE.SkinnedMesh.prototype.constructor = THREE.SkinnedMesh,
THREE.SkinnedMesh.prototype.bind = function(e, t) {
    this.skeleton = e,
    void 0 === t && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld),
    this.bindMatrix.copy(t),
    this.bindMatrixInverse.getInverse(t)
},
THREE.SkinnedMesh.prototype.pose = function() {
    this.skeleton.pose()
},
THREE.SkinnedMesh.prototype.normalizeSkinWeights = function() {
    if (this.geometry instanceof THREE.Geometry) for (var e = 0; e < this.geometry.skinWeights.length; e++) {
        var t = this.geometry.skinWeights[e],
        n = 1 / t.lengthManhattan();
        Infinity !== n ? t.multiplyScalar(n) : t.set(1, 0, 0, 0)
    } else if (this.geometry instanceof THREE.BufferGeometry) for (var t = new THREE.Vector4,
    r = this.geometry.attributes.skinWeight,
    e = 0; e < r.count; e++) t.x = r.getX(e),
    t.y = r.getY(e),
    t.z = r.getZ(e),
    t.w = r.getW(e),
    n = 1 / t.lengthManhattan(),
    Infinity !== n ? t.multiplyScalar(n) : t.set(1, 0, 0, 0),
    r.setXYZW(e, t.x, t.y, t.z, t.w)
},
THREE.SkinnedMesh.prototype.updateMatrixWorld = function(e) {
    THREE.Mesh.prototype.updateMatrixWorld.call(this, !0),
    "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh unrecognized bindMode: " + this.bindMode)
},
THREE.SkinnedMesh.prototype.clone = function() {
    return (new this.constructor(this.geometry, this.material, this.useVertexTexture)).copy(this)
},
THREE.LOD = function() {
    THREE.Object3D.call(this),
    this.type = "LOD",
    Object.defineProperties(this, {
        levels: {
            enumerable: !0,
            value: []
        },
        objects: {
            get: function() {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."),
                this.levels
            }
        }
    })
},
THREE.LOD.prototype = Object.create(THREE.Object3D.prototype),
THREE.LOD.prototype.constructor = THREE.LOD,
THREE.LOD.prototype.addLevel = function(e, t) {
    void 0 === t && (t = 0),
    t = Math.abs(t);
    for (var n = this.levels,
    r = 0; r < n.length && !(t < n[r].distance); r++);
    n.splice(r, 0, {
        distance: t,
        object: e
    }),
    this.add(e)
},
THREE.LOD.prototype.getObjectForDistance = function(e) {
    for (var t = this.levels,
    n = 1,
    r = t.length; n < r && !(e < t[n].distance); n++);
    return t[n - 1].object
},
THREE.LOD.prototype.raycast = function() {
    var e = new THREE.Vector3;
    return function(t, n) {
        e.setFromMatrixPosition(this.matrixWorld);
        var r = t.ray.origin.distanceTo(e);
        this.getObjectForDistance(r).raycast(t, n)
    }
} (),
THREE.LOD.prototype.update = function() {
    var e = new THREE.Vector3,
    t = new THREE.Vector3;
    return function(n) {
        var r = this.levels;
        if (1 < r.length) {
            e.setFromMatrixPosition(n.matrixWorld),
            t.setFromMatrixPosition(this.matrixWorld),
            n = e.distanceTo(t),
            r[0].object.visible = !0;
            for (var i = 1,
            s = r.length; i < s; i++) {
                if (! (n >= r[i].distance)) break;
                r[i - 1].object.visible = !1,
                r[i].object.visible = !0
            }
            for (; i < s; i++) r[i].object.visible = !1
        }
    }
} (),
THREE.LOD.prototype.copy = function(e) {
    THREE.Object3D.prototype.copy.call(this, e, !1),
    e = e.levels;
    for (var t = 0,
    n = e.length; t < n; t++) {
        var r = e[t];
        this.addLevel(r.object.clone(), r.distance)
    }
    return this
},
THREE.LOD.prototype.toJSON = function(e) {
    e = THREE.Object3D.prototype.toJSON.call(this, e),
    e.object.levels = [];
    for (var t = this.levels,
    n = 0,
    r = t.length; n < r; n++) {
        var i = t[n];
        e.object.levels.push({
            object: i.object.uuid,
            distance: i.distance
        })
    }
    return e
},
THREE.Sprite = function() {
    var e = new Uint16Array([0, 1, 2, 0, 2, 3]),
    t = new Float32Array([ - 0.5, -0.5, 0, .5, -0.5, 0, .5, .5, 0, -0.5, .5, 0]),
    n = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
    r = new THREE.BufferGeometry;
    return r.setIndex(new THREE.BufferAttribute(e, 1)),
    r.addAttribute("position", new THREE.BufferAttribute(t, 3)),
    r.addAttribute("uv", new THREE.BufferAttribute(n, 2)),
    function(e) {
        THREE.Object3D.call(this),
        this.type = "Sprite",
        this.geometry = r,
        this.material = void 0 !== e ? e: new THREE.SpriteMaterial
    }
} (),
THREE.Sprite.prototype = Object.create(THREE.Object3D.prototype),
THREE.Sprite.prototype.constructor = THREE.Sprite,
THREE.Sprite.prototype.raycast = function() {
    var e = new THREE.Vector3;
    return function(t, n) {
        e.setFromMatrixPosition(this.matrixWorld);
        var r = t.ray.distanceSqToPoint(e);
        r > this.scale.x * this.scale.y || n.push({
            distance: Math.sqrt(r),
            point: this.position,
            face: null,
            object: this
        })
    }
} (),
THREE.Sprite.prototype.clone = function() {
    return (new this.constructor(this.material)).copy(this)
},
THREE.Particle = THREE.Sprite,
THREE.LensFlare = function(e, t, n, r, i) {
    THREE.Object3D.call(this),
    this.lensFlares = [],
    this.positionScreen = new THREE.Vector3,
    this.customUpdateCallback = void 0,
    void 0 !== e && this.add(e, t, n, r, i)
},
THREE.LensFlare.prototype = Object.create(THREE.Object3D.prototype),
THREE.LensFlare.prototype.constructor = THREE.LensFlare,
THREE.LensFlare.prototype.add = function(e, t, n, r, i, s) {
    void 0 === t && (t = -1),
    void 0 === n && (n = 0),
    void 0 === s && (s = 1),
    void 0 === i && (i = new THREE.Color(16777215)),
    void 0 === r && (r = THREE.NormalBlending),
    n = Math.min(n, Math.max(0, n)),
    this.lensFlares.push({
        texture: e,
        size: t,
        distance: n,
        x: 0,
        y: 0,
        z: 0,
        scale: 1,
        rotation: 0,
        opacity: s,
        color: i,
        blending: r
    })
},
THREE.LensFlare.prototype.updateLensFlares = function() {
    var e, t = this.lensFlares.length,
    n, r = 2 * -this.positionScreen.x,
    i = 2 * -this.positionScreen.y;
    for (e = 0; e < t; e++) n = this.lensFlares[e],
    n.x = this.positionScreen.x + r * n.distance,
    n.y = this.positionScreen.y + i * n.distance,
    n.wantedRotation = n.x * Math.PI * .25,
    n.rotation += .25 * (n.wantedRotation - n.rotation)
},
THREE.LensFlare.prototype.copy = function(e) {
    THREE.Object3D.prototype.copy.call(this, e),
    this.positionScreen.copy(e.positionScreen),
    this.customUpdateCallback = e.customUpdateCallback;
    for (var t = 0,
    n = e.lensFlares.length; t < n; t++) this.lensFlares.push(e.lensFlares[t]);
    return this
},
THREE.Scene = function() {
    THREE.Object3D.call(this),
    this.type = "Scene",
    this.overrideMaterial = this.fog = null,
    this.autoUpdate = !0
},
THREE.Scene.prototype = Object.create(THREE.Object3D.prototype),
THREE.Scene.prototype.constructor = THREE.Scene,
THREE.Scene.prototype.copy = function(e, t) {
    return THREE.Object3D.prototype.copy.call(this, e, t),
    null !== e.fog && (this.fog = e.fog.clone()),
    null !== e.overrideMaterial && (this.overrideMaterial = e.overrideMaterial.clone()),
    this.autoUpdate = e.autoUpdate,
    this.matrixAutoUpdate = e.matrixAutoUpdate,
    this
},
THREE.Fog = function(e, t, n) {
    this.name = "",
    this.color = new THREE.Color(e),
    this.near = void 0 !== t ? t: 1,
    this.far = void 0 !== n ? n: 1e3
},
THREE.Fog.prototype.clone = function() {
    return new THREE.Fog(this.color.getHex(), this.near, this.far)
},
THREE.FogExp2 = function(e, t) {
    this.name = "",
    this.color = new THREE.Color(e),
    this.density = void 0 !== t ? t: 25e-5
},
THREE.FogExp2.prototype.clone = function() {
    return new THREE.FogExp2(this.color.getHex(), this.density)
},
THREE.ShaderChunk = {},
THREE.ShaderChunk.alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n",
THREE.ShaderChunk.alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif\n",
THREE.ShaderChunk.alphatest_fragment = "#ifdef ALPHATEST\n	if ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n",
THREE.ShaderChunk.aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n	#endif\n#endif\n",
THREE.ShaderChunk.aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif",
THREE.ShaderChunk.begin_vertex = "\nvec3 transformed = vec3( position );\n",
THREE.ShaderChunk.beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n",
THREE.ShaderChunk.bsdfs = "bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\n	return any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n		if( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n			float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n			float maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n			return distanceFalloff * maxDistanceCutoffFactor;\n#else\n			return pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n		}\n		return 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n	float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n	return ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	float gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	return 1.0 / ( gl * gv );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_GGX_Smith( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( G * D );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n	float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n	return specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n	float dotNH = saturate( dot( geometry.normal, halfDir ) );\n	float dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n	vec3 F = F_Schlick( specularColor, dotLH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n	return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n	return sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n",
THREE.ShaderChunk.bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n		vec3 vSigmaX = dFdx( surf_pos );\n		vec3 vSigmaY = dFdy( surf_pos );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 );\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif\n",
THREE.ShaderChunk.color_fragment = "#ifdef USE_COLOR\n	diffuseColor.rgb *= vColor;\n#endif",
THREE.ShaderChunk.color_pars_fragment = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif\n",
THREE.ShaderChunk.color_pars_vertex = "#ifdef USE_COLOR\n	varying vec3 vColor;\n#endif",
THREE.ShaderChunk.color_vertex = "#ifdef USE_COLOR\n	vColor.xyz = color.xyz;\n#endif",
THREE.ShaderChunk.common = "#define PI 3.14159\n#define PI2 6.28318\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	float distance = dot( planeNormal, point - pointOnPlane );\n	return - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n	return lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\n",
THREE.ShaderChunk.cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\nconst float cubeUV_textureSize = 1024.0;\nint getFaceFromDirection(vec3 direction) {\n    vec3 absDirection = abs(direction);\n    int face = -1;\n    if( absDirection.x > absDirection.z ) {\n        if(absDirection.x > absDirection.y )\n            face = direction.x > 0.0 ? 0 : 3;\n        else\n            face = direction.y > 0.0 ? 1 : 4;\n    }\n    else {\n        if(absDirection.z > absDirection.y )\n            face = direction.z > 0.0 ? 2 : 5;\n        else\n            face = direction.y > 0.0 ? 1 : 4;\n    }\n    return face;\n}\nconst float cubeUV_maxLods1 = log2(cubeUV_textureSize*0.25) - 1.0;\nconst float cubeUV_rangeClamp = exp2((6.0 - 1.0) * 2.0);\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n    float scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n    float dxRoughness = dFdx(roughness);\n    float dyRoughness = dFdy(roughness);\n    vec3 dx = dFdx( vec * scale * dxRoughness );\n    vec3 dy = dFdy( vec * scale * dyRoughness );\n    float d = max( dot( dx, dx ), dot( dy, dy ) );\n    d = clamp(d, 1.0, cubeUV_rangeClamp);\n    float mipLevel = 0.5 * log2(d);\n    return vec2(floor(mipLevel), fract(mipLevel));\n}\nconst float cubeUV_maxLods2 = log2(cubeUV_textureSize*0.25) - 2.0;\nconst float cubeUV_rcpTextureSize = 1.0 / cubeUV_textureSize;\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n    mipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n    float a = 16.0 * cubeUV_rcpTextureSize;\n    vec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n    vec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n    float powScale = exp2_packed.x * exp2_packed.y;\n    float scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n    float mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n    bool bRes = mipLevel == 0.0;\n    scale =  bRes && (scale < a) ? a : scale;\n    vec3 r;\n    vec2 offset;\n    int face = getFaceFromDirection(direction);\n    float rcpPowScale = 1.0 / powScale;\n    if( face == 0) {\n        r = vec3(direction.x, -direction.z, direction.y);\n        offset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n    }\n    else if( face == 1) {\n        r = vec3(direction.y, direction.x, direction.z);\n        offset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n    }\n    else if( face == 2) {\n        r = vec3(direction.z, direction.x, direction.y);\n        offset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n    }\n    else if( face == 3) {\n        r = vec3(direction.x, direction.z, direction.y);\n        offset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n    }\n    else if( face == 4) {\n        r = vec3(direction.y, direction.x, -direction.z);\n        offset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n    }\n    else {\n        r = vec3(direction.z, -direction.x, direction.y);\n        offset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n        offset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n    }\n    r = normalize(r);\n    float texelOffset = 0.5 * cubeUV_rcpTextureSize;\n    vec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n    vec2 base = offset + vec2( texelOffset );\n    return base + s * ( scale - 2.0 * texelOffset );\n}\nconst float cubeUV_maxLods3 = log2(cubeUV_textureSize*0.25) - 3.0;\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n    float roughnessVal = roughness* cubeUV_maxLods3;\n    float r1 = floor(roughnessVal);\n    float r2 = r1 + 1.0;\n    float t = fract(roughnessVal);\n    vec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n    float s = mipInfo.y;\n    float level0 = mipInfo.x;\n    float level1 = level0 + 1.0;\n    level1 = level1 > 5.0 ? 5.0 : level1;\n    level0 += min( floor( s + 0.5 ), 5.0 );\n    vec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n    vec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n    vec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n    vec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n    vec4 result = mix(color10, color20, t);\n    return vec4(result.rgb, 1.0);\n}\n#endif\n",
THREE.ShaderChunk.defaultnormal_vertex = "#ifdef FLIP_SIDED\n	objectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n",
THREE.ShaderChunk.displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n",
THREE.ShaderChunk.displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif\n",
THREE.ShaderChunk.emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n",
THREE.ShaderChunk.emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif\n",
THREE.ShaderChunk.encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n",
THREE.ShaderChunk.encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n",
THREE.ShaderChunk.envmap_fragment = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		vec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToVertex, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef DOUBLE_SIDED\n		float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n	#else\n		float flipNormal = 1.0;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_EQUIREC )\n		vec2 sampleUV;\n		sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n		sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n		vec4 envColor = texture2D( envMap, sampleUV );\n	#elif defined( ENVMAP_TYPE_SPHERE )\n		vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n		vec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n	#endif\n	envColor = envMapTexelToLinear( envColor );\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif\n",
THREE.ShaderChunk.envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( STANDARD )\n	uniform float reflectivity;\n	uniform float envMapIntenstiy;\n#endif\n#ifdef USE_ENVMAP\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	uniform float flipEnvMap;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( STANDARD )\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif\n",
THREE.ShaderChunk.envmap_pars_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n	varying vec3 vReflect;\n	uniform float refractionRatio;\n#endif\n",
THREE.ShaderChunk.envmap_vertex = "#if defined( USE_ENVMAP ) && ! defined( USE_BUMPMAP ) && ! defined( USE_NORMALMAP ) && ! defined( PHONG ) && ! defined( STANDARD )\n	vec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n	vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	#ifdef ENVMAP_MODE_REFLECTION\n		vReflect = reflect( cameraToVertex, worldNormal );\n	#else\n		vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n	#endif\n#endif\n",
THREE.ShaderChunk.fog_fragment = "#ifdef USE_FOG\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	#ifdef FOG_EXP2\n		float fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, depth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n",
THREE.ShaderChunk.fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif",
THREE.ShaderChunk.lightmap_fragment = "#ifdef USE_LIGHTMAP\n	reflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n",
THREE.ShaderChunk.lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif",
THREE.ShaderChunk.lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		directLight = getPointDirectLightIrradiance( pointLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		directLight = getSpotDirectLightIrradiance( spotLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directLight = getDirectionalDirectLightIrradiance( directionalLights[ i ], geometry );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = PI * directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		#ifdef DOUBLE_SIDED\n			vLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n		#endif\n	}\n#endif\n",
THREE.ShaderChunk.lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	return irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	IncidentLight getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		directLight.color = directionalLight.color;\n		directLight.direction = directionalLight.direction;\n		directLight.visible = true;\n		return directLight;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	IncidentLight getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		vec3 lVector = pointLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		if ( testLightInRange( lightDistance, pointLight.distance ) ) {\n			directLight.color = pointLight.color;\n			directLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n		return directLight;\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n		int shadow;\n		float shadowBias;\n		float shadowRadius;\n		vec2 shadowMapSize;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	IncidentLight getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry ) {\n		IncidentLight directLight;\n		vec3 lVector = spotLight.position - geometry.position;\n		directLight.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		float angleCos = dot( directLight.direction, spotLight.direction );\n		if ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\n			float spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n			directLight.color = spotLight.color;\n			directLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n			directLight.visible = true;\n		} else {\n			directLight.color = vec3( 0.0 );\n			directLight.visible = false;\n		}\n		return directLight;\n	}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n		float dotNL = dot( geometry.normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			irradiance *= PI;\n		#endif\n		return irradiance;\n	}\n#endif\n#if defined( USE_ENVMAP ) && defined( STANDARD )\n	vec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		vec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n			#endif\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n			vec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n		#else\n			vec4 envMapColor = vec4( 0.0 );\n		#endif\n		envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		return PI * envMapColor.rgb * envMapIntensity;\n	}\n	float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		float maxMIPLevelScalar = float( maxMIPLevel );\n		float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n		return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n	}\n	vec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n		#else\n			vec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n		#endif\n		#ifdef DOUBLE_SIDED\n			float flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n		#else\n			float flipNormal = 1.0;\n		#endif\n		reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n		float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n		#ifdef ENVMAP_TYPE_CUBE\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n			#else\n				vec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n			#endif\n		#elif defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n			vec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n		#elif defined( ENVMAP_TYPE_EQUIREC )\n			vec2 sampleUV;\n			sampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n			sampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n			#endif\n		#elif defined( ENVMAP_TYPE_SPHERE )\n			vec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\n			#ifdef TEXTURE_LOD_EXT\n				vec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#else\n				vec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n			#endif\n		#endif\n		envMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n		return envMapColor.rgb * envMapIntensity;\n	}\n#endif\n",
THREE.ShaderChunk.lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n",
THREE.ShaderChunk.lights_phong_pars_fragment = "#ifdef USE_ENVMAP\n	varying vec3 vWorldPosition;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n	vec3	diffuseColor;\n	vec3	specularColor;\n	float	specularShininess;\n	float	specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)\n",
THREE.ShaderChunk.lights_phong_pars_vertex = "#ifdef USE_ENVMAP\n	varying vec3 vWorldPosition;\n#endif\n",
THREE.ShaderChunk.lights_phong_vertex = "#ifdef USE_ENVMAP\n	vWorldPosition = worldPosition.xyz;\n#endif\n",
THREE.ShaderChunk.lights_standard_fragment = "StandardMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\nmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n",
THREE.ShaderChunk.lights_standard_pars_fragment = "struct StandardMaterial {\n	vec3	diffuseColor;\n	float	specularRoughness;\n	vec3	specularColor;\n};\nvoid RE_Direct_Standard( const in IncidentLight directLight, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifndef PHYSICALLY_CORRECT_LIGHTS\n		irradiance *= PI;\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n}\nvoid RE_IndirectDiffuse_Standard( const in vec3 irradiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Standard( const in vec3 radiance, const in GeometricContext geometry, const in StandardMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n}\n#define RE_Direct				RE_Direct_Standard\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Standard\n#define RE_IndirectSpecular		RE_IndirectSpecular_Standard\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n",
THREE.ShaderChunk.lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		directLight = getPointDirectLightIrradiance( pointLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		directLight = getSpotDirectLightIrradiance( spotLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		directLight = getDirectionalDirectLightIrradiance( directionalLight, geometry );\n		#ifdef USE_SHADOWMAP\n		directLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#ifdef USE_LIGHTMAP\n		vec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n		#ifndef PHYSICALLY_CORRECT_LIGHTS\n			lightMapIrradiance *= PI;\n		#endif\n		irradiance += lightMapIrradiance;\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n		}\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n	 	irradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n	#endif\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	vec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n	RE_IndirectSpecular( radiance, geometry, material, reflectedLight );\n#endif\n",
THREE.ShaderChunk.logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n	gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif",
THREE.ShaderChunk.logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n	uniform float logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n#endif\n",
THREE.ShaderChunk.logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n	#endif\n	uniform float logDepthBufFC;\n#endif",
THREE.ShaderChunk.logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n	gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n	#else\n		gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n	#endif\n#endif\n",
THREE.ShaderChunk.map_fragment = "#ifdef USE_MAP\n	vec4 texelColor = texture2D( map, vUv );\n	texelColor = mapTexelToLinear( texelColor );\n	diffuseColor *= texelColor;\n#endif\n",
THREE.ShaderChunk.map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n",
THREE.ShaderChunk.map_particle_fragment = "#ifdef USE_MAP\n	vec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n	diffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n",
THREE.ShaderChunk.map_particle_pars_fragment = "#ifdef USE_MAP\n	uniform vec4 offsetRepeat;\n	uniform sampler2D map;\n#endif\n",
THREE.ShaderChunk.metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.r;\n#endif\n",
THREE.ShaderChunk.metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif",
THREE.ShaderChunk.morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n	objectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n	objectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n	objectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n",
THREE.ShaderChunk.morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_MORPHNORMALS\n	uniform float morphTargetInfluences[ 8 ];\n	#else\n	uniform float morphTargetInfluences[ 4 ];\n	#endif\n#endif",
THREE.ShaderChunk.morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n	transformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n	transformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n	transformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n	#ifndef USE_MORPHNORMALS\n	transformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n	transformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n	transformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n	transformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n	#endif\n#endif\n",
THREE.ShaderChunk.normal_fragment = "#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\n	#endif\n#endif\n#ifdef USE_NORMALMAP\n	normal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n",
THREE.ShaderChunk.normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 S = normalize( q0 * st1.t - q1 * st0.t );\n		vec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n		vec3 N = normalize( surf_norm );\n		vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n		mapN.xy = normalScale * mapN.xy;\n		mat3 tsn = mat3( S, T, N );\n		return normalize( tsn * mapN );\n	}\n#endif\n",
THREE.ShaderChunk.premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif\n",
THREE.ShaderChunk.project_vertex = "#ifdef USE_SKINNING\n	vec4 mvPosition = modelViewMatrix * skinned;\n#else\n	vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n",
THREE.ShaderChunk.roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.r;\n#endif\n",
THREE.ShaderChunk.roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif",
THREE.ShaderChunk.shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n	float unpackDepth( const in vec4 rgba_depth ) {\n		const vec4 bit_shift = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n		return dot( rgba_depth, bit_shift );\n	}\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackDepth( texture2D( depths, uv ) ) );\n	}\n	float texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n		const vec2 offset = vec2( 0.0, 1.0 );\n		vec2 texelSize = vec2( 1.0 ) / size;\n		vec2 centroidUV = floor( uv * size + 0.5 ) / size;\n		float lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n		float lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n		float rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n		float rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n		vec2 f = fract( uv * size + 0.5 );\n		float a = mix( lb, lt, f.y );\n		float b = mix( rb, rt, f.y );\n		float c = mix( a, b, f.x );\n		return c;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			return (\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return 1.0;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		float dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif\n",
THREE.ShaderChunk.shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n	#endif\n#endif\n",
THREE.ShaderChunk.shadowmap_vertex = "#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n	}\n	#endif\n#endif\n",
THREE.ShaderChunk.shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHTS > 0\n	DirectionalLight directionalLight;\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		shadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_SPOT_LIGHTS > 0\n	SpotLight spotLight;\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		shadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#if NUM_POINT_LIGHTS > 0\n	PointLight pointLight;\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		shadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n	}\n	#endif\n	#endif\n	return shadow;\n}\n",
THREE.ShaderChunk.skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
THREE.ShaderChunk.skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	#ifdef BONE_TEXTURE\n		uniform sampler2D boneTexture;\n		uniform int boneTextureWidth;\n		uniform int boneTextureHeight;\n		mat4 getBoneMatrix( const in float i ) {\n			float j = i * 4.0;\n			float x = mod( j, float( boneTextureWidth ) );\n			float y = floor( j / float( boneTextureWidth ) );\n			float dx = 1.0 / float( boneTextureWidth );\n			float dy = 1.0 / float( boneTextureHeight );\n			y = dy * ( y + 0.5 );\n			vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n			vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n			vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n			vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n			mat4 bone = mat4( v1, v2, v3, v4 );\n			return bone;\n		}\n	#else\n		uniform mat4 boneGlobalMatrices[ MAX_BONES ];\n		mat4 getBoneMatrix( const in float i ) {\n			mat4 bone = boneGlobalMatrices[ int(i) ];\n			return bone;\n		}\n	#endif\n#endif\n",
THREE.ShaderChunk.skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	skinned  = bindMatrixInverse * skinned;\n#endif\n",
THREE.ShaderChunk.skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n",
THREE.ShaderChunk.specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif",
THREE.ShaderChunk.specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif",
THREE.ShaderChunk.tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n",
THREE.ShaderChunk.tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n",
THREE.ShaderChunk.uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif",
THREE.ShaderChunk.uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n#endif",
THREE.ShaderChunk.uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = uv2;\n#endif",
THREE.ShaderChunk.uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n#endif",
THREE.ShaderChunk.uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	varying vec2 vUv;\n	uniform vec4 offsetRepeat;\n#endif\n",
THREE.ShaderChunk.uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n	vUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif",
THREE.ShaderChunk.worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( STANDARD ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n	#ifdef USE_SKINNING\n		vec4 worldPosition = modelMatrix * skinned;\n	#else\n		vec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n	#endif\n#endif\n",
THREE.UniformsUtils = {
    merge: function(e) {
        for (var t = {},
        n = 0; n < e.length; n++) {
            var r = this.clone(e[n]),
            i;
            for (i in r) t[i] = r[i]
        }
        return t
    },
    clone: function(e) {
        var t = {},
        n;
        for (n in e) {
            t[n] = {};
            for (var r in e[n]) {
                var i = e[n][r];
                i instanceof THREE.Color || i instanceof THREE.Vector2 || i instanceof THREE.Vector3 || i instanceof THREE.Vector4 || i instanceof THREE.Matrix3 || i instanceof THREE.Matrix4 || i instanceof THREE.Texture ? t[n][r] = i.clone() : Array.isArray(i) ? t[n][r] = i.slice() : t[n][r] = i
            }
        }
        return t
    }
},
THREE.UniformsLib = {
    common: {
        diffuse: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        offsetRepeat: {
            type: "v4",
            value: new THREE.Vector4(0, 0, 1, 1)
        },
        specularMap: {
            type: "t",
            value: null
        },
        alphaMap: {
            type: "t",
            value: null
        },
        envMap: {
            type: "t",
            value: null
        },
        flipEnvMap: {
            type: "f",
            value: -1
        },
        reflectivity: {
            type: "f",
            value: 1
        },
        refractionRatio: {
            type: "f",
            value: .98
        }
    },
    aomap: {
        aoMap: {
            type: "t",
            value: null
        },
        aoMapIntensity: {
            type: "f",
            value: 1
        }
    },
    lightmap: {
        lightMap: {
            type: "t",
            value: null
        },
        lightMapIntensity: {
            type: "f",
            value: 1
        }
    },
    emissivemap: {
        emissiveMap: {
            type: "t",
            value: null
        }
    },
    bumpmap: {
        bumpMap: {
            type: "t",
            value: null
        },
        bumpScale: {
            type: "f",
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            type: "t",
            value: null
        },
        normalScale: {
            type: "v2",
            value: new THREE.Vector2(1, 1)
        }
    },
    displacementmap: {
        displacementMap: {
            type: "t",
            value: null
        },
        displacementScale: {
            type: "f",
            value: 1
        },
        displacementBias: {
            type: "f",
            value: 0
        }
    },
    roughnessmap: {
        roughnessMap: {
            type: "t",
            value: null
        }
    },
    metalnessmap: {
        metalnessMap: {
            type: "t",
            value: null
        }
    },
    fog: {
        fogDensity: {
            type: "f",
            value: 25e-5
        },
        fogNear: {
            type: "f",
            value: 1
        },
        fogFar: {
            type: "f",
            value: 2e3
        },
        fogColor: {
            type: "c",
            value: new THREE.Color(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            type: "fv",
            value: []
        },
        directionalLights: {
            type: "sa",
            value: [],
            properties: {
                direction: {
                    type: "v3"
                },
                color: {
                    type: "c"
                },
                shadow: {
                    type: "i"
                },
                shadowBias: {
                    type: "f"
                },
                shadowRadius: {
                    type: "f"
                },
                shadowMapSize: {
                    type: "v2"
                }
            }
        },
        directionalShadowMap: {
            type: "tv",
            value: []
        },
        directionalShadowMatrix: {
            type: "m4v",
            value: []
        },
        spotLights: {
            type: "sa",
            value: [],
            properties: {
                color: {
                    type: "c"
                },
                position: {
                    type: "v3"
                },
                direction: {
                    type: "v3"
                },
                distance: {
                    type: "f"
                },
                coneCos: {
                    type: "f"
                },
                penumbraCos: {
                    type: "f"
                },
                decay: {
                    type: "f"
                },
                shadow: {
                    type: "i"
                },
                shadowBias: {
                    type: "f"
                },
                shadowRadius: {
                    type: "f"
                },
                shadowMapSize: {
                    type: "v2"
                }
            }
        },
        spotShadowMap: {
            type: "tv",
            value: []
        },
        spotShadowMatrix: {
            type: "m4v",
            value: []
        },
        pointLights: {
            type: "sa",
            value: [],
            properties: {
                color: {
                    type: "c"
                },
                position: {
                    type: "v3"
                },
                decay: {
                    type: "f"
                },
                distance: {
                    type: "f"
                },
                shadow: {
                    type: "i"
                },
                shadowBias: {
                    type: "f"
                },
                shadowRadius: {
                    type: "f"
                },
                shadowMapSize: {
                    type: "v2"
                }
            }
        },
        pointShadowMap: {
            type: "tv",
            value: []
        },
        pointShadowMatrix: {
            type: "m4v",
            value: []
        },
        hemisphereLights: {
            type: "sa",
            value: [],
            properties: {
                direction: {
                    type: "v3"
                },
                skyColor: {
                    type: "c"
                },
                groundColor: {
                    type: "c"
                }
            }
        }
    },
    points: {
        diffuse: {
            type: "c",
            value: new THREE.Color(15658734)
        },
        opacity: {
            type: "f",
            value: 1
        },
        size: {
            type: "f",
            value: 1
        },
        scale: {
            type: "f",
            value: 1
        },
        map: {
            type: "t",
            value: null
        },
        offsetRepeat: {
            type: "v4",
            value: new THREE.Vector4(0, 0, 1, 1)
        }
    }
},
THREE.ShaderChunk.cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	gl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n	#include <logdepthbuf_fragment>\n}\n",
THREE.ShaderChunk.cube_vert = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n	#include <logdepthbuf_vertex>\n}\n",
THREE.ShaderChunk.depth_frag = "uniform float mNear;\nuniform float mFar;\nuniform float opacity;\n#include <common>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	#ifdef USE_LOGDEPTHBUF_EXT\n		float depth = gl_FragDepthEXT / gl_FragCoord.w;\n	#else\n		float depth = gl_FragCoord.z / gl_FragCoord.w;\n	#endif\n	float color = 1.0 - smoothstep( mNear, mFar, depth );\n	gl_FragColor = vec4( vec3( color ), opacity );\n}\n",
THREE.ShaderChunk.depth_vert = "#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n}\n",
THREE.ShaderChunk.depthRGBA_frag = "#include <common>\n#include <logdepthbuf_pars_fragment>\nvec4 pack_depth( const in float depth ) {\n	const vec4 bit_shift = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n	const vec4 bit_mask = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n	vec4 res = mod( depth * bit_shift * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n	res -= res.xxyz * bit_mask;\n	return res;\n}\nvoid main() {\n	#include <logdepthbuf_fragment>\n	#ifdef USE_LOGDEPTHBUF_EXT\n		gl_FragData[ 0 ] = pack_depth( gl_FragDepthEXT );\n	#else\n		gl_FragData[ 0 ] = pack_depth( gl_FragCoord.z );\n	#endif\n}\n",
THREE.ShaderChunk.depthRGBA_vert = "#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n}\n",
THREE.ShaderChunk.distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\nvec4 pack1K ( float depth ) {\n	depth /= 1000.0;\n	const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\n	const vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n	vec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n	res -= res.xxyz * bitMsk;\n	return res;\n}\nfloat unpack1K ( vec4 color ) {\n	const vec4 bitSh = vec4( 1.0 / ( 256.0 * 256.0 * 256.0 ), 1.0 / ( 256.0 * 256.0 ), 1.0 / 256.0, 1.0 );\n	return dot( color, bitSh ) * 1000.0;\n}\nvoid main () {\n	gl_FragColor = pack1K( length( vWorldPosition.xyz - lightPos.xyz ) );\n}\n",
THREE.ShaderChunk.distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\nvoid main() {\n	#include <skinbase_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	vWorldPosition = worldPosition;\n}\n",
THREE.ShaderChunk.equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	vec3 direction = normalize( vWorldPosition );\n	vec2 sampleUV;\n	sampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n	sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <logdepthbuf_fragment>\n}\n",
THREE.ShaderChunk.equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	vWorldPosition = transformDirection( position, modelMatrix );\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n	#include <logdepthbuf_vertex>\n}\n",
THREE.ShaderChunk.linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n",
THREE.ShaderChunk.linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	vLineDistance = scale * lineDistance;\n	vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n}\n",
THREE.ShaderChunk.meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight;\n	reflectedLight.directDiffuse = vec3( 0.0 );\n	reflectedLight.directSpecular = vec3( 0.0 );\n	reflectedLight.indirectDiffuse = diffuseColor.rgb;\n	reflectedLight.indirectSpecular = vec3( 0.0 );\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n",
THREE.ShaderChunk.meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_ENVMAP\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n}\n",
THREE.ShaderChunk.meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	reflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n",
THREE.ShaderChunk.meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n}\n",
THREE.ShaderChunk.meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n",
THREE.ShaderChunk.meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <lights_phong_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_phong_vertex>\n	#include <shadowmap_vertex>\n}\n",
THREE.ShaderChunk.meshstandard_frag = "#define STANDARD\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform float envMapIntensity;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_standard_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment>\n	#include <emissivemap_fragment>\n	#include <lights_standard_fragment>\n	#include <lights_template>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n",
THREE.ShaderChunk.meshstandard_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n#endif\n	#include <begin_vertex>\n	#include <displacementmap_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n}\n",
THREE.ShaderChunk.normal_frag = "uniform float opacity;\nvarying vec3 vNormal;\n#include <common>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( 0.5 * normalize( vNormal ) + 0.5, opacity );\n	#include <logdepthbuf_fragment>\n}\n",
THREE.ShaderChunk.normal_vert = "varying vec3 vNormal;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	vNormal = normalize( normalMatrix * normal );\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n}\n",
THREE.ShaderChunk.points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	gl_FragColor = vec4( outgoingLight, diffuseColor.a );\n	#include <premultiplied_alpha_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}\n",
THREE.ShaderChunk.points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <begin_vertex>\n	#include <project_vertex>\n	#ifdef USE_SIZEATTENUATION\n		gl_PointSize = size * ( scale / - mvPosition.z );\n	#else\n		gl_PointSize = size;\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n}\n",
THREE.ShaderLib = {
    basic: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.fog]),
        vertexShader: THREE.ShaderChunk.meshbasic_vert,
        fragmentShader: THREE.ShaderChunk.meshbasic_frag
    },
    lambert: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            }
        }]),
        vertexShader: THREE.ShaderChunk.meshlambert_vert,
        fragmentShader: THREE.ShaderChunk.meshlambert_frag
    },
    phong: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.bumpmap, THREE.UniformsLib.normalmap, THREE.UniformsLib.displacementmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            specular: {
                type: "c",
                value: new THREE.Color(1118481)
            },
            shininess: {
                type: "f",
                value: 30
            }
        }]),
        vertexShader: THREE.ShaderChunk.meshphong_vert,
        fragmentShader: THREE.ShaderChunk.meshphong_frag
    },
    standard: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.aomap, THREE.UniformsLib.lightmap, THREE.UniformsLib.emissivemap, THREE.UniformsLib.bumpmap, THREE.UniformsLib.normalmap, THREE.UniformsLib.displacementmap, THREE.UniformsLib.roughnessmap, THREE.UniformsLib.metalnessmap, THREE.UniformsLib.fog, THREE.UniformsLib.lights, {
            emissive: {
                type: "c",
                value: new THREE.Color(0)
            },
            roughness: {
                type: "f",
                value: .5
            },
            metalness: {
                type: "f",
                value: 0
            },
            envMapIntensity: {
                type: "f",
                value: 1
            }
        }]),
        vertexShader: THREE.ShaderChunk.meshstandard_vert,
        fragmentShader: THREE.ShaderChunk.meshstandard_frag
    },
    points: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.points, THREE.UniformsLib.fog]),
        vertexShader: THREE.ShaderChunk.points_vert,
        fragmentShader: THREE.ShaderChunk.points_frag
    },
    dashed: {
        uniforms: THREE.UniformsUtils.merge([THREE.UniformsLib.common, THREE.UniformsLib.fog, {
            scale: {
                type: "f",
                value: 1
            },
            dashSize: {
                type: "f",
                value: 1
            },
            totalSize: {
                type: "f",
                value: 2
            }
        }]),
        vertexShader: THREE.ShaderChunk.linedashed_vert,
        fragmentShader: THREE.ShaderChunk.linedashed_frag
    },
    depth: {
        uniforms: {
            mNear: {
                type: "f",
                value: 1
            },
            mFar: {
                type: "f",
                value: 2e3
            },
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: THREE.ShaderChunk.depth_vert,
        fragmentShader: THREE.ShaderChunk.depth_frag
    },
    normal: {
        uniforms: {
            opacity: {
                type: "f",
                value: 1
            }
        },
        vertexShader: THREE.ShaderChunk.normal_vert,
        fragmentShader: THREE.ShaderChunk.normal_frag
    },
    cube: {
        uniforms: {
            tCube: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "f",
                value: -1
            }
        },
        vertexShader: THREE.ShaderChunk.cube_vert,
        fragmentShader: THREE.ShaderChunk.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                type: "t",
                value: null
            },
            tFlip: {
                type: "f",
                value: -1
            }
        },
        vertexShader: THREE.ShaderChunk.equirect_vert,
        fragmentShader: THREE.ShaderChunk.equirect_frag
    },
    depthRGBA: {
        uniforms: {},
        vertexShader: THREE.ShaderChunk.depthRGBA_vert,
        fragmentShader: THREE.ShaderChunk.depthRGBA_frag
    },
    distanceRGBA: {
        uniforms: {
            lightPos: {
                type: "v3",
                value: new THREE.Vector3(0, 0, 0)
            }
        },
        vertexShader: THREE.ShaderChunk.distanceRGBA_vert,
        fragmentShader: THREE.ShaderChunk.distanceRGBA_frag
    }
},
THREE.WebGLRenderer = function(e) {
    function t(e, t, n, r) { ! 0 === H && (e *= r, t *= r, n *= r),
        wt.clearColor(e, t, n, r)
    }
    function n() {
        wt.init(),
        wt.scissor(Y.copy(ut).multiplyScalar(ot)),
        wt.viewport(et.copy(ft).multiplyScalar(ot)),
        t(nt.r, nt.g, nt.b, rt)
    }
    function r() {
        G = V = null,
        Q = "",
        K = -1,
        wt.reset()
    }
    function i(e) {
        e.preventDefault(),
        r(),
        n(),
        Et.clear()
    }
    function s(e) {
        e = e.target,
        e.removeEventListener("dispose", s);
        e: {
            var t = Et.get(e);
            if (e.image && t.__image__webglTextureCube) mt.deleteTexture(t.__image__webglTextureCube);
            else {
                if (void 0 === t.__webglInit) break e;
                mt.deleteTexture(t.__webglTexture)
            }
            Et.delete(e)
        }
        dt.textures--
    }
    function o(e) {
        e = e.target,
        e.removeEventListener("dispose", o);
        var t = Et.get(e),
        n = Et.get(e.texture);
        if (e && void 0 !== n.__webglTexture) {
            mt.deleteTexture(n.__webglTexture);
            if (e instanceof THREE.WebGLRenderTargetCube) for (n = 0; 6 > n; n++) mt.deleteFramebuffer(t.__webglFramebuffer[n]),
            mt.deleteRenderbuffer(t.__webglDepthbuffer[n]);
            else mt.deleteFramebuffer(t.__webglFramebuffer),
            mt.deleteRenderbuffer(t.__webglDepthbuffer);
            Et.delete(e.texture),
            Et.delete(e)
        }
        dt.textures--
    }
    function u(e) {
        e = e.target,
        e.removeEventListener("dispose", u),
        a(e),
        Et.delete(e)
    }
    function a(e) {
        var t = Et.get(e).program;
        e.program = void 0,
        void 0 !== t && xt.releaseProgram(t)
    }
    function f(e, t) {
        return Math.abs(t[0]) - Math.abs(e[0])
    }
    function l(e, t) {
        return e.object.renderOrder !== t.object.renderOrder ? e.object.renderOrder - t.object.renderOrder: e.material.id !== t.material.id ? e.material.id - t.material.id: e.z !== t.z ? e.z - t.z: e.id - t.id
    }
    function c(e, t) {
        return e.object.renderOrder !== t.object.renderOrder ? e.object.renderOrder - t.object.renderOrder: e.z !== t.z ? t.z - e.z: e.id - t.id
    }
    function h(e, t, n, r, i) {
        var s;
        n.transparent ? (r = q, s = ++R) : (r = F, s = ++I),
        s = r[s],
        void 0 !== s ? (s.id = e.id, s.object = e, s.geometry = t, s.material = n, s.z = ht.z, s.group = i) : (s = {
            id: e.id,
            object: e,
            geometry: t,
            material: n,
            z: ht.z,
            group: i
        },
        r.push(s))
    }
    function p(e, t) {
        if (!1 !== e.visible) {
            if (e.layers.test(t.layers)) if (e instanceof THREE.Light) j.push(e);
            else if (e instanceof THREE.Sprite) ! 1 !== e.frustumCulled && !0 !== lt.intersectsObject(e) || z.push(e);
            else if (e instanceof THREE.LensFlare) W.push(e);
            else if (e instanceof THREE.ImmediateRenderObject) ! 0 === X.sortObjects && (ht.setFromMatrixPosition(e.matrixWorld), ht.applyProjection(ct)),
            h(e, null, e.material, ht.z, null);
            else if (e instanceof THREE.Mesh || e instanceof THREE.Line || e instanceof THREE.Points) if (e instanceof THREE.SkinnedMesh && e.skeleton.update(), !1 === e.frustumCulled || !0 === lt.intersectsObject(e)) {
                var n = e.material;
                if (!0 === n.visible) { ! 0 === X.sortObjects && (ht.setFromMatrixPosition(e.matrixWorld), ht.applyProjection(ct));
                    var r = St.update(e);
                    if (n instanceof THREE.MultiMaterial) for (var i = r.groups,
                    s = n.materials,
                    n = 0,
                    o = i.length; n < o; n++) {
                        var u = i[n],
                        a = s[u.materialIndex]; ! 0 === a.visible && h(e, r, a, ht.z, u)
                    } else h(e, r, n, ht.z, null)
                }
            }
            r = e.children,
            n = 0;
            for (o = r.length; n < o; n++) p(r[n], t)
        }
    }
    function d(e, t, n, r) {
        for (var i = 0,
        s = e.length; i < s; i++) {
            var o = e[i],
            u = o.object,
            a = o.geometry,
            f = void 0 === r ? o.material: r,
            o = o.group;
            u.modelViewMatrix.multiplyMatrices(t.matrixWorldInverse, u.matrixWorld),
            u.normalMatrix.getNormalMatrix(u.modelViewMatrix);
            if (u instanceof THREE.ImmediateRenderObject) {
                v(f);
                var l = m(t, n, f, u);
                Q = "",
                u.render(function(e) {
                    X.renderBufferImmediate(e, l, f)
                })
            } else X.renderBufferDirect(t, n, a, f, u, o)
        }
    }
    function v(e) {
        e.side !== THREE.DoubleSide ? wt.enable(mt.CULL_FACE) : wt.disable(mt.CULL_FACE),
        wt.setFlipSided(e.side === THREE.BackSide),
        !0 === e.transparent ? wt.setBlending(e.blending, e.blendEquation, e.blendSrc, e.blendDst, e.blendEquationAlpha, e.blendSrcAlpha, e.blendDstAlpha, e.premultipliedAlpha) : wt.setBlending(THREE.NoBlending),
        wt.setDepthFunc(e.depthFunc),
        wt.setDepthTest(e.depthTest),
        wt.setDepthWrite(e.depthWrite),
        wt.setColorWrite(e.colorWrite),
        wt.setPolygonOffset(e.polygonOffset, e.polygonOffsetFactor, e.polygonOffsetUnits)
    }
    function m(e, t, n, r) {
        tt = 0;
        var i = Et.get(n);
        void 0 === i.program && (n.needsUpdate = !0),
        void 0 !== i.lightsHash && i.lightsHash !== pt.hash && (n.needsUpdate = !0);
        if (n.needsUpdate) {
            e: {
                var s = Et.get(n),
                o = xt.getParameters(n, pt, t, r),
                f = xt.getProgramCode(n, o),
                l = s.program,
                c = !0;
                if (void 0 === l) n.addEventListener("dispose", u);
                else if (l.code !== f) a(n);
                else {
                    if (void 0 !== o.shaderID) break e;
                    c = !1
                }
                c && (o.shaderID ? (l = THREE.ShaderLib[o.shaderID], s.__webglShader = {
                    name: n.type,
                    uniforms: THREE.UniformsUtils.clone(l.uniforms),
                    vertexShader: l.vertexShader,
                    fragmentShader: l.fragmentShader
                }) : s.__webglShader = {
                    name: n.type,
                    uniforms: n.uniforms,
                    vertexShader: n.vertexShader,
                    fragmentShader: n.fragmentShader
                },
                n.__webglShader = s.__webglShader, l = xt.acquireProgram(n, o, f), s.program = l, n.program = l),
                o = l.getAttributes();
                if (n.morphTargets) for (f = n.numSupportedMorphTargets = 0; f < X.maxMorphTargets; f++) 0 <= o["morphTarget" + f] && n.numSupportedMorphTargets++;
                if (n.morphNormals) for (f = n.numSupportedMorphNormals = 0; f < X.maxMorphNormals; f++) 0 <= o["morphNormal" + f] && n.numSupportedMorphNormals++;
                s.uniformsList = [];
                var o = s.__webglShader.uniforms,
                f = s.program.getUniforms(),
                h;
                for (h in o)(l = f[h]) && s.uniformsList.push([s.__webglShader.uniforms[h], l]);
                if (n instanceof THREE.MeshPhongMaterial || n instanceof THREE.MeshLambertMaterial || n instanceof THREE.MeshStandardMaterial || n.lights) s.lightsHash = pt.hash,
                o.ambientLightColor.value = pt.ambient,
                o.directionalLights.value = pt.directional,
                o.spotLights.value = pt.spot,
                o.pointLights.value = pt.point,
                o.hemisphereLights.value = pt.hemi,
                o.directionalShadowMap.value = pt.directionalShadowMap,
                o.directionalShadowMatrix.value = pt.directionalShadowMatrix,
                o.spotShadowMap.value = pt.spotShadowMap,
                o.spotShadowMatrix.value = pt.spotShadowMatrix,
                o.pointShadowMap.value = pt.pointShadowMap,
                o.pointShadowMatrix.value = pt.pointShadowMatrix;
                s.hasDynamicUniforms = !1,
                h = 0;
                for (o = s.uniformsList.length; h < o; h++) if (!0 === s.uniformsList[h][0].dynamic) {
                    s.hasDynamicUniforms = !0;
                    break
                }
            }
            n.needsUpdate = !1
        }
        l = f = c = !1,
        s = i.program,
        h = s.getUniforms(),
        o = i.__webglShader.uniforms,
        s.id !== V && (mt.useProgram(s.program), V = s.id, l = f = c = !0),
        n.id !== K && (K = n.id, f = !0);
        if (c || e !== G) mt.uniformMatrix4fv(h.projectionMatrix, !1, e.projectionMatrix.elements),
        bt.logarithmicDepthBuffer && mt.uniform1f(h.logDepthBufFC, 2 / (Math.log(e.far + 1) / Math.LN2)),
        e !== G && (G = e, l = f = !0),
        (n instanceof THREE.ShaderMaterial || n instanceof THREE.MeshPhongMaterial || n instanceof THREE.MeshStandardMaterial || n.envMap) && void 0 !== h.cameraPosition && (ht.setFromMatrixPosition(e.matrixWorld), mt.uniform3f(h.cameraPosition, ht.x, ht.y, ht.z)),
        (n instanceof THREE.MeshPhongMaterial || n instanceof THREE.MeshLambertMaterial || n instanceof THREE.MeshBasicMaterial || n instanceof THREE.MeshStandardMaterial || n instanceof THREE.ShaderMaterial || n.skinning) && void 0 !== h.viewMatrix && mt.uniformMatrix4fv(h.viewMatrix, !1, e.matrixWorldInverse.elements),
        void 0 !== h.toneMappingExposure && mt.uniform1f(h.toneMappingExposure, X.toneMappingExposure),
        void 0 !== h.toneMappingWhitePoint && mt.uniform1f(h.toneMappingWhitePoint, X.toneMappingWhitePoint);
        n.skinning && (r.bindMatrix && void 0 !== h.bindMatrix && mt.uniformMatrix4fv(h.bindMatrix, !1, r.bindMatrix.elements), r.bindMatrixInverse && void 0 !== h.bindMatrixInverse && mt.uniformMatrix4fv(h.bindMatrixInverse, !1, r.bindMatrixInverse.elements), bt.floatVertexTextures && r.skeleton && r.skeleton.useVertexTexture ? (void 0 !== h.boneTexture && (c = g(), mt.uniform1i(h.boneTexture, c), X.setTexture(r.skeleton.boneTexture, c)), void 0 !== h.boneTextureWidth && mt.uniform1i(h.boneTextureWidth, r.skeleton.boneTextureWidth), void 0 !== h.boneTextureHeight && mt.uniform1i(h.boneTextureHeight, r.skeleton.boneTextureHeight)) : r.skeleton && r.skeleton.boneMatrices && void 0 !== h.boneGlobalMatrices && mt.uniformMatrix4fv(h.boneGlobalMatrices, !1, r.skeleton.boneMatrices));
        if (f) {
            if (n instanceof THREE.MeshPhongMaterial || n instanceof THREE.MeshLambertMaterial || n instanceof THREE.MeshStandardMaterial || n.lights) f = l,
            o.ambientLightColor.needsUpdate = f,
            o.directionalLights.needsUpdate = f,
            o.pointLights.needsUpdate = f,
            o.spotLights.needsUpdate = f,
            o.hemisphereLights.needsUpdate = f;
            t && n.fog && (o.fogColor.value = t.color, t instanceof THREE.Fog ? (o.fogNear.value = t.near, o.fogFar.value = t.far) : t instanceof THREE.FogExp2 && (o.fogDensity.value = t.density));
            if (n instanceof THREE.MeshBasicMaterial || n instanceof THREE.MeshLambertMaterial || n instanceof THREE.MeshPhongMaterial || n instanceof THREE.MeshStandardMaterial) {
                o.opacity.value = n.opacity,
                o.diffuse.value = n.color,
                n.emissive && o.emissive.value.copy(n.emissive).multiplyScalar(n.emissiveIntensity),
                o.map.value = n.map,
                o.specularMap.value = n.specularMap,
                o.alphaMap.value = n.alphaMap,
                n.aoMap && (o.aoMap.value = n.aoMap, o.aoMapIntensity.value = n.aoMapIntensity);
                var p;
                n.map ? p = n.map: n.specularMap ? p = n.specularMap: n.displacementMap ? p = n.displacementMap: n.normalMap ? p = n.normalMap: n.bumpMap ? p = n.bumpMap: n.roughnessMap ? p = n.roughnessMap: n.metalnessMap ? p = n.metalnessMap: n.alphaMap ? p = n.alphaMap: n.emissiveMap && (p = n.emissiveMap),
                void 0 !== p && (p instanceof THREE.WebGLRenderTarget && (p = p.texture), t = p.offset, p = p.repeat, o.offsetRepeat.value.set(t.x, t.y, p.x, p.y)),
                o.envMap.value = n.envMap,
                o.flipEnvMap.value = n.envMap instanceof THREE.WebGLRenderTargetCube ? 1 : -1,
                o.reflectivity.value = n.reflectivity,
                o.refractionRatio.value = n.refractionRatio
            }
            n instanceof THREE.LineBasicMaterial ? (o.diffuse.value = n.color, o.opacity.value = n.opacity) : n instanceof THREE.LineDashedMaterial ? (o.diffuse.value = n.color, o.opacity.value = n.opacity, o.dashSize.value = n.dashSize, o.totalSize.value = n.dashSize + n.gapSize, o.scale.value = n.scale) : n instanceof THREE.PointsMaterial ? (o.diffuse.value = n.color, o.opacity.value = n.opacity, o.size.value = n.size * ot, o.scale.value = A.clientHeight / 2, o.map.value = n.map, null !== n.map && (p = n.map.offset, n = n.map.repeat, o.offsetRepeat.value.set(p.x, p.y, n.x, n.y))) : n instanceof THREE.MeshLambertMaterial ? (n.lightMap && (o.lightMap.value = n.lightMap, o.lightMapIntensity.value = n.lightMapIntensity), n.emissiveMap && (o.emissiveMap.value = n.emissiveMap)) : n instanceof THREE.MeshPhongMaterial ? (o.specular.value = n.specular, o.shininess.value = Math.max(n.shininess, 1e-4), n.lightMap && (o.lightMap.value = n.lightMap, o.lightMapIntensity.value = n.lightMapIntensity), n.emissiveMap && (o.emissiveMap.value = n.emissiveMap), n.bumpMap && (o.bumpMap.value = n.bumpMap, o.bumpScale.value = n.bumpScale), n.normalMap && (o.normalMap.value = n.normalMap, o.normalScale.value.copy(n.normalScale)), n.displacementMap && (o.displacementMap.value = n.displacementMap, o.displacementScale.value = n.displacementScale, o.displacementBias.value = n.displacementBias)) : n instanceof THREE.MeshStandardMaterial ? (o.roughness.value = n.roughness, o.metalness.value = n.metalness, n.roughnessMap && (o.roughnessMap.value = n.roughnessMap), n.metalnessMap && (o.metalnessMap.value = n.metalnessMap), n.lightMap && (o.lightMap.value = n.lightMap, o.lightMapIntensity.value = n.lightMapIntensity), n.emissiveMap && (o.emissiveMap.value = n.emissiveMap), n.bumpMap && (o.bumpMap.value = n.bumpMap, o.bumpScale.value = n.bumpScale), n.normalMap && (o.normalMap.value = n.normalMap, o.normalScale.value.copy(n.normalScale)), n.displacementMap && (o.displacementMap.value = n.displacementMap, o.displacementScale.value = n.displacementScale, o.displacementBias.value = n.displacementBias), n.envMap && (o.envMapIntensity.value = n.envMapIntensity)) : n instanceof THREE.MeshDepthMaterial ? (o.mNear.value = e.near, o.mFar.value = e.far, o.opacity.value = n.opacity) : n instanceof THREE.MeshNormalMaterial && (o.opacity.value = n.opacity),
            b(i.uniformsList)
        }
        mt.uniformMatrix4fv(h.modelViewMatrix, !1, r.modelViewMatrix.elements),
        h.normalMatrix && mt.uniformMatrix3fv(h.normalMatrix, !1, r.normalMatrix.elements),
        void 0 !== h.modelMatrix && mt.uniformMatrix4fv(h.modelMatrix, !1, r.matrixWorld.elements);
        if (!0 === i.hasDynamicUniforms) {
            i = i.uniformsList,
            n = [],
            p = 0;
            for (t = i.length; p < t; p++) h = i[p][0],
            o = h.onUpdateCallback,
            void 0 !== o && (o.bind(h)(r, e), n.push(i[p]));
            b(n)
        }
        return s
    }
    function g() {
        var e = tt;
        return e >= bt.maxTextures && console.warn("WebGLRenderer: trying to use " + e + " texture units while this GPU supports only " + bt.maxTextures),
        tt += 1,
        e
    }
    function y(e, t, n, r) {
        var i;
        if ("1i" === t) mt.uniform1i(n, r);
        else if ("1f" === t) mt.uniform1f(n, r);
        else if ("2f" === t) mt.uniform2f(n, r[0], r[1]);
        else if ("3f" === t) mt.uniform3f(n, r[0], r[1], r[2]);
        else if ("4f" === t) mt.uniform4f(n, r[0], r[1], r[2], r[3]);
        else if ("1iv" === t) mt.uniform1iv(n, r);
        else if ("3iv" === t) mt.uniform3iv(n, r);
        else if ("1fv" === t) mt.uniform1fv(n, r);
        else if ("2fv" === t) mt.uniform2fv(n, r);
        else if ("3fv" === t) mt.uniform3fv(n, r);
        else if ("4fv" === t) mt.uniform4fv(n, r);
        else if ("Matrix2fv" === t) mt.uniformMatrix2fv(n, !1, r);
        else if ("Matrix3fv" === t) mt.uniformMatrix3fv(n, !1, r);
        else if ("Matrix4fv" === t) mt.uniformMatrix4fv(n, !1, r);
        else if ("i" === t) mt.uniform1i(n, r);
        else if ("f" === t) mt.uniform1f(n, r);
        else if ("v2" === t) mt.uniform2f(n, r.x, r.y);
        else if ("v3" === t) mt.uniform3f(n, r.x, r.y, r.z);
        else if ("v4" === t) mt.uniform4f(n, r.x, r.y, r.z, r.w);
        else if ("c" === t) mt.uniform3f(n, r.r, r.g, r.b);
        else if ("s" === t) {
            e = e.properties;
            for (var s in e) {
                i = e[s];
                var o = n[s],
                u = r[s];
                y(i, i.type, o, u)
            }
        } else if ("sa" === t) {
            e = e.properties,
            t = 0;
            for (var a = r.length; t < a; t++) for (s in e) i = e[s],
            o = n[t][s],
            u = r[t][s],
            y(i, i.type, o, u)
        } else if ("iv1" === t) mt.uniform1iv(n, r);
        else if ("iv" === t) mt.uniform3iv(n, r);
        else if ("fv1" === t) mt.uniform1fv(n, r);
        else if ("fv" === t) mt.uniform3fv(n, r);
        else if ("v2v" === t) {
            void 0 === e._array && (e._array = new Float32Array(2 * r.length)),
            i = t = 0;
            for (s = r.length; t < s; t++, i += 2) e._array[i + 0] = r[t].x,
            e._array[i + 1] = r[t].y;
            mt.uniform2fv(n, e._array)
        } else if ("v3v" === t) {
            void 0 === e._array && (e._array = new Float32Array(3 * r.length)),
            i = t = 0;
            for (s = r.length; t < s; t++, i += 3) e._array[i + 0] = r[t].x,
            e._array[i + 1] = r[t].y,
            e._array[i + 2] = r[t].z;
            mt.uniform3fv(n, e._array)
        } else if ("v4v" === t) {
            void 0 === e._array && (e._array = new Float32Array(4 * r.length)),
            i = t = 0;
            for (s = r.length; t < s; t++, i += 4) e._array[i + 0] = r[t].x,
            e._array[i + 1] = r[t].y,
            e._array[i + 2] = r[t].z,
            e._array[i + 3] = r[t].w;
            mt.uniform4fv(n, e._array)
        } else if ("m2" === t) mt.uniformMatrix2fv(n, !1, r.elements);
        else if ("m3" === t) mt.uniformMatrix3fv(n, !1, r.elements);
        else if ("m3v" === t) {
            void 0 === e._array && (e._array = new Float32Array(9 * r.length)),
            t = 0;
            for (s = r.length; t < s; t++) r[t].flattenToArrayOffset(e._array, 9 * t);
            mt.uniformMatrix3fv(n, !1, e._array)
        } else if ("m4" === t) mt.uniformMatrix4fv(n, !1, r.elements);
        else if ("m4v" === t) {
            void 0 === e._array && (e._array = new Float32Array(16 * r.length)),
            t = 0;
            for (s = r.length; t < s; t++) r[t].flattenToArrayOffset(e._array, 16 * t);
            mt.uniformMatrix4fv(n, !1, e._array)
        } else if ("t" === t) i = g(),
        mt.uniform1i(n, i),
        r && (r instanceof THREE.CubeTexture || Array.isArray(r.image) && 6 === r.image.length ? x(r, i) : r instanceof THREE.WebGLRenderTargetCube ? T(r.texture, i) : r instanceof THREE.WebGLRenderTarget ? X.setTexture(r.texture, i) : X.setTexture(r, i));
        else if ("tv" === t) {
            void 0 === e._array && (e._array = []),
            t = 0;
            for (s = e.value.length; t < s; t++) e._array[t] = g();
            mt.uniform1iv(n, e._array),
            t = 0;
            for (s = e.value.length; t < s; t++) r = e.value[t],
            i = e._array[t],
            r && (r instanceof THREE.CubeTexture || r.image instanceof Array && 6 === r.image.length ? x(r, i) : r instanceof THREE.WebGLRenderTarget ? X.setTexture(r.texture, i) : r instanceof THREE.WebGLRenderTargetCube ? T(r.texture, i) : X.setTexture(r, i))
        } else console.warn("THREE.WebGLRenderer: Unknown uniform type: " + t)
    }
    function b(e) {
        for (var t = 0,
        n = e.length; t < n; t++) {
            var r = e[t][0]; ! 1 !== r.needsUpdate && y(r, r.type, e[t][1], r.value)
        }
    }
    function w(e, t, n) {
        n ? (mt.texParameteri(e, mt.TEXTURE_WRAP_S, L(t.wrapS)), mt.texParameteri(e, mt.TEXTURE_WRAP_T, L(t.wrapT)), mt.texParameteri(e, mt.TEXTURE_MAG_FILTER, L(t.magFilter)), mt.texParameteri(e, mt.TEXTURE_MIN_FILTER, L(t.minFilter))) : (mt.texParameteri(e, mt.TEXTURE_WRAP_S, mt.CLAMP_TO_EDGE), mt.texParameteri(e, mt.TEXTURE_WRAP_T, mt.CLAMP_TO_EDGE), t.wrapS === THREE.ClampToEdgeWrapping && t.wrapT === THREE.ClampToEdgeWrapping || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.", t), mt.texParameteri(e, mt.TEXTURE_MAG_FILTER, k(t.magFilter)), mt.texParameteri(e, mt.TEXTURE_MIN_FILTER, k(t.minFilter)), t.minFilter !== THREE.NearestFilter && t.minFilter !== THREE.LinearFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.", t)),
        !(n = yt.get("EXT_texture_filter_anisotropic")) || t.type === THREE.FloatType && null === yt.get("OES_texture_float_linear") || t.type === THREE.HalfFloatType && null === yt.get("OES_texture_half_float_linear") || !(1 < t.anisotropy || Et.get(t).__currentAnisotropy) || (mt.texParameterf(e, n.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(t.anisotropy, X.getMaxAnisotropy())), Et.get(t).__currentAnisotropy = t.anisotropy)
    }
    function E(e, t) {
        if (e.width > t || e.height > t) {
            var n = t / Math.max(e.width, e.height),
            r = document.createElement("canvas");
            return r.width = Math.floor(e.width * n),
            r.height = Math.floor(e.height * n),
            r.getContext("2d").drawImage(e, 0, 0, e.width, e.height, 0, 0, r.width, r.height),
            console.warn("THREE.WebGLRenderer: image is too big (" + e.width + "x" + e.height + "). Resized to " + r.width + "x" + r.height, e),
            r
        }
        return e
    }
    function S(e) {
        return THREE.Math.isPowerOfTwo(e.width) && THREE.Math.isPowerOfTwo(e.height)
    }
    function x(e, t) {
        var n = Et.get(e);
        if (6 === e.image.length) if (0 < e.version && n.__version !== e.version) {
            n.__image__webglTextureCube || (e.addEventListener("dispose", s), n.__image__webglTextureCube = mt.createTexture(), dt.textures++),
            wt.activeTexture(mt.TEXTURE0 + t),
            wt.bindTexture(mt.TEXTURE_CUBE_MAP, n.__image__webglTextureCube),
            mt.pixelStorei(mt.UNPACK_FLIP_Y_WEBGL, e.flipY);
            for (var r = e instanceof THREE.CompressedTexture,
            i = e.image[0] instanceof THREE.DataTexture, o = [], u = 0; 6 > u; u++) o[u] = !X.autoScaleCubemaps || r || i ? i ? e.image[u].image: e.image[u] : E(e.image[u], bt.maxCubemapSize);
            var a = S(o[0]),
            f = L(e.format),
            l = L(e.type);
            w(mt.TEXTURE_CUBE_MAP, e, a);
            for (u = 0; 6 > u; u++) if (r) for (var c, h = o[u].mipmaps, p = 0, d = h.length; p < d; p++) c = h[p],
            e.format !== THREE.RGBAFormat && e.format !== THREE.RGBFormat ? -1 < wt.getCompressedTextureFormats().indexOf(f) ? wt.compressedTexImage2D(mt.TEXTURE_CUBE_MAP_POSITIVE_X + u, p, f, c.width, c.height, 0, c.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setCubeTexture()") : wt.texImage2D(mt.TEXTURE_CUBE_MAP_POSITIVE_X + u, p, f, c.width, c.height, 0, f, l, c.data);
            else i ? wt.texImage2D(mt.TEXTURE_CUBE_MAP_POSITIVE_X + u, 0, f, o[u].width, o[u].height, 0, f, l, o[u].data) : wt.texImage2D(mt.TEXTURE_CUBE_MAP_POSITIVE_X + u, 0, f, f, l, o[u]);
            e.generateMipmaps && a && mt.generateMipmap(mt.TEXTURE_CUBE_MAP),
            n.__version = e.version,
            e.onUpdate && e.onUpdate(e)
        } else wt.activeTexture(mt.TEXTURE0 + t),
        wt.bindTexture(mt.TEXTURE_CUBE_MAP, n.__image__webglTextureCube)
    }
    function T(e, t) {
        wt.activeTexture(mt.TEXTURE0 + t),
        wt.bindTexture(mt.TEXTURE_CUBE_MAP, Et.get(e).__webglTexture)
    }
    function N(e, t, n, r) {
        var i = L(t.texture.format),
        s = L(t.texture.type);
        wt.texImage2D(r, 0, i, t.width, t.height, 0, i, s, null),
        mt.bindFramebuffer(mt.FRAMEBUFFER, e),
        mt.framebufferTexture2D(mt.FRAMEBUFFER, n, r, Et.get(t.texture).__webglTexture, 0),
        mt.bindFramebuffer(mt.FRAMEBUFFER, null)
    }
    function C(e, t) {
        mt.bindRenderbuffer(mt.RENDERBUFFER, e),
        t.depthBuffer && !t.stencilBuffer ? (mt.renderbufferStorage(mt.RENDERBUFFER, mt.DEPTH_COMPONENT16, t.width, t.height), mt.framebufferRenderbuffer(mt.FRAMEBUFFER, mt.DEPTH_ATTACHMENT, mt.RENDERBUFFER, e)) : t.depthBuffer && t.stencilBuffer ? (mt.renderbufferStorage(mt.RENDERBUFFER, mt.DEPTH_STENCIL, t.width, t.height), mt.framebufferRenderbuffer(mt.FRAMEBUFFER, mt.DEPTH_STENCIL_ATTACHMENT, mt.RENDERBUFFER, e)) : mt.renderbufferStorage(mt.RENDERBUFFER, mt.RGBA4, t.width, t.height),
        mt.bindRenderbuffer(mt.RENDERBUFFER, null)
    }
    function k(e) {
        return e === THREE.NearestFilter || e === THREE.NearestMipMapNearestFilter || e === THREE.NearestMipMapLinearFilter ? mt.NEAREST: mt.LINEAR
    }
    function L(e) {
        var t;
        if (e === THREE.RepeatWrapping) return mt.REPEAT;
        if (e === THREE.ClampToEdgeWrapping) return mt.CLAMP_TO_EDGE;
        if (e === THREE.MirroredRepeatWrapping) return mt.MIRRORED_REPEAT;
        if (e === THREE.NearestFilter) return mt.NEAREST;
        if (e === THREE.NearestMipMapNearestFilter) return mt.NEAREST_MIPMAP_NEAREST;
        if (e === THREE.NearestMipMapLinearFilter) return mt.NEAREST_MIPMAP_LINEAR;
        if (e === THREE.LinearFilter) return mt.LINEAR;
        if (e === THREE.LinearMipMapNearestFilter) return mt.LINEAR_MIPMAP_NEAREST;
        if (e === THREE.LinearMipMapLinearFilter) return mt.LINEAR_MIPMAP_LINEAR;
        if (e === THREE.UnsignedByteType) return mt.UNSIGNED_BYTE;
        if (e === THREE.UnsignedShort4444Type) return mt.UNSIGNED_SHORT_4_4_4_4;
        if (e === THREE.UnsignedShort5551Type) return mt.UNSIGNED_SHORT_5_5_5_1;
        if (e === THREE.UnsignedShort565Type) return mt.UNSIGNED_SHORT_5_6_5;
        if (e === THREE.ByteType) return mt.BYTE;
        if (e === THREE.ShortType) return mt.SHORT;
        if (e === THREE.UnsignedShortType) return mt.UNSIGNED_SHORT;
        if (e === THREE.IntType) return mt.INT;
        if (e === THREE.UnsignedIntType) return mt.UNSIGNED_INT;
        if (e === THREE.FloatType) return mt.FLOAT;
        t = yt.get("OES_texture_half_float");
        if (null !== t && e === THREE.HalfFloatType) return t.HALF_FLOAT_OES;
        if (e === THREE.AlphaFormat) return mt.ALPHA;
        if (e === THREE.RGBFormat) return mt.RGB;
        if (e === THREE.RGBAFormat) return mt.RGBA;
        if (e === THREE.LuminanceFormat) return mt.LUMINANCE;
        if (e === THREE.LuminanceAlphaFormat) return mt.LUMINANCE_ALPHA;
        if (e === THREE.AddEquation) return mt.FUNC_ADD;
        if (e === THREE.SubtractEquation) return mt.FUNC_SUBTRACT;
        if (e === THREE.ReverseSubtractEquation) return mt.FUNC_REVERSE_SUBTRACT;
        if (e === THREE.ZeroFactor) return mt.ZERO;
        if (e === THREE.OneFactor) return mt.ONE;
        if (e === THREE.SrcColorFactor) return mt.SRC_COLOR;
        if (e === THREE.OneMinusSrcColorFactor) return mt.ONE_MINUS_SRC_COLOR;
        if (e === THREE.SrcAlphaFactor) return mt.SRC_ALPHA;
        if (e === THREE.OneMinusSrcAlphaFactor) return mt.ONE_MINUS_SRC_ALPHA;
        if (e === THREE.DstAlphaFactor) return mt.DST_ALPHA;
        if (e === THREE.OneMinusDstAlphaFactor) return mt.ONE_MINUS_DST_ALPHA;
        if (e === THREE.DstColorFactor) return mt.DST_COLOR;
        if (e === THREE.OneMinusDstColorFactor) return mt.ONE_MINUS_DST_COLOR;
        if (e === THREE.SrcAlphaSaturateFactor) return mt.SRC_ALPHA_SATURATE;
        t = yt.get("WEBGL_compressed_texture_s3tc");
        if (null !== t) {
            if (e === THREE.RGB_S3TC_DXT1_Format) return t.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (e === THREE.RGBA_S3TC_DXT1_Format) return t.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (e === THREE.RGBA_S3TC_DXT3_Format) return t.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (e === THREE.RGBA_S3TC_DXT5_Format) return t.COMPRESSED_RGBA_S3TC_DXT5_EXT
        }
        t = yt.get("WEBGL_compressed_texture_pvrtc");
        if (null !== t) {
            if (e === THREE.RGB_PVRTC_4BPPV1_Format) return t.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (e === THREE.RGB_PVRTC_2BPPV1_Format) return t.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (e === THREE.RGBA_PVRTC_4BPPV1_Format) return t.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (e === THREE.RGBA_PVRTC_2BPPV1_Format) return t.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
        }
        t = yt.get("WEBGL_compressed_texture_etc1");
        if (null !== t && e === THREE.RGB_ETC1_Format) return t.COMPRESSED_RGB_ETC1_WEBGL;
        t = yt.get("EXT_blend_minmax");
        if (null !== t) {
            if (e === THREE.MinEquation) return t.MIN_EXT;
            if (e === THREE.MaxEquation) return t.MAX_EXT
        }
        return 0
    }
    console.log("THREE.WebGLRenderer", THREE.REVISION),
    e = e || {};
    var A = void 0 !== e.canvas ? e.canvas: document.createElement("canvas"),
    O = void 0 !== e.context ? e.context: null,
    M = void 0 !== e.alpha ? e.alpha: !1,
    _ = void 0 !== e.depth ? e.depth: !0,
    D = void 0 !== e.stencil ? e.stencil: !0,
    P = void 0 !== e.antialias ? e.antialias: !1,
    H = void 0 !== e.premultipliedAlpha ? e.premultipliedAlpha: !0,
    B = void 0 !== e.preserveDrawingBuffer ? e.preserveDrawingBuffer: !1,
    j = [],
    F = [],
    I = -1,
    q = [],
    R = -1,
    U = new Float32Array(8),
    z = [],
    W = [];
    this.domElement = A,
    this.context = null,
    this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0,
    this.gammaFactor = 2,
    this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1,
    this.toneMapping = THREE.LinearToneMapping,
    this.toneMappingWhitePoint = this.toneMappingExposure = 1,
    this.maxMorphTargets = 8,
    this.maxMorphNormals = 4,
    this.autoScaleCubemaps = !0;
    var X = this,
    V = null,
    $ = null,
    J = null,
    K = -1,
    Q = "",
    G = null,
    Y = new THREE.Vector4,
    Z = null,
    et = new THREE.Vector4,
    tt = 0,
    nt = new THREE.Color(0),
    rt = 0,
    it = A.width,
    st = A.height,
    ot = 1,
    ut = new THREE.Vector4(0, 0, it, st),
    at = !1,
    ft = new THREE.Vector4(0, 0, it, st),
    lt = new THREE.Frustum,
    ct = new THREE.Matrix4,
    ht = new THREE.Vector3,
    pt = {
        hash: "",
        ambient: [0, 0, 0],
        directional: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotShadowMap: [],
        spotShadowMatrix: [],
        point: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        shadows: [],
        shadowsPointLight: 0
    },
    dt = {
        geometries: 0,
        textures: 0
    },
    vt = {
        calls: 0,
        vertices: 0,
        faces: 0,
        points: 0
    };
    this.info = {
        render: vt,
        memory: dt,
        programs: null
    };
    var mt;
    try {
        M = {
            alpha: M,
            depth: _,
            stencil: D,
            antialias: P,
            premultipliedAlpha: H,
            preserveDrawingBuffer: B
        },
        mt = O || A.getContext("webgl", M) || A.getContext("experimental-webgl", M);
        if (null === mt) throw null !== A.getContext("webgl") ? "Error creating WebGL context with your selected attributes.": "Error creating WebGL context.";
        void 0 === mt.getShaderPrecisionFormat && (mt.getShaderPrecisionFormat = function() {
            return {
                rangeMin: 1,
                rangeMax: 1,
                precision: 1
            }
        }),
        A.addEventListener("webglcontextlost", i, !1)
    } catch(gt) {
        console.error("THREE.WebGLRenderer: " + gt)
    }
    var yt = new THREE.WebGLExtensions(mt);
    yt.get("OES_texture_float"),
    yt.get("OES_texture_float_linear"),
    yt.get("OES_texture_half_float"),
    yt.get("OES_texture_half_float_linear"),
    yt.get("OES_standard_derivatives"),
    yt.get("ANGLE_instanced_arrays"),
    yt.get("OES_element_index_uint") && (THREE.BufferGeometry.MaxIndex = 4294967296);
    var bt = new THREE.WebGLCapabilities(mt, yt, e),
    wt = new THREE.WebGLState(mt, yt, L),
    Et = new THREE.WebGLProperties,
    St = new THREE.WebGLObjects(mt, Et, this.info),
    xt = new THREE.WebGLPrograms(this, bt),
    Tt = new THREE.WebGLLights;
    this.info.programs = xt.programs;
    var Nt = new THREE.WebGLBufferRenderer(mt, yt, vt),
    Ct = new THREE.WebGLIndexedBufferRenderer(mt, yt, vt);
    n(),
    this.context = mt,
    this.capabilities = bt,
    this.extensions = yt,
    this.properties = Et,
    this.state = wt;
    var kt = new THREE.WebGLShadowMap(this, pt, St);
    this.shadowMap = kt;
    var Lt = new THREE.SpritePlugin(this, z),
    At = new THREE.LensFlarePlugin(this, W);
    this.getContext = function() {
        return mt
    },
    this.getContextAttributes = function() {
        return mt.getContextAttributes()
    },
    this.forceContextLoss = function() {
        yt.get("WEBGL_lose_context").loseContext()
    },
    this.getMaxAnisotropy = function() {
        var e;
        return function() {
            if (void 0 !== e) return e;
            var t = yt.get("EXT_texture_filter_anisotropic");
            return e = null !== t ? mt.getParameter(t.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
        }
    } (),
    this.getPrecision = function() {
        return bt.precision
    },
    this.getPixelRatio = function() {
        return ot
    },
    this.setPixelRatio = function(e) {
        void 0 !== e && (ot = e, this.setSize(ft.z, ft.w, !1))
    },
    this.getSize = function() {
        return {
            width: it,
            height: st
        }
    },
    this.setSize = function(e, t, n) {
        it = e,
        st = t,
        A.width = e * ot,
        A.height = t * ot,
        !1 !== n && (A.style.width = e + "px", A.style.height = t + "px"),
        this.setViewport(0, 0, e, t)
    },
    this.setViewport = function(e, t, n, r) {
        wt.viewport(ft.set(e, t, n, r))
    },
    this.setScissor = function(e, t, n, r) {
        wt.scissor(ut.set(e, t, n, r))
    },
    this.setScissorTest = function(e) {
        wt.setScissorTest(at = e)
    },
    this.getClearColor = function() {
        return nt
    },
    this.setClearColor = function(e, n) {
        nt.set(e),
        rt = void 0 !== n ? n: 1,
        t(nt.r, nt.g, nt.b, rt)
    },
    this.getClearAlpha = function() {
        return rt
    },
    this.setClearAlpha = function(e) {
        rt = e,
        t(nt.r, nt.g, nt.b, rt)
    },
    this.clear = function(e, t, n) {
        var r = 0;
        if (void 0 === e || e) r |= mt.COLOR_BUFFER_BIT;
        if (void 0 === t || t) r |= mt.DEPTH_BUFFER_BIT;
        if (void 0 === n || n) r |= mt.STENCIL_BUFFER_BIT;
        mt.clear(r)
    },
    this.clearColor = function() {
        this.clear(!0, !1, !1)
    },
    this.clearDepth = function() {
        this.clear(!1, !0, !1)
    },
    this.clearStencil = function() {
        this.clear(!1, !1, !0)
    },
    this.clearTarget = function(e, t, n, r) {
        this.setRenderTarget(e),
        this.clear(t, n, r)
    },
    this.resetGLState = r,
    this.dispose = function() {
        A.removeEventListener("webglcontextlost", i, !1)
    },
    this.renderBufferImmediate = function(e, t, n) {
        wt.initAttributes();
        var r = Et.get(e);
        e.hasPositions && !r.position && (r.position = mt.createBuffer()),
        e.hasNormals && !r.normal && (r.normal = mt.createBuffer()),
        e.hasUvs && !r.uv && (r.uv = mt.createBuffer()),
        e.hasColors && !r.color && (r.color = mt.createBuffer()),
        t = t.getAttributes(),
        e.hasPositions && (mt.bindBuffer(mt.ARRAY_BUFFER, r.position), mt.bufferData(mt.ARRAY_BUFFER, e.positionArray, mt.DYNAMIC_DRAW), wt.enableAttribute(t.position), mt.vertexAttribPointer(t.position, 3, mt.FLOAT, !1, 0, 0));
        if (e.hasNormals) {
            mt.bindBuffer(mt.ARRAY_BUFFER, r.normal);
            if ("MeshPhongMaterial" !== n.type && "MeshStandardMaterial" !== n.type && n.shading === THREE.FlatShading) for (var i = 0,
            s = 3 * e.count; i < s; i += 9) {
                var o = e.normalArray,
                u = (o[i + 0] + o[i + 3] + o[i + 6]) / 3,
                a = (o[i + 1] + o[i + 4] + o[i + 7]) / 3,
                f = (o[i + 2] + o[i + 5] + o[i + 8]) / 3;
                o[i + 0] = u,
                o[i + 1] = a,
                o[i + 2] = f,
                o[i + 3] = u,
                o[i + 4] = a,
                o[i + 5] = f,
                o[i + 6] = u,
                o[i + 7] = a,
                o[i + 8] = f
            }
            mt.bufferData(mt.ARRAY_BUFFER, e.normalArray, mt.DYNAMIC_DRAW),
            wt.enableAttribute(t.normal),
            mt.vertexAttribPointer(t.normal, 3, mt.FLOAT, !1, 0, 0)
        }
        e.hasUvs && n.map && (mt.bindBuffer(mt.ARRAY_BUFFER, r.uv), mt.bufferData(mt.ARRAY_BUFFER, e.uvArray, mt.DYNAMIC_DRAW), wt.enableAttribute(t.uv), mt.vertexAttribPointer(t.uv, 2, mt.FLOAT, !1, 0, 0)),
        e.hasColors && n.vertexColors !== THREE.NoColors && (mt.bindBuffer(mt.ARRAY_BUFFER, r.color), mt.bufferData(mt.ARRAY_BUFFER, e.colorArray, mt.DYNAMIC_DRAW), wt.enableAttribute(t.color), mt.vertexAttribPointer(t.color, 3, mt.FLOAT, !1, 0, 0)),
        wt.disableUnusedAttributes(),
        mt.drawArrays(mt.TRIANGLES, 0, e.count),
        e.count = 0
    },
    this.renderBufferDirect = function(e, t, n, r, i, s) {
        v(r);
        var o = m(e, t, r, i),
        u = !1;
        e = n.id + "_" + o.id + "_" + r.wireframe,
        e !== Q && (Q = e, u = !0),
        t = i.morphTargetInfluences;
        if (void 0 !== t) {
            e = [];
            for (var a = 0,
            u = t.length; a < u; a++) {
                var l = t[a];
                e.push([l, a])
            }
            e.sort(f),
            8 < e.length && (e.length = 8);
            for (var c = n.morphAttributes,
            a = 0,
            u = e.length; a < u; a++) l = e[a],
            U[a] = l[0],
            0 !== l[0] ? (t = l[1], !0 === r.morphTargets && c.position && n.addAttribute("morphTarget" + a, c.position[t]), !0 === r.morphNormals && c.normal && n.addAttribute("morphNormal" + a, c.normal[t])) : (!0 === r.morphTargets && n.removeAttribute("morphTarget" + a), !0 === r.morphNormals && n.removeAttribute("morphNormal" + a));
            e = o.getUniforms(),
            null !== e.morphTargetInfluences && mt.uniform1fv(e.morphTargetInfluences, U),
            u = !0
        }
        t = n.index,
        a = n.attributes.position,
        !0 === r.wireframe && (t = St.getWireframeAttribute(n)),
        null !== t ? (e = Ct, e.setIndex(t)) : e = Nt;
        if (u) {
            e: {
                var u = void 0,
                h;
                if (n instanceof THREE.InstancedBufferGeometry && (h = yt.get("ANGLE_instanced_arrays"), null === h)) {
                    console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
                    break e
                }
                void 0 === u && (u = 0),
                wt.initAttributes();
                var l = n.attributes,
                o = o.getAttributes(),
                c = r.defaultAttributeValues,
                p;
                for (p in o) {
                    var d = o[p];
                    if (0 <= d) {
                        var g = l[p];
                        if (void 0 !== g) {
                            var y = g.itemSize,
                            b = St.getAttributeBuffer(g);
                            if (g instanceof THREE.InterleavedBufferAttribute) {
                                var w = g.data,
                                E = w.stride,
                                g = g.offset;
                                w instanceof THREE.InstancedInterleavedBuffer ? (wt.enableAttributeAndDivisor(d, w.meshPerAttribute, h), void 0 === n.maxInstancedCount && (n.maxInstancedCount = w.meshPerAttribute * w.count)) : wt.enableAttribute(d),
                                mt.bindBuffer(mt.ARRAY_BUFFER, b),
                                mt.vertexAttribPointer(d, y, mt.FLOAT, !1, E * w.array.BYTES_PER_ELEMENT, (u * E + g) * w.array.BYTES_PER_ELEMENT)
                            } else g instanceof THREE.InstancedBufferAttribute ? (wt.enableAttributeAndDivisor(d, g.meshPerAttribute, h), void 0 === n.maxInstancedCount && (n.maxInstancedCount = g.meshPerAttribute * g.count)) : wt.enableAttribute(d),
                            mt.bindBuffer(mt.ARRAY_BUFFER, b),
                            mt.vertexAttribPointer(d, y, mt.FLOAT, !1, 0, u * y * 4)
                        } else if (void 0 !== c && (y = c[p], void 0 !== y)) switch (y.length) {
                        case 2:
                            mt.vertexAttrib2fv(d, y);
                            break;
                        case 3:
                            mt.vertexAttrib3fv(d, y);
                            break;
                        case 4:
                            mt.vertexAttrib4fv(d, y);
                            break;
                        default:
                            mt.vertexAttrib1fv(d, y)
                        }
                    }
                }
                wt.disableUnusedAttributes()
            }
            null !== t && mt.bindBuffer(mt.ELEMENT_ARRAY_BUFFER, St.getAttributeBuffer(t))
        }
        h = Infinity,
        null !== t ? h = t.count: void 0 !== a && (h = a.count),
        p = n.drawRange.start,
        t = n.drawRange.count,
        a = null !== s ? s.start: 0,
        u = null !== s ? s.count: Infinity,
        s = Math.max(0, p, a),
        h = Math.min(0 + h, p + t, a + u) - 1,
        h = Math.max(0, h - s + 1);
        if (i instanceof THREE.Mesh) if (!0 === r.wireframe) wt.setLineWidth(r.wireframeLinewidth * (null === $ ? ot: 1)),
        e.setMode(mt.LINES);
        else switch (i.drawMode) {
        case THREE.TrianglesDrawMode:
            e.setMode(mt.TRIANGLES);
            break;
        case THREE.TriangleStripDrawMode:
            e.setMode(mt.TRIANGLE_STRIP);
            break;
        case THREE.TriangleFanDrawMode:
            e.setMode(mt.TRIANGLE_FAN)
        } else i instanceof THREE.Line ? (r = r.linewidth, void 0 === r && (r = 1), wt.setLineWidth(r * (null === $ ? ot: 1)), i instanceof THREE.LineSegments ? e.setMode(mt.LINES) : e.setMode(mt.LINE_STRIP)) : i instanceof THREE.Points && e.setMode(mt.POINTS);
        n instanceof THREE.InstancedBufferGeometry ? 0 < n.maxInstancedCount && e.renderInstances(n, s, h) : e.render(s, h)
    },
    this.render = function(e, t, n, r) {
        if (0 == t instanceof THREE.Camera) console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        else {
            var i = e.fog;
            Q = "",
            K = -1,
            G = null,
            !0 === e.autoUpdate && e.updateMatrixWorld(),
            null === t.parent && t.updateMatrixWorld(),
            t.matrixWorldInverse.getInverse(t.matrixWorld),
            ct.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            lt.setFromMatrix(ct),
            j.length = 0,
            R = I = -1,
            z.length = 0,
            W.length = 0,
            p(e, t),
            F.length = I + 1,
            q.length = R + 1,
            !0 === X.sortObjects && (F.sort(l), q.sort(c));
            var s = j,
            o, u, a, f = 0,
            h = 0,
            v = 0,
            m, g, y, b = t.matrixWorldInverse,
            w = 0,
            E = 0,
            x = 0,
            T = 0,
            N = 0;
            o = pt.shadowsPointLight = 0;
            for (u = s.length; o < u; o++) if (a = s[o], m = a.color, g = a.intensity, y = a.distance, a instanceof THREE.AmbientLight) f += m.r * g,
            h += m.g * g,
            v += m.b * g;
            else if (a instanceof THREE.DirectionalLight) {
                var C = Tt.get(a);
                C.color.copy(a.color).multiplyScalar(a.intensity),
                C.direction.setFromMatrixPosition(a.matrixWorld),
                ht.setFromMatrixPosition(a.target.matrixWorld),
                C.direction.sub(ht),
                C.direction.transformDirection(b);
                if (C.shadow = a.castShadow) C.shadowBias = a.shadow.bias,
                C.shadowRadius = a.shadow.radius,
                C.shadowMapSize = a.shadow.mapSize,
                pt.shadows[N++] = a;
                pt.directionalShadowMap[w] = a.shadow.map,
                pt.directionalShadowMatrix[w] = a.shadow.matrix,
                pt.directional[w++] = C
            } else if (a instanceof THREE.SpotLight) {
                C = Tt.get(a),
                C.position.setFromMatrixPosition(a.matrixWorld),
                C.position.applyMatrix4(b),
                C.color.copy(m).multiplyScalar(g),
                C.distance = y,
                C.direction.setFromMatrixPosition(a.matrixWorld),
                ht.setFromMatrixPosition(a.target.matrixWorld),
                C.direction.sub(ht),
                C.direction.transformDirection(b),
                C.coneCos = Math.cos(a.angle),
                C.penumbraCos = Math.cos(a.angle * (1 - a.penumbra)),
                C.decay = 0 === a.distance ? 0 : a.decay;
                if (C.shadow = a.castShadow) C.shadowBias = a.shadow.bias,
                C.shadowRadius = a.shadow.radius,
                C.shadowMapSize = a.shadow.mapSize,
                pt.shadows[N++] = a;
                pt.spotShadowMap[x] = a.shadow.map,
                pt.spotShadowMatrix[x] = a.shadow.matrix,
                pt.spot[x++] = C
            } else if (a instanceof THREE.PointLight) {
                C = Tt.get(a),
                C.position.setFromMatrixPosition(a.matrixWorld),
                C.position.applyMatrix4(b),
                C.color.copy(a.color).multiplyScalar(a.intensity),
                C.distance = a.distance,
                C.decay = 0 === a.distance ? 0 : a.decay;
                if (C.shadow = a.castShadow) C.shadowBias = a.shadow.bias,
                C.shadowRadius = a.shadow.radius,
                C.shadowMapSize = a.shadow.mapSize,
                pt.shadows[N++] = a;
                pt.pointShadowMap[E] = a.shadow.map,
                void 0 === pt.pointShadowMatrix[E] && (pt.pointShadowMatrix[E] = new THREE.Matrix4),
                ht.setFromMatrixPosition(a.matrixWorld).negate(),
                pt.pointShadowMatrix[E].identity().setPosition(ht),
                pt.point[E++] = C
            } else a instanceof THREE.HemisphereLight && (C = Tt.get(a), C.direction.setFromMatrixPosition(a.matrixWorld), C.direction.transformDirection(b), C.direction.normalize(), C.skyColor.copy(a.color).multiplyScalar(g), C.groundColor.copy(a.groundColor).multiplyScalar(g), pt.hemi[T++] = C);
            pt.ambient[0] = f,
            pt.ambient[1] = h,
            pt.ambient[2] = v,
            pt.directional.length = w,
            pt.spot.length = x,
            pt.point.length = E,
            pt.hemi.length = T,
            pt.shadows.length = N,
            pt.hash = w + "," + E + "," + x + "," + T + "," + N,
            kt.render(e, t),
            vt.calls = 0,
            vt.vertices = 0,
            vt.faces = 0,
            vt.points = 0,
            void 0 === n && (n = null),
            this.setRenderTarget(n),
            (this.autoClear || r) && this.clear(this.autoClearColor, this.autoClearDepth, this.autoClearStencil),
            e.overrideMaterial ? (r = e.overrideMaterial, d(F, t, i, r), d(q, t, i, r)) : (wt.setBlending(THREE.NoBlending), d(F, t, i), d(q, t, i)),
            Lt.render(e, t),
            At.render(e, t, et),
            n && (e = n.texture, e.generateMipmaps && S(n) && e.minFilter !== THREE.NearestFilter && e.minFilter !== THREE.LinearFilter && (e = n instanceof THREE.WebGLRenderTargetCube ? mt.TEXTURE_CUBE_MAP: mt.TEXTURE_2D, n = Et.get(n.texture).__webglTexture, wt.bindTexture(e, n), mt.generateMipmap(e), wt.bindTexture(e, null))),
            wt.setDepthTest(!0),
            wt.setDepthWrite(!0),
            wt.setColorWrite(!0)
        }
    },
    this.setFaceCulling = function(e, t) {
        e === THREE.CullFaceNone ? wt.disable(mt.CULL_FACE) : (t === THREE.FrontFaceDirectionCW ? mt.frontFace(mt.CW) : mt.frontFace(mt.CCW), e === THREE.CullFaceBack ? mt.cullFace(mt.BACK) : e === THREE.CullFaceFront ? mt.cullFace(mt.FRONT) : mt.cullFace(mt.FRONT_AND_BACK), wt.enable(mt.CULL_FACE))
    },
    this.setTexture = function(e, t) {
        var n = Et.get(e);
        if (0 < e.version && n.__version !== e.version) {
            var r = e.image;
            if (void 0 === r) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined", e);
            else if (!1 === r.complete) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete", e);
            else {
                void 0 === n.__webglInit && (n.__webglInit = !0, e.addEventListener("dispose", s), n.__webglTexture = mt.createTexture(), dt.textures++),
                wt.activeTexture(mt.TEXTURE0 + t),
                wt.bindTexture(mt.TEXTURE_2D, n.__webglTexture),
                mt.pixelStorei(mt.UNPACK_FLIP_Y_WEBGL, e.flipY),
                mt.pixelStorei(mt.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e.premultiplyAlpha),
                mt.pixelStorei(mt.UNPACK_ALIGNMENT, e.unpackAlignment);
                var i = E(e.image, bt.maxTextureSize);
                if ((e.wrapS !== THREE.ClampToEdgeWrapping || e.wrapT !== THREE.ClampToEdgeWrapping || e.minFilter !== THREE.NearestFilter && e.minFilter !== THREE.LinearFilter) && !1 === S(i)) if (r = i, r instanceof HTMLImageElement || r instanceof HTMLCanvasElement) {
                    var o = document.createElement("canvas");
                    o.width = THREE.Math.nearestPowerOfTwo(r.width),
                    o.height = THREE.Math.nearestPowerOfTwo(r.height),
                    o.getContext("2d").drawImage(r, 0, 0, o.width, o.height),
                    console.warn("THREE.WebGLRenderer: image is not power of two (" + r.width + "x" + r.height + "). Resized to " + o.width + "x" + o.height, r),
                    i = o
                } else i = r;
                var r = S(i),
                o = L(e.format),
                u = L(e.type);
                w(mt.TEXTURE_2D, e, r);
                var a = e.mipmaps;
                if (e instanceof THREE.DataTexture) if (0 < a.length && r) {
                    for (var f = 0,
                    l = a.length; f < l; f++) i = a[f],
                    wt.texImage2D(mt.TEXTURE_2D, f, o, i.width, i.height, 0, o, u, i.data);
                    e.generateMipmaps = !1
                } else wt.texImage2D(mt.TEXTURE_2D, 0, o, i.width, i.height, 0, o, u, i.data);
                else if (e instanceof THREE.CompressedTexture) for (f = 0, l = a.length; f < l; f++) i = a[f],
                e.format !== THREE.RGBAFormat && e.format !== THREE.RGBFormat ? -1 < wt.getCompressedTextureFormats().indexOf(o) ? wt.compressedTexImage2D(mt.TEXTURE_2D, f, o, i.width, i.height, 0, i.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : wt.texImage2D(mt.TEXTURE_2D, f, o, i.width, i.height, 0, o, u, i.data);
                else if (0 < a.length && r) {
                    f = 0;
                    for (l = a.length; f < l; f++) i = a[f],
                    wt.texImage2D(mt.TEXTURE_2D, f, o, o, u, i);
                    e.generateMipmaps = !1
                } else wt.texImage2D(mt.TEXTURE_2D, 0, o, o, u, i);
                e.generateMipmaps && r && mt.generateMipmap(mt.TEXTURE_2D),
                n.__version = e.version,
                e.onUpdate && e.onUpdate(e)
            }
        } else wt.activeTexture(mt.TEXTURE0 + t),
        wt.bindTexture(mt.TEXTURE_2D, n.__webglTexture)
    },
    this.getCurrentRenderTarget = function() {
        return $
    },
    this.setRenderTarget = function(e) {
        if (($ = e) && void 0 === Et.get(e).__webglFramebuffer) {
            var t = Et.get(e),
            n = Et.get(e.texture);
            e.addEventListener("dispose", o),
            n.__webglTexture = mt.createTexture(),
            dt.textures++;
            var r = e instanceof THREE.WebGLRenderTargetCube,
            i = THREE.Math.isPowerOfTwo(e.width) && THREE.Math.isPowerOfTwo(e.height);
            if (r) {
                t.__webglFramebuffer = [];
                for (var s = 0; 6 > s; s++) t.__webglFramebuffer[s] = mt.createFramebuffer()
            } else t.__webglFramebuffer = mt.createFramebuffer();
            if (r) {
                wt.bindTexture(mt.TEXTURE_CUBE_MAP, n.__webglTexture),
                w(mt.TEXTURE_CUBE_MAP, e.texture, i);
                for (s = 0; 6 > s; s++) N(t.__webglFramebuffer[s], e, mt.COLOR_ATTACHMENT0, mt.TEXTURE_CUBE_MAP_POSITIVE_X + s);
                e.texture.generateMipmaps && i && mt.generateMipmap(mt.TEXTURE_CUBE_MAP),
                wt.bindTexture(mt.TEXTURE_CUBE_MAP, null)
            } else wt.bindTexture(mt.TEXTURE_2D, n.__webglTexture),
            w(mt.TEXTURE_2D, e.texture, i),
            N(t.__webglFramebuffer, e, mt.COLOR_ATTACHMENT0, mt.TEXTURE_2D),
            e.texture.generateMipmaps && i && mt.generateMipmap(mt.TEXTURE_2D),
            wt.bindTexture(mt.TEXTURE_2D, null);
            if (e.depthBuffer) {
                t = Et.get(e);
                if (e instanceof THREE.WebGLRenderTargetCube) for (t.__webglDepthbuffer = [], n = 0; 6 > n; n++) mt.bindFramebuffer(mt.FRAMEBUFFER, t.__webglFramebuffer[n]),
                t.__webglDepthbuffer[n] = mt.createRenderbuffer(),
                C(t.__webglDepthbuffer[n], e);
                else mt.bindFramebuffer(mt.FRAMEBUFFER, t.__webglFramebuffer),
                t.__webglDepthbuffer = mt.createRenderbuffer(),
                C(t.__webglDepthbuffer, e);
                mt.bindFramebuffer(mt.FRAMEBUFFER, null)
            }
        }
        t = e instanceof THREE.WebGLRenderTargetCube,
        e ? (n = Et.get(e), n = t ? n.__webglFramebuffer[e.activeCubeFace] : n.__webglFramebuffer, Y.copy(e.scissor), Z = e.scissorTest, et.copy(e.viewport)) : (n = null, Y.copy(ut).multiplyScalar(ot), Z = at, et.copy(ft).multiplyScalar(ot)),
        J !== n && (mt.bindFramebuffer(mt.FRAMEBUFFER, n), J = n),
        wt.scissor(Y),
        wt.setScissorTest(Z),
        wt.viewport(et),
        t && (t = Et.get(e.texture), mt.framebufferTexture2D(mt.FRAMEBUFFER, mt.COLOR_ATTACHMENT0, mt.TEXTURE_CUBE_MAP_POSITIVE_X + e.activeCubeFace, t.__webglTexture, e.activeMipMapLevel))
    },
    this.readRenderTargetPixels = function(e, t, n, r, i, s) {
        if (0 == e instanceof THREE.WebGLRenderTarget) console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        else {
            var o = Et.get(e).__webglFramebuffer;
            if (o) {
                var u = !1;
                o !== J && (mt.bindFramebuffer(mt.FRAMEBUFFER, o), u = !0);
                try {
                    var a = e.texture;
                    a.format !== THREE.RGBAFormat && L(a.format) !== mt.getParameter(mt.IMPLEMENTATION_COLOR_READ_FORMAT) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : a.type === THREE.UnsignedByteType || L(a.type) === mt.getParameter(mt.IMPLEMENTATION_COLOR_READ_TYPE) || a.type === THREE.FloatType && yt.get("WEBGL_color_buffer_float") || a.type === THREE.HalfFloatType && yt.get("EXT_color_buffer_half_float") ? mt.checkFramebufferStatus(mt.FRAMEBUFFER) === mt.FRAMEBUFFER_COMPLETE ? mt.readPixels(t, n, r, i, L(a.format), L(a.type), s) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                } finally {
                    u && mt.bindFramebuffer(mt.FRAMEBUFFER, J)
                }
            }
        }
    }
},
THREE.WebGLRenderTarget = function(e, t, n) {
    this.uuid = THREE.Math.generateUUID(),
    this.width = e,
    this.height = t,
    this.scissor = new THREE.Vector4(0, 0, e, t),
    this.scissorTest = !1,
    this.viewport = new THREE.Vector4(0, 0, e, t),
    n = n || {},
    void 0 === n.minFilter && (n.minFilter = THREE.LinearFilter),
    this.texture = new THREE.Texture(void 0, void 0, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy),
    this.depthBuffer = void 0 !== n.depthBuffer ? n.depthBuffer: !0,
    this.stencilBuffer = void 0 !== n.stencilBuffer ? n.stencilBuffer: !0
},
THREE.WebGLRenderTarget.prototype = {
    constructor: THREE.WebGLRenderTarget,
    setSize: function(e, t) {
        if (this.width !== e || this.height !== t) this.width = e,
        this.height = t,
        this.dispose();
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    },
    clone: function() {
        return (new this.constructor).copy(this)
    },
    copy: function(e) {
        return this.width = e.width,
        this.height = e.height,
        this.viewport.copy(e.viewport),
        this.texture = e.texture.clone(),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this
    },
    dispose: function() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
},
THREE.EventDispatcher.prototype.apply(THREE.WebGLRenderTarget.prototype),
THREE.WebGLRenderTargetCube = function(e, t, n) {
    THREE.WebGLRenderTarget.call(this, e, t, n),
    this.activeMipMapLevel = this.activeCubeFace = 0
},
THREE.WebGLRenderTargetCube.prototype = Object.create(THREE.WebGLRenderTarget.prototype),
THREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube,
THREE.WebGLBufferRenderer = function(e, t, n) {
    var r;
    this.setMode = function(e) {
        r = e
    },
    this.render = function(t, i) {
        e.drawArrays(r, t, i),
        n.calls++,
        n.vertices += i,
        r === e.TRIANGLES && (n.faces += i / 3)
    },
    this.renderInstances = function(i) {
        var s = t.get("ANGLE_instanced_arrays");
        if (null === s) console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
        else {
            var o = i.attributes.position,
            u = 0,
            u = o instanceof THREE.InterleavedBufferAttribute ? o.data.count: o.count;
            s.drawArraysInstancedANGLE(r, 0, u, i.maxInstancedCount),
            n.calls++,
            n.vertices += u * i.maxInstancedCount,
            r === e.TRIANGLES && (n.faces += i.maxInstancedCount * u / 3)
        }
    }
},
THREE.WebGLIndexedBufferRenderer = function(e, t, n) {
    var r, i, s;
    this.setMode = function(e) {
        r = e
    },
    this.setIndex = function(n) {
        n.array instanceof Uint32Array && t.get("OES_element_index_uint") ? (i = e.UNSIGNED_INT, s = 4) : (i = e.UNSIGNED_SHORT, s = 2)
    },
    this.render = function(t, o) {
        e.drawElements(r, o, i, t * s),
        n.calls++,
        n.vertices += o,
        r === e.TRIANGLES && (n.faces += o / 3)
    },
    this.renderInstances = function(o, u, l) {
        var h = t.get("ANGLE_instanced_arrays");
        null === h ? console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.") : (h.drawElementsInstancedANGLE(r, l, i, u * s, o.maxInstancedCount), n.calls++, n.vertices += l * o.maxInstancedCount, r === e.TRIANGLES && (n.faces += o.maxInstancedCount * l / 3))
    }
},
THREE.WebGLExtensions = function(e) {
    var t = {};
    this.get = function(n) {
        if (void 0 !== t[n]) return t[n];
        var r;
        switch (n) {
        case "EXT_texture_filter_anisotropic":
            r = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            r = e.getExtension("WEBGL_compressed_texture_s3tc") || e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            r = e.getExtension("WEBGL_compressed_texture_pvrtc") || e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        case "WEBGL_compressed_texture_etc1":
            r = e.getExtension("WEBGL_compressed_texture_etc1");
            break;
        default:
            r = e.getExtension(n)
        }
        return null === r && console.warn("THREE.WebGLRenderer: " + n + " extension not supported."),
        t[n] = r
    }
},
THREE.WebGLCapabilities = function(e, t, n) {
    function r(t) {
        if ("highp" === t) {
            if (0 < e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision && 0 < e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision) return "highp";
            t = "mediump"
        }
        return "mediump" === t && 0 < e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision && 0 < e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision ? "mediump": "lowp"
    }
    this.getMaxPrecision = r,
    this.precision = void 0 !== n.precision ? n.precision: "highp",
    this.logarithmicDepthBuffer = void 0 !== n.logarithmicDepthBuffer ? n.logarithmicDepthBuffer: !1,
    this.maxTextures = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
    this.maxVertexTextures = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE),
    this.maxCubemapSize = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
    this.maxAttributes = e.getParameter(e.MAX_VERTEX_ATTRIBS),
    this.maxVertexUniforms = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
    this.maxVaryings = e.getParameter(e.MAX_VARYING_VECTORS),
    this.maxFragmentUniforms = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
    this.vertexTextures = 0 < this.maxVertexTextures,
    this.floatFragmentTextures = !!t.get("OES_texture_float"),
    this.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures,
    n = r(this.precision),
    n !== this.precision && (console.warn("THREE.WebGLRenderer:", this.precision, "not supported, using", n, "instead."), this.precision = n),
    this.logarithmicDepthBuffer && (this.logarithmicDepthBuffer = !!t.get("EXT_frag_depth"))
},
THREE.WebGLGeometries = function(e, t, n) {
    function r(e) {
        var o = e.target;
        e = s[o.id],
        null !== e.index && i(e.index);
        var u = e.attributes,
        a;
        for (a in u) i(u[a]);
        o.removeEventListener("dispose", r),
        delete s[o.id],
        a = t.get(o),
        a.wireframe && i(a.wireframe),
        t.delete(o),
        o = t.get(e),
        o.wireframe && i(o.wireframe),
        t.delete(e),
        n.memory.geometries--
    }
    function i(n) {
        var r;
        r = n instanceof THREE.InterleavedBufferAttribute ? t.get(n.data).__webglBuffer: t.get(n).__webglBuffer,
        void 0 !== r && (e.deleteBuffer(r), n instanceof THREE.InterleavedBufferAttribute ? t.delete(n.data) : t.delete(n))
    }
    var s = {};
    this.get = function(e) {
        var t = e.geometry;
        if (void 0 !== s[t.id]) return s[t.id];
        t.addEventListener("dispose", r);
        var i;
        return t instanceof THREE.BufferGeometry ? i = t: t instanceof THREE.Geometry && (void 0 === t._bufferGeometry && (t._bufferGeometry = (new THREE.BufferGeometry).setFromObject(e)), i = t._bufferGeometry),
        s[t.id] = i,
        n.memory.geometries++,
        i
    }
},
THREE.WebGLLights = function() {
    var e = {};
    this.get = function(t) {
        if (void 0 !== e[t.id]) return e[t.id];
        var n;
        switch (t.type) {
        case "DirectionalLight":
            n = {
                direction: new THREE.Vector3,
                color: new THREE.Color,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new THREE.Vector2
            };
            break;
        case "SpotLight":
            n = {
                position: new THREE.Vector3,
                direction: new THREE.Vector3,
                color: new THREE.Color,
                distance: 0,
                coneCos: 0,
                penumbraCos: 0,
                decay: 0,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new THREE.Vector2
            };
            break;
        case "PointLight":
            n = {
                position: new THREE.Vector3,
                color: new THREE.Color,
                distance: 0,
                decay: 0,
                shadow: !1,
                shadowBias: 0,
                shadowRadius: 1,
                shadowMapSize: new THREE.Vector2
            };
            break;
        case "HemisphereLight":
            n = {
                direction: new THREE.Vector3,
                skyColor: new THREE.Color,
                groundColor: new THREE.Color
            }
        }
        return e[t.id] = n
    }
},
THREE.WebGLObjects = function(e, t, n) {
    function r(n, r) {
        var i = n instanceof THREE.InterleavedBufferAttribute ? n.data: n,
        s = t.get(i);
        void 0 === s.__webglBuffer ? (s.__webglBuffer = e.createBuffer(), e.bindBuffer(r, s.__webglBuffer), e.bufferData(r, i.array, i.dynamic ? e.DYNAMIC_DRAW: e.STATIC_DRAW), s.version = i.version) : s.version !== i.version && (e.bindBuffer(r, s.__webglBuffer), !1 === i.dynamic || -1 === i.updateRange.count ? e.bufferSubData(r, 0, i.array) : 0 === i.updateRange.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (e.bufferSubData(r, i.updateRange.offset * i.array.BYTES_PER_ELEMENT, i.array.subarray(i.updateRange.offset, i.updateRange.offset + i.updateRange.count)), i.updateRange.count = 0), s.version = i.version)
    }
    function i(e, t, n) {
        if (t > n) {
            var r = t;
            t = n,
            n = r
        }
        return r = e[t],
        void 0 === r ? (e[t] = [n], !0) : -1 === r.indexOf(n) ? (r.push(n), !0) : !1
    }
    var s = new THREE.WebGLGeometries(e, t, n);
    this.getAttributeBuffer = function(e) {
        return e instanceof THREE.InterleavedBufferAttribute ? t.get(e.data).__webglBuffer: t.get(e).__webglBuffer
    },
    this.getWireframeAttribute = function(n) {
        var s = t.get(n);
        if (void 0 !== s.wireframe) return s.wireframe;
        var o = [],
        u = n.index,
        f = n.attributes;
        n = f.position;
        if (null !== u) for (var f = {},
        u = u.array,
        l = 0,
        c = u.length; l < c; l += 3) {
            var h = u[l + 0],
            p = u[l + 1],
            v = u[l + 2];
            i(f, h, p) && o.push(h, p),
            i(f, p, v) && o.push(p, v),
            i(f, v, h) && o.push(v, h)
        } else for (u = f.position.array, l = 0, c = u.length / 3 - 1; l < c; l += 3) h = l + 0,
        p = l + 1,
        v = l + 2,
        o.push(h, p, p, v, v, h);
        return o = new THREE.BufferAttribute(new(65535 < n.count ? Uint32Array: Uint16Array)(o), 1),
        r(o, e.ELEMENT_ARRAY_BUFFER),
        s.wireframe = o
    },
    this.update = function(t) {
        var n = s.get(t);
        t.geometry instanceof THREE.Geometry && n.updateFromObject(t),
        t = n.index;
        var i = n.attributes;
        null !== t && r(t, e.ELEMENT_ARRAY_BUFFER);
        for (var o in i) r(i[o], e.ARRAY_BUFFER);
        t = n.morphAttributes;
        for (o in t) for (var i = t[o], u = 0, l = i.length; u < l; u++) r(i[u], e.ARRAY_BUFFER);
        return n
    }
},
THREE.WebGLProgram = function() {
    function e(e) {
        switch (e) {
        case THREE.LinearEncoding:
            return ["Linear", "( value )"];
        case THREE.sRGBEncoding:
            return ["sRGB", "( value )"];
        case THREE.RGBEEncoding:
            return ["RGBE", "( value )"];
        case THREE.RGBM7Encoding:
            return ["RGBM", "( value, 7.0 )"];
        case THREE.RGBM16Encoding:
            return ["RGBM", "( value, 16.0 )"];
        case THREE.RGBDEncoding:
            return ["RGBD", "( value, 256.0 )"];
        case THREE.GammaEncoding:
            return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
        default:
            throw Error("unsupported encoding: " + e)
        }
    }
    function t(t, n) {
        var r = e(n);
        return "vec4 " + t + "( vec4 value ) { return " + r[0] + "ToLinear" + r[1] + "; }"
    }
    function n(t, n) {
        var r = e(n);
        return "vec4 " + t + "( vec4 value ) { return LinearTo" + r[0] + r[1] + "; }"
    }
    function r(e, t) {
        var n;
        switch (t) {
        case THREE.LinearToneMapping:
            n = "Linear";
            break;
        case THREE.ReinhardToneMapping:
            n = "Reinhard";
            break;
        case THREE.Uncharted2ToneMapping:
            n = "Uncharted2";
            break;
        case THREE.CineonToneMapping:
            n = "OptimizedCineon";
            break;
        default:
            throw Error("unsupported toneMapping: " + t)
        }
        return "vec3 " + e + "( vec3 color ) { return " + n + "ToneMapping( color ); }"
    }
    function i(e, t, n) {
        return e = e || {},
        [e.derivatives || t.envMapCubeUV || t.bumpMap || t.normalMap || t.flatShading ? "#extension GL_OES_standard_derivatives : enable": "", (e.fragDepth || t.logarithmicDepthBuffer) && n.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable": "", e.drawBuffers && n.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require": "", (e.shaderTextureLOD || t.envMap) && n.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable": ""].filter(o).join("\n")
    }
    function s(e) {
        var t = [],
        n;
        for (n in e) {
            var r = e[n]; ! 1 !== r && t.push("#define " + n + " " + r)
        }
        return t.join("\n")
    }
    function o(e) {
        return "" !== e
    }
    function u(e, t) {
        return e.replace(/NUM_DIR_LIGHTS/g, t.numDirLights).replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights).replace(/NUM_POINT_LIGHTS/g, t.numPointLights).replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    }
    function a(e) {
        return e.replace(/#include +<([\w\d.]+)>/g,
        function(e, t) {
            var n = THREE.ShaderChunk[t];
            if (void 0 === n) throw Error("Can not resolve #include <" + t + ">");
            return a(n)
        })
    }
    function f(e) {
        return e.replace(/for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g,
        function(e, t, n, r) {
            e = "";
            for (t = parseInt(t); t < parseInt(n); t++) e += r.replace(/\[ i \]/g, "[ " + t + " ]");
            return e
        })
    }
    var l = 0,
    c = /^([\w\d_]+)\.([\w\d_]+)$/,
    h = /^([\w\d_]+)\[(\d+)\]\.([\w\d_]+)$/,
    p = /^([\w\d_]+)\[0\]$/;
    return function(e, v, y, w) {
        var E = e.context,
        S = y.extensions,
        x = y.defines,
        T = y.__webglShader.vertexShader,
        N = y.__webglShader.fragmentShader,
        C = "SHADOWMAP_TYPE_BASIC";
        w.shadowMapType === THREE.PCFShadowMap ? C = "SHADOWMAP_TYPE_PCF": w.shadowMapType === THREE.PCFSoftShadowMap && (C = "SHADOWMAP_TYPE_PCF_SOFT");
        var L = "ENVMAP_TYPE_CUBE",
        A = "ENVMAP_MODE_REFLECTION",
        O = "ENVMAP_BLENDING_MULTIPLY";
        if (w.envMap) {
            switch (y.envMap.mapping) {
            case THREE.CubeReflectionMapping:
            case THREE.CubeRefractionMapping:
                L = "ENVMAP_TYPE_CUBE";
                break;
            case THREE.CubeUVReflectionMapping:
            case THREE.CubeUVRefractionMapping:
                L = "ENVMAP_TYPE_CUBE_UV";
                break;
            case THREE.EquirectangularReflectionMapping:
            case THREE.EquirectangularRefractionMapping:
                L = "ENVMAP_TYPE_EQUIREC";
                break;
            case THREE.SphericalReflectionMapping:
                L = "ENVMAP_TYPE_SPHERE"
            }
            switch (y.envMap.mapping) {
            case THREE.CubeRefractionMapping:
            case THREE.EquirectangularRefractionMapping:
                A = "ENVMAP_MODE_REFRACTION"
            }
            switch (y.combine) {
            case THREE.MultiplyOperation:
                O = "ENVMAP_BLENDING_MULTIPLY";
                break;
            case THREE.MixOperation:
                O = "ENVMAP_BLENDING_MIX";
                break;
            case THREE.AddOperation:
                O = "ENVMAP_BLENDING_ADD"
            }
        }
        var M = 0 < e.gammaFactor ? e.gammaFactor: 1,
        S = i(S, w, e.extensions),
        _ = s(x),
        D = E.createProgram();
        y instanceof THREE.RawShaderMaterial ? e = x = "": (x = ["precision " + w.precision + " float;", "precision " + w.precision + " int;", "#define SHADER_NAME " + y.__webglShader.name, _, w.supportsVertexTextures ? "#define VERTEX_TEXTURES": "", "#define GAMMA_FACTOR " + M, "#define MAX_BONES " + w.maxBones, w.map ? "#define USE_MAP": "", w.envMap ? "#define USE_ENVMAP": "", w.envMap ? "#define " + A: "", w.lightMap ? "#define USE_LIGHTMAP": "", w.aoMap ? "#define USE_AOMAP": "", w.emissiveMap ? "#define USE_EMISSIVEMAP": "", w.bumpMap ? "#define USE_BUMPMAP": "", w.normalMap ? "#define USE_NORMALMAP": "", w.displacementMap && w.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP": "", w.specularMap ? "#define USE_SPECULARMAP": "", w.roughnessMap ? "#define USE_ROUGHNESSMAP": "", w.metalnessMap ? "#define USE_METALNESSMAP": "", w.alphaMap ? "#define USE_ALPHAMAP": "", w.vertexColors ? "#define USE_COLOR": "", w.flatShading ? "#define FLAT_SHADED": "", w.skinning ? "#define USE_SKINNING": "", w.useVertexTexture ? "#define BONE_TEXTURE": "", w.morphTargets ? "#define USE_MORPHTARGETS": "", w.morphNormals && !1 === w.flatShading ? "#define USE_MORPHNORMALS": "", w.doubleSided ? "#define DOUBLE_SIDED": "", w.flipSided ? "#define FLIP_SIDED": "", w.shadowMapEnabled ? "#define USE_SHADOWMAP": "", w.shadowMapEnabled ? "#define " + C: "", 0 < w.pointLightShadows ? "#define POINT_LIGHT_SHADOWS": "", w.sizeAttenuation ? "#define USE_SIZEATTENUATION": "", w.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF": "", w.logarithmicDepthBuffer && e.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT": "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "	attribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "	attribute vec3 morphTarget0;", "	attribute vec3 morphTarget1;", "	attribute vec3 morphTarget2;", "	attribute vec3 morphTarget3;", "	#ifdef USE_MORPHNORMALS", "		attribute vec3 morphNormal0;", "		attribute vec3 morphNormal1;", "		attribute vec3 morphNormal2;", "		attribute vec3 morphNormal3;", "	#else", "		attribute vec3 morphTarget4;", "		attribute vec3 morphTarget5;", "		attribute vec3 morphTarget6;", "		attribute vec3 morphTarget7;", "	#endif", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", "\n"].filter(o).join("\n"), e = [S, "precision " + w.precision + " float;", "precision " + w.precision + " int;", "#define SHADER_NAME " + y.__webglShader.name, _, w.alphaTest ? "#define ALPHATEST " + w.alphaTest: "", "#define GAMMA_FACTOR " + M, w.useFog && w.fog ? "#define USE_FOG": "", w.useFog && w.fogExp ? "#define FOG_EXP2": "", w.map ? "#define USE_MAP": "", w.envMap ? "#define USE_ENVMAP": "", w.envMap ? "#define " + L: "", w.envMap ? "#define " + A: "", w.envMap ? "#define " + O: "", w.lightMap ? "#define USE_LIGHTMAP": "", w.aoMap ? "#define USE_AOMAP": "", w.emissiveMap ? "#define USE_EMISSIVEMAP": "", w.bumpMap ? "#define USE_BUMPMAP": "", w.normalMap ? "#define USE_NORMALMAP": "", w.specularMap ? "#define USE_SPECULARMAP": "", w.roughnessMap ? "#define USE_ROUGHNESSMAP": "", w.metalnessMap ? "#define USE_METALNESSMAP": "", w.alphaMap ? "#define USE_ALPHAMAP": "", w.vertexColors ? "#define USE_COLOR": "", w.flatShading ? "#define FLAT_SHADED": "", w.doubleSided ? "#define DOUBLE_SIDED": "", w.flipSided ? "#define FLIP_SIDED": "", w.shadowMapEnabled ? "#define USE_SHADOWMAP": "", w.shadowMapEnabled ? "#define " + C: "", 0 < w.pointLightShadows ? "#define POINT_LIGHT_SHADOWS": "", w.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA": "", w.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS": "", w.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF": "", w.logarithmicDepthBuffer && e.extensions.get("EXT_frag_depth") ? "#define USE_LOGDEPTHBUF_EXT": "", w.envMap && e.extensions.get("EXT_shader_texture_lod") ? "#define TEXTURE_LOD_EXT": "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", w.toneMapping !== THREE.NoToneMapping ? "#define TONE_MAPPING": "", w.toneMapping !== THREE.NoToneMapping ? THREE.ShaderChunk.tonemapping_pars_fragment: "", w.toneMapping !== THREE.NoToneMapping ? r("toneMapping", w.toneMapping) : "", w.outputEncoding || w.mapEncoding || w.envMapEncoding || w.emissiveMapEncoding ? THREE.ShaderChunk.encodings_pars_fragment: "", w.mapEncoding ? t("mapTexelToLinear", w.mapEncoding) : "", w.envMapEncoding ? t("envMapTexelToLinear", w.envMapEncoding) : "", w.emissiveMapEncoding ? t("emissiveMapTexelToLinear", w.emissiveMapEncoding) : "", w.outputEncoding ? n("linearToOutputTexel", w.outputEncoding) : "", "\n"].filter(o).join("\n")),
        T = a(T, w),
        T = u(T, w),
        N = a(N, w),
        N = u(N, w),
        0 == y instanceof THREE.ShaderMaterial && (T = f(T), N = f(N)),
        N = e + N,
        T = THREE.WebGLShader(E, E.VERTEX_SHADER, x + T),
        N = THREE.WebGLShader(E, E.FRAGMENT_SHADER, N),
        E.attachShader(D, T),
        E.attachShader(D, N),
        void 0 !== y.index0AttributeName ? E.bindAttribLocation(D, 0, y.index0AttributeName) : !0 === w.morphTargets && E.bindAttribLocation(D, 0, "position"),
        E.linkProgram(D),
        w = E.getProgramInfoLog(D),
        C = E.getShaderInfoLog(T),
        L = E.getShaderInfoLog(N),
        O = A = !0;
        if (!1 === E.getProgramParameter(D, E.LINK_STATUS)) A = !1,
        console.error("THREE.WebGLProgram: shader error: ", E.getError(), "gl.VALIDATE_STATUS", E.getProgramParameter(D, E.VALIDATE_STATUS), "gl.getProgramInfoLog", w, C, L);
        else if ("" !== w) console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", w);
        else if ("" === C || "" === L) O = !1;
        O && (this.diagnostics = {
            runnable: A,
            material: y,
            programLog: w,
            vertexShader: {
                log: C,
                prefix: x
            },
            fragmentShader: {
                log: L,
                prefix: e
            }
        }),
        E.deleteShader(T),
        E.deleteShader(N);
        var P;
        this.getUniforms = function() {
            if (void 0 === P) {
                for (var e = {},
                t = E.getProgramParameter(D, E.ACTIVE_UNIFORMS), n = 0; n < t; n++) {
                    var r = E.getActiveUniform(D, n).name,
                    i = E.getUniformLocation(D, r),
                    s = c.exec(r);
                    if (s) {
                        var r = s[1],
                        s = s[2],
                        o = e[r];
                        o || (o = e[r] = {}),
                        o[s] = i
                    } else if (s = h.exec(r)) {
                        var o = s[1],
                        r = s[2],
                        s = s[3],
                        u = e[o];
                        u || (u = e[o] = []),
                        (o = u[r]) || (o = u[r] = {}),
                        o[s] = i
                    } else(s = p.exec(r)) ? (o = s[1], e[o] = i) : e[r] = i
                }
                P = e
            }
            return P
        };
        var H;
        return this.getAttributes = function() {
            if (void 0 === H) {
                for (var e = {},
                t = E.getProgramParameter(D, E.ACTIVE_ATTRIBUTES), n = 0; n < t; n++) {
                    var r = E.getActiveAttrib(D, n).name;
                    e[r] = E.getAttribLocation(D, r)
                }
                H = e
            }
            return H
        },
        this.destroy = function() {
            E.deleteProgram(D),
            this.program = void 0
        },
        Object.defineProperties(this, {
            uniforms: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."),
                    this.getUniforms()
                }
            },
            attributes: {
                get: function() {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."),
                    this.getAttributes()
                }
            }
        }),
        this.id = l++,
        this.code = v,
        this.usedTimes = 1,
        this.program = D,
        this.vertexShader = T,
        this.fragmentShader = N,
        this
    }
} (),
THREE.WebGLPrograms = function(e, t) {
    function n(e, t) {
        var n;
        return e ? e instanceof THREE.Texture ? n = e.encoding: e instanceof THREE.WebGLRenderTarget && (n = e.texture.encoding) : n = THREE.LinearEncoding,
        n === THREE.LinearEncoding && t && (n = THREE.GammaEncoding),
        n
    }
    var r = [],
    i = {
        MeshDepthMaterial: "depth",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshStandardMaterial: "standard",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points"
    },
    s = "precision supportsVertexTextures map mapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap displacementMap specularMap roughnessMap metalnessMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights shadowMapEnabled pointLightShadows toneMapping physicallyCorrectLights shadowMapType alphaTest doubleSided flipSided".split(" ");
    this.getParameters = function(r, s, o, u) {
        var f = i[r.type],
        l;
        t.floatVertexTextures && u && u.skeleton && u.skeleton.useVertexTexture ? l = 1024 : (l = Math.floor((t.maxVertexUniforms - 20) / 4), void 0 !== u && u instanceof THREE.SkinnedMesh && (l = Math.min(u.skeleton.bones.length, l), l < u.skeleton.bones.length && console.warn("WebGLRenderer: too many bones - " + u.skeleton.bones.length + ", this GPU supports just " + l + " (try OpenGL instead of ANGLE)")));
        var h = e.getPrecision();
        return null !== r.precision && (h = t.getMaxPrecision(r.precision), h !== r.precision && console.warn("THREE.WebGLProgram.getParameters:", r.precision, "not supported, using", h, "instead.")),
        {
            shaderID: f,
            precision: h,
            supportsVertexTextures: t.vertexTextures,
            outputEncoding: n(e.getCurrentRenderTarget(), e.gammaOutput),
            map: !!r.map,
            mapEncoding: n(r.map, e.gammaInput),
            envMap: !!r.envMap,
            envMapMode: r.envMap && r.envMap.mapping,
            envMapEncoding: n(r.envMap, e.gammaInput),
            envMapCubeUV: !!r.envMap && (r.envMap.mapping === THREE.CubeUVReflectionMapping || r.envMap.mapping === THREE.CubeUVRefractionMapping),
            lightMap: !!r.lightMap,
            aoMap: !!r.aoMap,
            emissiveMap: !!r.emissiveMap,
            emissiveMapEncoding: n(r.emissiveMap, e.gammaInput),
            bumpMap: !!r.bumpMap,
            normalMap: !!r.normalMap,
            displacementMap: !!r.displacementMap,
            roughnessMap: !!r.roughnessMap,
            metalnessMap: !!r.metalnessMap,
            specularMap: !!r.specularMap,
            alphaMap: !!r.alphaMap,
            combine: r.combine,
            vertexColors: r.vertexColors,
            fog: o,
            useFog: r.fog,
            fogExp: o instanceof THREE.FogExp2,
            flatShading: r.shading === THREE.FlatShading,
            sizeAttenuation: r.sizeAttenuation,
            logarithmicDepthBuffer: t.logarithmicDepthBuffer,
            skinning: r.skinning,
            maxBones: l,
            useVertexTexture: t.floatVertexTextures && u && u.skeleton && u.skeleton.useVertexTexture,
            morphTargets: r.morphTargets,
            morphNormals: r.morphNormals,
            maxMorphTargets: e.maxMorphTargets,
            maxMorphNormals: e.maxMorphNormals,
            numDirLights: s.directional.length,
            numPointLights: s.point.length,
            numSpotLights: s.spot.length,
            numHemiLights: s.hemi.length,
            pointLightShadows: s.shadowsPointLight,
            shadowMapEnabled: e.shadowMap.enabled && u.receiveShadow && 0 < s.shadows.length,
            shadowMapType: e.shadowMap.type,
            toneMapping: e.toneMapping,
            physicallyCorrectLights: e.physicallyCorrectLights,
            premultipliedAlpha: r.premultipliedAlpha,
            alphaTest: r.alphaTest,
            doubleSided: r.side === THREE.DoubleSide,
            flipSided: r.side === THREE.BackSide
        }
    },
    this.getProgramCode = function(e, t) {
        var n = [];
        t.shaderID ? n.push(t.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader));
        if (void 0 !== e.defines) for (var r in e.defines) n.push(r),
        n.push(e.defines[r]);
        for (r = 0; r < s.length; r++) {
            var i = s[r];
            n.push(i),
            n.push(t[i])
        }
        return n.join()
    },
    this.acquireProgram = function(t, n, i) {
        for (var s, o = 0,
        u = r.length; o < u; o++) {
            var f = r[o];
            if (f.code === i) {
                s = f,
                ++s.usedTimes;
                break
            }
        }
        return void 0 === s && (s = new THREE.WebGLProgram(e, i, t, n), r.push(s)),
        s
    },
    this.releaseProgram = function(e) {
        if (0 === --e.usedTimes) {
            var t = r.indexOf(e);
            r[t] = r[r.length - 1],
            r.pop(),
            e.destroy()
        }
    },
    this.programs = r
},
THREE.WebGLProperties = function() {
    var e = {};
    this.get = function(t) {
        t = t.uuid;
        var n = e[t];
        return void 0 === n && (n = {},
        e[t] = n),
        n
    },
    this.delete = function(t) {
        delete e[t.uuid]
    },
    this.clear = function() {
        e = {}
    }
},
THREE.WebGLShader = function() {
    function e(e) {
        e = e.split("\n");
        for (var t = 0; t < e.length; t++) e[t] = t + 1 + ": " + e[t];
        return e.join("\n")
    }
    return function(t, n, r) {
        var i = t.createShader(n);
        return t.shaderSource(i, r),
        t.compileShader(i),
        !1 === t.getShaderParameter(i, t.COMPILE_STATUS) && console.error("THREE.WebGLShader: Shader couldn't compile."),
        "" !== t.getShaderInfoLog(i) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", n === t.VERTEX_SHADER ? "vertex": "fragment", t.getShaderInfoLog(i), e(r)),
        i
    }
} (),
THREE.WebGLShadowMap = function(e, t, n) {
    function r(e, t, n, r) {
        var i = e.geometry,
        s = null,
        s = p,
        o = e.customDepthMaterial;
        return n && (s = d, o = e.customDistanceMaterial),
        o ? s = o: (e = e instanceof THREE.SkinnedMesh && t.skinning, o = 0, void 0 !== i.morphTargets && 0 < i.morphTargets.length && t.morphTargets && (o |= 1), e && (o |= 2), s = s[o]),
        s.visible = t.visible,
        s.wireframe = t.wireframe,
        s.wireframeLinewidth = t.wireframeLinewidth,
        n && void 0 !== s.uniforms.lightPos && s.uniforms.lightPos.value.copy(r),
        s
    }
    function i(e, t, n) {
        if (!1 !== e.visible) {
            e.layers.test(t.layers) && (e instanceof THREE.Mesh || e instanceof THREE.Line || e instanceof THREE.Points) && e.castShadow && (!1 === e.frustumCulled || !0 === u.intersectsObject(e)) && !0 === e.material.visible && (e.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, e.matrixWorld), h.push(e)),
            e = e.children;
            for (var r = 0,
            s = e.length; r < s; r++) i(e[r], t, n)
        }
    }
    for (var s = e.context,
    o = e.state,
    u = new THREE.Frustum,
    a = new THREE.Matrix4,
    f = new THREE.Vector2,
    l = new THREE.Vector3,
    c = new THREE.Vector3,
    h = [], p = Array(4), d = Array(4), v = [new THREE.Vector3(1, 0, 0), new THREE.Vector3( - 1, 0, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0)], m = [new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)], g = [new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4, new THREE.Vector4], y = THREE.ShaderLib.depthRGBA, b = THREE.UniformsUtils.clone(y.uniforms), w = THREE.ShaderLib.distanceRGBA, E = THREE.UniformsUtils.clone(w.uniforms), S = 0; 4 !== S; ++S) {
        var x = 0 !== (S & 1),
        T = 0 !== (S & 2),
        N = new THREE.ShaderMaterial({
            uniforms: b,
            vertexShader: y.vertexShader,
            fragmentShader: y.fragmentShader,
            morphTargets: x,
            skinning: T
        });
        p[S] = N,
        x = new THREE.ShaderMaterial({
            defines: {
                USE_SHADOWMAP: ""
            },
            uniforms: E,
            vertexShader: w.vertexShader,
            fragmentShader: w.fragmentShader,
            morphTargets: x,
            skinning: T
        }),
        d[S] = x
    }
    var C = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = THREE.PCFShadowMap,
    this.cullFace = THREE.CullFaceFront,
    this.render = function(p, d) {
        var y, b, w = t.shadows;
        if (0 !== w.length && !1 !== C.enabled && (!1 !== C.autoUpdate || !1 !== C.needsUpdate)) {
            o.clearColor(1, 1, 1, 1),
            o.disable(s.BLEND),
            o.enable(s.CULL_FACE),
            s.frontFace(s.CCW),
            s.cullFace(C.cullFace === THREE.CullFaceFront ? s.FRONT: s.BACK),
            o.setDepthTest(!0),
            o.setScissorTest(!1);
            for (var E = 0,
            S = w.length; E < S; E++) {
                var x = w[E],
                T = x.shadow,
                N = T.camera;
                f.copy(T.mapSize);
                if (x instanceof THREE.PointLight) {
                    y = 6,
                    b = !0;
                    var L = f.x,
                    A = f.y;
                    g[0].set(2 * L, A, L, A),
                    g[1].set(0, A, L, A),
                    g[2].set(3 * L, A, L, A),
                    g[3].set(L, A, L, A),
                    g[4].set(3 * L, 0, L, A),
                    g[5].set(L, 0, L, A),
                    f.x *= 4,
                    f.y *= 2
                } else y = 1,
                b = !1;
                null === T.map && (T.map = new THREE.WebGLRenderTarget(f.x, f.y, {
                    minFilter: THREE.NearestFilter,
                    magFilter: THREE.NearestFilter,
                    format: THREE.RGBAFormat
                }), x instanceof THREE.SpotLight && (N.aspect = f.x / f.y), N.updateProjectionMatrix()),
                L = T.map,
                T = T.matrix,
                c.setFromMatrixPosition(x.matrixWorld),
                N.position.copy(c),
                e.setRenderTarget(L),
                e.clear();
                for (L = 0; L < y; L++) {
                    b ? (l.copy(N.position), l.add(v[L]), N.up.copy(m[L]), N.lookAt(l), o.viewport(g[L])) : (l.setFromMatrixPosition(x.target.matrixWorld), N.lookAt(l)),
                    N.updateMatrixWorld(),
                    N.matrixWorldInverse.getInverse(N.matrixWorld),
                    T.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
                    T.multiply(N.projectionMatrix),
                    T.multiply(N.matrixWorldInverse),
                    a.multiplyMatrices(N.projectionMatrix, N.matrixWorldInverse),
                    u.setFromMatrix(a),
                    h.length = 0,
                    i(p, d, N);
                    for (var A = 0,
                    O = h.length; A < O; A++) {
                        var M = h[A],
                        _ = n.update(M),
                        D = M.material;
                        if (D instanceof THREE.MultiMaterial) for (var P = _.groups,
                        D = D.materials,
                        H = 0,
                        B = P.length; H < B; H++) {
                            var j = P[H],
                            I = D[j.materialIndex]; ! 0 === I.visible && (I = r(M, I, b, c), e.renderBufferDirect(N, null, _, I, M, j))
                        } else I = r(M, D, b, c),
                        e.renderBufferDirect(N, null, _, I, M, null)
                    }
                }
            }
            y = e.getClearColor(),
            b = e.getClearAlpha(),
            e.setClearColor(y, b),
            o.enable(s.BLEND),
            C.cullFace === THREE.CullFaceFront && s.cullFace(s.BACK),
            C.needsUpdate = !1
        }
    }
},
THREE.WebGLState = function(e, t, n) {
    var r = this,
    i = new THREE.Vector4,
    s = new Uint8Array(16),
    o = new Uint8Array(16),
    u = new Uint8Array(16),
    a = {},
    f = null,
    l = null,
    c = null,
    h = null,
    p = null,
    d = null,
    v = null,
    m = null,
    g = !1,
    y = null,
    b = null,
    w = null,
    E = null,
    S = null,
    x = null,
    T = null,
    N = null,
    C = null,
    k = null,
    L = null,
    A = null,
    O = null,
    M = null,
    _ = null,
    D = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
    P = void 0,
    H = {},
    B = new THREE.Vector4,
    j = null,
    F = null,
    I = new THREE.Vector4,
    q = new THREE.Vector4,
    R = e.createTexture();
    e.bindTexture(e.TEXTURE_2D, R),
    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, e.LINEAR),
    e.texImage2D(e.TEXTURE_2D, 0, e.RGB, 1, 1, 0, e.RGB, e.UNSIGNED_BYTE, new Uint8Array(3)),
    this.init = function() {
        this.clearColor(0, 0, 0, 1),
        this.clearDepth(1),
        this.clearStencil(0),
        this.enable(e.DEPTH_TEST),
        e.depthFunc(e.LEQUAL),
        e.frontFace(e.CCW),
        e.cullFace(e.BACK),
        this.enable(e.CULL_FACE),
        this.enable(e.BLEND),
        e.blendEquation(e.FUNC_ADD),
        e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA)
    },
    this.initAttributes = function() {
        for (var e = 0,
        t = s.length; e < t; e++) s[e] = 0
    },
    this.enableAttribute = function(n) {
        s[n] = 1,
        0 === o[n] && (e.enableVertexAttribArray(n), o[n] = 1),
        0 !== u[n] && (t.get("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(n, 0), u[n] = 0)
    },
    this.enableAttributeAndDivisor = function(t, n, r) {
        s[t] = 1,
        0 === o[t] && (e.enableVertexAttribArray(t), o[t] = 1),
        u[t] !== n && (r.vertexAttribDivisorANGLE(t, n), u[t] = n)
    },
    this.disableUnusedAttributes = function() {
        for (var t = 0,
        n = o.length; t < n; t++) o[t] !== s[t] && (e.disableVertexAttribArray(t), o[t] = 0)
    },
    this.enable = function(t) { ! 0 !== a[t] && (e.enable(t), a[t] = !0)
    },
    this.disable = function(t) { ! 1 !== a[t] && (e.disable(t), a[t] = !1)
    },
    this.getCompressedTextureFormats = function() {
        if (null === f && (f = [], t.get("WEBGL_compressed_texture_pvrtc") || t.get("WEBGL_compressed_texture_s3tc") || t.get("WEBGL_compressed_texture_etc1"))) for (var n = e.getParameter(e.COMPRESSED_TEXTURE_FORMATS), r = 0; r < n.length; r++) f.push(n[r]);
        return f
    },
    this.setBlending = function(t, r, i, s, o, u, a, f) {
        t === THREE.NoBlending ? this.disable(e.BLEND) : this.enable(e.BLEND);
        if (t !== l || f !== g) t === THREE.AdditiveBlending ? f ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE, e.ONE, e.ONE)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.SRC_ALPHA, e.ONE)) : t === THREE.SubtractiveBlending ? f ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.ONE_MINUS_SRC_COLOR)) : t === THREE.MultiplyBlending ? f ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ZERO, e.ZERO, e.SRC_COLOR, e.SRC_ALPHA)) : (e.blendEquation(e.FUNC_ADD), e.blendFunc(e.ZERO, e.SRC_COLOR)) : f ? (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.ONE, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA)) : (e.blendEquationSeparate(e.FUNC_ADD, e.FUNC_ADD), e.blendFuncSeparate(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA)),
        l = t,
        g = f;
        if (t === THREE.CustomBlending) {
            o = o || r,
            u = u || i,
            a = a || s;
            if (r !== c || o !== d) e.blendEquationSeparate(n(r), n(o)),
            c = r,
            d = o;
            if (i !== h || s !== p || u !== v || a !== m) e.blendFuncSeparate(n(i), n(s), n(u), n(a)),
            h = i,
            p = s,
            v = u,
            m = a
        } else m = v = d = p = h = c = null
    },
    this.setDepthFunc = function(t) {
        if (y !== t) {
            if (t) switch (t) {
            case THREE.NeverDepth:
                e.depthFunc(e.NEVER);
                break;
            case THREE.AlwaysDepth:
                e.depthFunc(e.ALWAYS);
                break;
            case THREE.LessDepth:
                e.depthFunc(e.LESS);
                break;
            case THREE.LessEqualDepth:
                e.depthFunc(e.LEQUAL);
                break;
            case THREE.EqualDepth:
                e.depthFunc(e.EQUAL);
                break;
            case THREE.GreaterEqualDepth:
                e.depthFunc(e.GEQUAL);
                break;
            case THREE.GreaterDepth:
                e.depthFunc(e.GREATER);
                break;
            case THREE.NotEqualDepth:
                e.depthFunc(e.NOTEQUAL);
                break;
            default:
                e.depthFunc(e.LEQUAL)
            } else e.depthFunc(e.LEQUAL);
            y = t
        }
    },
    this.setDepthTest = function(t) {
        t ? this.enable(e.DEPTH_TEST) : this.disable(e.DEPTH_TEST)
    },
    this.setDepthWrite = function(t) {
        b !== t && (e.depthMask(t), b = t)
    },
    this.setColorWrite = function(t) {
        w !== t && (e.colorMask(t, t, t, t), w = t)
    },
    this.setStencilFunc = function(t, n, r) {
        if (S !== t || x !== n || T !== r) e.stencilFunc(t, n, r),
        S = t,
        x = n,
        T = r
    },
    this.setStencilOp = function(t, n, r) {
        if (N !== t || C !== n || k !== r) e.stencilOp(t, n, r),
        N = t,
        C = n,
        k = r
    },
    this.setStencilTest = function(t) {
        t ? this.enable(e.STENCIL_TEST) : this.disable(e.STENCIL_TEST)
    },
    this.setStencilWrite = function(t) {
        E !== t && (e.stencilMask(t), E = t)
    },
    this.setFlipSided = function(t) {
        L !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), L = t)
    },
    this.setLineWidth = function(t) {
        t !== A && (e.lineWidth(t), A = t)
    },
    this.setPolygonOffset = function(t, n, r) {
        t ? this.enable(e.POLYGON_OFFSET_FILL) : this.disable(e.POLYGON_OFFSET_FILL),
        !t || O === n && M === r || (e.polygonOffset(n, r), O = n, M = r)
    },
    this.getScissorTest = function() {
        return _
    },
    this.setScissorTest = function(t) { (_ = t) ? this.enable(e.SCISSOR_TEST) : this.disable(e.SCISSOR_TEST)
    },
    this.activeTexture = function(t) {
        void 0 === t && (t = e.TEXTURE0 + D - 1),
        P !== t && (e.activeTexture(t), P = t)
    },
    this.bindTexture = function(t, n) {
        void 0 === P && r.activeTexture();
        var i = H[P];
        void 0 === i && (i = {
            type: void 0,
            texture: void 0
        },
        H[P] = i);
        if (i.type !== t || i.texture !== n) e.bindTexture(t, n || R),
        i.type = t,
        i.texture = n
    },
    this.compressedTexImage2D = function() {
        try {
            e.compressedTexImage2D.apply(e, arguments)
        } catch(t) {
            console.error(t)
        }
    },
    this.texImage2D = function() {
        try {
            e.texImage2D.apply(e, arguments)
        } catch(t) {
            console.error(t)
        }
    },
    this.clearColor = function(t, n, r, s) {
        i.set(t, n, r, s),
        !1 === B.equals(i) && (e.clearColor(t, n, r, s), B.copy(i))
    },
    this.clearDepth = function(t) {
        j !== t && (e.clearDepth(t), j = t)
    },
    this.clearStencil = function(t) {
        F !== t && (e.clearStencil(t), F = t)
    },
    this.scissor = function(t) { ! 1 === I.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), I.copy(t))
    },
    this.viewport = function(t) { ! 1 === q.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), q.copy(t))
    },
    this.reset = function() {
        for (var t = 0; t < o.length; t++) 1 === o[t] && (e.disableVertexAttribArray(t), o[t] = 0);
        a = {},
        f = null,
        P = void 0,
        H = {},
        L = E = b = w = l = null
    }
},
THREE.LensFlarePlugin = function(e, t) {
    var n, r, i, s, o, u, a, f, l, c, h = e.context,
    p = e.state,
    d, v, m, g, y, b;
    this.render = function(S, x, T) {
        if (0 !== t.length) {
            S = new THREE.Vector3;
            var N = T.w / T.z,
            C = .5 * T.z,
            L = .5 * T.w,
            A = 16 / T.w,
            O = new THREE.Vector2(A * N, A),
            M = new THREE.Vector3(1, 1, 0),
            _ = new THREE.Vector2(1, 1);
            if (void 0 === m) {
                var A = new Float32Array([ - 1, -1, 0, 0, 1, -1, 1, 0, 1, 1, 1, 1, -1, 1, 0, 1]),
                D = new Uint16Array([0, 1, 2, 0, 2, 3]);
                d = h.createBuffer(),
                v = h.createBuffer(),
                h.bindBuffer(h.ARRAY_BUFFER, d),
                h.bufferData(h.ARRAY_BUFFER, A, h.STATIC_DRAW),
                h.bindBuffer(h.ELEMENT_ARRAY_BUFFER, v),
                h.bufferData(h.ELEMENT_ARRAY_BUFFER, D, h.STATIC_DRAW),
                y = h.createTexture(),
                b = h.createTexture(),
                p.bindTexture(h.TEXTURE_2D, y),
                h.texImage2D(h.TEXTURE_2D, 0, h.RGB, 16, 16, 0, h.RGB, h.UNSIGNED_BYTE, null),
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE),
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE),
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.NEAREST),
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.NEAREST),
                p.bindTexture(h.TEXTURE_2D, b),
                h.texImage2D(h.TEXTURE_2D, 0, h.RGBA, 16, 16, 0, h.RGBA, h.UNSIGNED_BYTE, null),
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE),
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE),
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.NEAREST),
                h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.NEAREST);
                var A = (g = 0 < h.getParameter(h.MAX_VERTEX_TEXTURE_IMAGE_UNITS)) ? {
                    vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nuniform sampler2D occlusionMap;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\nvec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\nvVisibility =        visibility.r / 9.0;\nvVisibility *= 1.0 - visibility.g / 9.0;\nvVisibility *=       visibility.b / 9.0;\nvVisibility *= 1.0 - visibility.a / 9.0;\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                    fragmentShader: "uniform lowp int renderType;\nuniform sampler2D map;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvarying float vVisibility;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * vVisibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                }: {
                    vertexShader: "uniform lowp int renderType;\nuniform vec3 screenPosition;\nuniform vec2 scale;\nuniform float rotation;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uv;\nvec2 pos = position;\nif ( renderType == 2 ) {\npos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\npos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\n}\ngl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\n}",
                    fragmentShader: "precision mediump float;\nuniform lowp int renderType;\nuniform sampler2D map;\nuniform sampler2D occlusionMap;\nuniform float opacity;\nuniform vec3 color;\nvarying vec2 vUV;\nvoid main() {\nif ( renderType == 0 ) {\ngl_FragColor = vec4( texture2D( map, vUV ).rgb, 0.0 );\n} else if ( renderType == 1 ) {\ngl_FragColor = texture2D( map, vUV );\n} else {\nfloat visibility = texture2D( occlusionMap, vec2( 0.5, 0.1 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) ).a;\nvisibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) ).a;\nvisibility = ( 1.0 - visibility / 4.0 );\nvec4 texture = texture2D( map, vUV );\ntexture.a *= opacity * visibility;\ngl_FragColor = texture;\ngl_FragColor.rgb *= color;\n}\n}"
                },
                D = h.createProgram(),
                P = h.createShader(h.FRAGMENT_SHADER),
                H = h.createShader(h.VERTEX_SHADER),
                B = "precision " + e.getPrecision() + " float;\n";
                h.shaderSource(P, B + A.fragmentShader),
                h.shaderSource(H, B + A.vertexShader),
                h.compileShader(P),
                h.compileShader(H),
                h.attachShader(D, P),
                h.attachShader(D, H),
                h.linkProgram(D),
                m = D,
                l = h.getAttribLocation(m, "position"),
                c = h.getAttribLocation(m, "uv"),
                n = h.getUniformLocation(m, "renderType"),
                r = h.getUniformLocation(m, "map"),
                i = h.getUniformLocation(m, "occlusionMap"),
                s = h.getUniformLocation(m, "opacity"),
                o = h.getUniformLocation(m, "color"),
                u = h.getUniformLocation(m, "scale"),
                a = h.getUniformLocation(m, "rotation"),
                f = h.getUniformLocation(m, "screenPosition")
            }
            h.useProgram(m),
            p.initAttributes(),
            p.enableAttribute(l),
            p.enableAttribute(c),
            p.disableUnusedAttributes(),
            h.uniform1i(i, 0),
            h.uniform1i(r, 1),
            h.bindBuffer(h.ARRAY_BUFFER, d),
            h.vertexAttribPointer(l, 2, h.FLOAT, !1, 16, 0),
            h.vertexAttribPointer(c, 2, h.FLOAT, !1, 16, 8),
            h.bindBuffer(h.ELEMENT_ARRAY_BUFFER, v),
            p.disable(h.CULL_FACE),
            p.setDepthWrite(!1),
            D = 0;
            for (P = t.length; D < P; D++) if (A = 16 / T.w, O.set(A * N, A), H = t[D], S.set(H.matrixWorld.elements[12], H.matrixWorld.elements[13], H.matrixWorld.elements[14]), S.applyMatrix4(x.matrixWorldInverse), S.applyProjection(x.projectionMatrix), M.copy(S), _.x = M.x * C + C, _.y = M.y * L + L, g || 0 < _.x && _.x < T.z && 0 < _.y && _.y < T.w) {
                p.activeTexture(h.TEXTURE0),
                p.bindTexture(h.TEXTURE_2D, null),
                p.activeTexture(h.TEXTURE1),
                p.bindTexture(h.TEXTURE_2D, y),
                h.copyTexImage2D(h.TEXTURE_2D, 0, h.RGB, T.x + _.x - 8, T.y + _.y - 8, 16, 16, 0),
                h.uniform1i(n, 0),
                h.uniform2f(u, O.x, O.y),
                h.uniform3f(f, M.x, M.y, M.z),
                p.disable(h.BLEND),
                p.enable(h.DEPTH_TEST),
                h.drawElements(h.TRIANGLES, 6, h.UNSIGNED_SHORT, 0),
                p.activeTexture(h.TEXTURE0),
                p.bindTexture(h.TEXTURE_2D, b),
                h.copyTexImage2D(h.TEXTURE_2D, 0, h.RGBA, T.x + _.x - 8, T.y + _.y - 8, 16, 16, 0),
                h.uniform1i(n, 1),
                p.disable(h.DEPTH_TEST),
                p.activeTexture(h.TEXTURE1),
                p.bindTexture(h.TEXTURE_2D, y),
                h.drawElements(h.TRIANGLES, 6, h.UNSIGNED_SHORT, 0),
                H.positionScreen.copy(M),
                H.customUpdateCallback ? H.customUpdateCallback(H) : H.updateLensFlares(),
                h.uniform1i(n, 2),
                p.enable(h.BLEND);
                for (var B = 0,
                j = H.lensFlares.length; B < j; B++) {
                    var F = H.lensFlares[B];.001 < F.opacity && .001 < F.scale && (M.x = F.x, M.y = F.y, M.z = F.z, A = F.size * F.scale / T.w, O.x = A * N, O.y = A, h.uniform3f(f, M.x, M.y, M.z), h.uniform2f(u, O.x, O.y), h.uniform1f(a, F.rotation), h.uniform1f(s, F.opacity), h.uniform3f(o, F.color.r, F.color.g, F.color.b), p.setBlending(F.blending, F.blendEquation, F.blendSrc, F.blendDst), e.setTexture(F.texture, 1), h.drawElements(h.TRIANGLES, 6, h.UNSIGNED_SHORT, 0))
                }
            }
            p.enable(h.CULL_FACE),
            p.enable(h.DEPTH_TEST),
            p.setDepthWrite(!0),
            e.resetGLState()
        }
    }
},
THREE.SpritePlugin = function(e, t) {
    function b(e, t) {
        return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder: e.z !== t.z ? t.z - e.z: t.id - e.id
    }
    var n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g, y, w = e.context,
    E = e.state,
    S, x, T, N, C = new THREE.Vector3,
    k = new THREE.Quaternion,
    L = new THREE.Vector3;
    this.render = function(A, O) {
        if (0 !== t.length) {
            if (void 0 === T) {
                var M = new Float32Array([ - 0.5, -0.5, 0, 0, .5, -0.5, 1, 0, .5, .5, 1, 1, -0.5, .5, 0, 1]),
                _ = new Uint16Array([0, 1, 2, 0, 2, 3]);
                S = w.createBuffer(),
                x = w.createBuffer(),
                w.bindBuffer(w.ARRAY_BUFFER, S),
                w.bufferData(w.ARRAY_BUFFER, M, w.STATIC_DRAW),
                w.bindBuffer(w.ELEMENT_ARRAY_BUFFER, x),
                w.bufferData(w.ELEMENT_ARRAY_BUFFER, _, w.STATIC_DRAW);
                var M = w.createProgram(),
                _ = w.createShader(w.VERTEX_SHADER),
                P = w.createShader(w.FRAGMENT_SHADER);
                w.shaderSource(_, ["precision " + e.getPrecision() + " float;", "uniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform float rotation;\nuniform vec2 scale;\nuniform vec2 uvOffset;\nuniform vec2 uvScale;\nattribute vec2 position;\nattribute vec2 uv;\nvarying vec2 vUV;\nvoid main() {\nvUV = uvOffset + uv * uvScale;\nvec2 alignedPosition = position * scale;\nvec2 rotatedPosition;\nrotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\nrotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\nvec4 finalPosition;\nfinalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\nfinalPosition.xy += rotatedPosition;\nfinalPosition = projectionMatrix * finalPosition;\ngl_Position = finalPosition;\n}"].join("\n")),
                w.shaderSource(P, ["precision " + e.getPrecision() + " float;", "uniform vec3 color;\nuniform sampler2D map;\nuniform float opacity;\nuniform int fogType;\nuniform vec3 fogColor;\nuniform float fogDensity;\nuniform float fogNear;\nuniform float fogFar;\nuniform float alphaTest;\nvarying vec2 vUV;\nvoid main() {\nvec4 texture = texture2D( map, vUV );\nif ( texture.a < alphaTest ) discard;\ngl_FragColor = vec4( color * texture.xyz, texture.a * opacity );\nif ( fogType > 0 ) {\nfloat depth = gl_FragCoord.z / gl_FragCoord.w;\nfloat fogFactor = 0.0;\nif ( fogType == 1 ) {\nfogFactor = smoothstep( fogNear, fogFar, depth );\n} else {\nconst float LOG2 = 1.442695;\nfogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );\nfogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );\n}\ngl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );\n}\n}"].join("\n")),
                w.compileShader(_),
                w.compileShader(P),
                w.attachShader(M, _),
                w.attachShader(M, P),
                w.linkProgram(M),
                T = M,
                g = w.getAttribLocation(T, "position"),
                y = w.getAttribLocation(T, "uv"),
                n = w.getUniformLocation(T, "uvOffset"),
                r = w.getUniformLocation(T, "uvScale"),
                i = w.getUniformLocation(T, "rotation"),
                s = w.getUniformLocation(T, "scale"),
                o = w.getUniformLocation(T, "color"),
                u = w.getUniformLocation(T, "map"),
                a = w.getUniformLocation(T, "opacity"),
                f = w.getUniformLocation(T, "modelViewMatrix"),
                l = w.getUniformLocation(T, "projectionMatrix"),
                c = w.getUniformLocation(T, "fogType"),
                h = w.getUniformLocation(T, "fogDensity"),
                p = w.getUniformLocation(T, "fogNear"),
                d = w.getUniformLocation(T, "fogFar"),
                v = w.getUniformLocation(T, "fogColor"),
                m = w.getUniformLocation(T, "alphaTest"),
                M = document.createElement("canvas"),
                M.width = 8,
                M.height = 8,
                _ = M.getContext("2d"),
                _.fillStyle = "white",
                _.fillRect(0, 0, 8, 8),
                N = new THREE.Texture(M),
                N.needsUpdate = !0
            }
            w.useProgram(T),
            E.initAttributes(),
            E.enableAttribute(g),
            E.enableAttribute(y),
            E.disableUnusedAttributes(),
            E.disable(w.CULL_FACE),
            E.enable(w.BLEND),
            w.bindBuffer(w.ARRAY_BUFFER, S),
            w.vertexAttribPointer(g, 2, w.FLOAT, !1, 16, 0),
            w.vertexAttribPointer(y, 2, w.FLOAT, !1, 16, 8),
            w.bindBuffer(w.ELEMENT_ARRAY_BUFFER, x),
            w.uniformMatrix4fv(l, !1, O.projectionMatrix.elements),
            E.activeTexture(w.TEXTURE0),
            w.uniform1i(u, 0),
            _ = M = 0,
            (P = A.fog) ? (w.uniform3f(v, P.color.r, P.color.g, P.color.b), P instanceof THREE.Fog ? (w.uniform1f(p, P.near), w.uniform1f(d, P.far), w.uniform1i(c, 1), _ = M = 1) : P instanceof THREE.FogExp2 && (w.uniform1f(h, P.density), w.uniform1i(c, 2), _ = M = 2)) : (w.uniform1i(c, 0), _ = M = 0);
            for (var P = 0,
            j = t.length; P < j; P++) {
                var I = t[P];
                I.modelViewMatrix.multiplyMatrices(O.matrixWorldInverse, I.matrixWorld),
                I.z = -I.modelViewMatrix.elements[14]
            }
            t.sort(b);
            for (var R = [], P = 0, j = t.length; P < j; P++) {
                var I = t[P],
                U = I.material;
                w.uniform1f(m, U.alphaTest),
                w.uniformMatrix4fv(f, !1, I.modelViewMatrix.elements),
                I.matrixWorld.decompose(C, k, L),
                R[0] = L.x,
                R[1] = L.y,
                I = 0,
                A.fog && U.fog && (I = _),
                M !== I && (w.uniform1i(c, I), M = I),
                null !== U.map ? (w.uniform2f(n, U.map.offset.x, U.map.offset.y), w.uniform2f(r, U.map.repeat.x, U.map.repeat.y)) : (w.uniform2f(n, 0, 0), w.uniform2f(r, 1, 1)),
                w.uniform1f(a, U.opacity),
                w.uniform3f(o, U.color.r, U.color.g, U.color.b),
                w.uniform1f(i, U.rotation),
                w.uniform2fv(s, R),
                E.setBlending(U.blending, U.blendEquation, U.blendSrc, U.blendDst),
                E.setDepthTest(U.depthTest),
                E.setDepthWrite(U.depthWrite),
                U.map && U.map.image && U.map.image.width ? e.setTexture(U.map, 0) : e.setTexture(N, 0),
                w.drawElements(w.TRIANGLES, 6, w.UNSIGNED_SHORT, 0)
            }
            E.enable(w.CULL_FACE),
            e.resetGLState()
        }
    }
},
Object.defineProperties(THREE.Box2.prototype, {
    empty: {
        value: function() {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        }
    },
    isIntersectionBox: {
        value: function(e) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        }
    }
}),
Object.defineProperties(THREE.Box3.prototype, {
    empty: {
        value: function() {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."),
            this.isEmpty()
        }
    },
    isIntersectionBox: {
        value: function(e) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        }
    },
    isIntersectionSphere: {
        value: function(e) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(e)
        }
    }
}),
Object.defineProperties(THREE.Matrix3.prototype, {
    multiplyVector3: {
        value: function(e) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."),
            e.applyMatrix3(this)
        }
    },
    multiplyVector3Array: {
        value: function(e) {
            return console.warn("THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."),
            this.applyToVector3Array(e)
        }
    }
}),
Object.defineProperties(THREE.Matrix4.prototype, {
    extractPosition: {
        value: function(e) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."),
            this.copyPosition(e)
        }
    },
    setRotationFromQuaternion: {
        value: function(e) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."),
            this.makeRotationFromQuaternion(e)
        }
    },
    multiplyVector3: {
        value: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead."),
            e.applyProjection(this)
        }
    },
    multiplyVector4: {
        value: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        }
    },
    multiplyVector3Array: {
        value: function(e) {
            return console.warn("THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead."),
            this.applyToVector3Array(e)
        }
    },
    rotateAxis: {
        value: function(e) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."),
            e.transformDirection(this)
        }
    },
    crossVector: {
        value: function(e) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."),
            e.applyMatrix4(this)
        }
    },
    translate: {
        value: function(e) {
            console.error("THREE.Matrix4: .translate() has been removed.")
        }
    },
    rotateX: {
        value: function(e) {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        }
    },
    rotateY: {
        value: function(e) {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        }
    },
    rotateZ: {
        value: function(e) {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        }
    },
    rotateByAxis: {
        value: function(e, t) {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        }
    }
}),
Object.defineProperties(THREE.Plane.prototype, {
    isIntersectionLine: {
        value: function(e) {
            return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."),
            this.intersectsLine(e)
        }
    }
}),
Object.defineProperties(THREE.Quaternion.prototype, {
    multiplyVector3: {
        value: function(e) {
            return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."),
            e.applyQuaternion(this)
        }
    }
}),
Object.defineProperties(THREE.Ray.prototype, {
    isIntersectionBox: {
        value: function(e) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."),
            this.intersectsBox(e)
        }
    },
    isIntersectionPlane: {
        value: function(e) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."),
            this.intersectsPlane(e)
        }
    },
    isIntersectionSphere: {
        value: function(e) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."),
            this.intersectsSphere(e)
        }
    }
}),
Object.defineProperties(THREE.Vector3.prototype, {
    setEulerFromRotationMatrix: {
        value: function() {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        }
    },
    setEulerFromQuaternion: {
        value: function() {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        }
    },
    getPositionFromMatrix: {
        value: function(e) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."),
            this.setFromMatrixPosition(e)
        }
    },
    getScaleFromMatrix: {
        value: function(e) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."),
            this.setFromMatrixScale(e)
        }
    },
    getColumnFromMatrix: {
        value: function(e, t) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."),
            this.setFromMatrixColumn(e, t)
        }
    }
}),
THREE.Face4 = function(e, t, n, r, i, s, o) {
    return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."),
    new THREE.Face3(e, t, n, i, s, o)
},
THREE.Vertex = function(e, t, n) {
    return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."),
    new THREE.Vector3(e, t, n)
},
Object.defineProperties(THREE.Object3D.prototype, {
    eulerOrder: {
        get: function() {
            return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
            this.rotation.order
        },
        set: function(e) {
            console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."),
            this.rotation.order = e
        }
    },
    getChildByName: {
        value: function(e) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."),
            this.getObjectByName(e)
        }
    },
    renderDepth: {
        set: function(e) {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        }
    },
    translate: {
        value: function(e, t) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."),
            this.translateOnAxis(t, e)
        }
    },
    useQuaternion: {
        get: function() {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        },
        set: function(e) {
            console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
        }
    }
}),
Object.defineProperties(THREE, {
    PointCloud: {
        value: function(e, t) {
            return console.warn("THREE.PointCloud has been renamed to THREE.Points."),
            new THREE.Points(e, t)
        }
    },
    ParticleSystem: {
        value: function(e, t) {
            return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."),
            new THREE.Points(e, t)
        }
    }
}),
Object.defineProperties(THREE.Light.prototype, {
    onlyShadow: {
        set: function(e) {
            console.warn("THREE.Light: .onlyShadow has been removed.")
        }
    },
    shadowCameraFov: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."),
            this.shadow.camera.fov = e
        }
    },
    shadowCameraLeft: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."),
            this.shadow.camera.left = e
        }
    },
    shadowCameraRight: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."),
            this.shadow.camera.right = e
        }
    },
    shadowCameraTop: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."),
            this.shadow.camera.top = e
        }
    },
    shadowCameraBottom: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."),
            this.shadow.camera.bottom = e
        }
    },
    shadowCameraNear: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."),
            this.shadow.camera.near = e
        }
    },
    shadowCameraFar: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."),
            this.shadow.camera.far = e
        }
    },
    shadowCameraVisible: {
        set: function(e) {
            console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
        }
    },
    shadowBias: {
        set: function(e) {
            console.warn("THREE.Light: .shadowBias is now .shadow.bias."),
            this.shadow.bias = e
        }
    },
    shadowDarkness: {
        set: function(e) {
            console.warn("THREE.Light: .shadowDarkness has been removed.")
        }
    },
    shadowMapWidth: {
        set: function(e) {
            console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."),
            this.shadow.mapSize.width = e
        }
    },
    shadowMapHeight: {
        set: function(e) {
            console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."),
            this.shadow.mapSize.height = e
        }
    }
}),
Object.defineProperties(THREE.BufferAttribute.prototype, {
    length: {
        get: function() {
            return console.warn("THREE.BufferAttribute: .length has been deprecated. Please use .count."),
            this.array.length
        }
    }
}),
Object.defineProperties(THREE.BufferGeometry.prototype, {
    drawcalls: {
        get: function() {
            return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."),
            this.groups
        }
    },
    offsets: {
        get: function() {
            return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."),
            this.groups
        }
    },
    addIndex: {
        value: function(e) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."),
            this.setIndex(e)
        }
    },
    addDrawCall: {
        value: function(e, t, n) {
            void 0 !== n && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."),
            console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."),
            this.addGroup(e, t)
        }
    },
    clearDrawCalls: {
        value: function() {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."),
            this.clearGroups()
        }
    },
    computeTangents: {
        value: function() {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        }
    },
    computeOffsets: {
        value: function() {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }
}),
Object.defineProperties(THREE.Material.prototype, {
    wrapAround: {
        get: function() {
            console.warn("THREE." + this.type + ": .wrapAround has been removed.")
        },
        set: function(e) {
            console.warn("THREE." + this.type + ": .wrapAround has been removed.")
        }
    },
    wrapRGB: {
        get: function() {
            return console.warn("THREE." + this.type + ": .wrapRGB has been removed."),
            new THREE.Color
        }
    }
}),
Object.defineProperties(THREE, {
    PointCloudMaterial: {
        value: function(e) {
            return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."),
            new THREE.PointsMaterial(e)
        }
    },
    ParticleBasicMaterial: {
        value: function(e) {
            return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."),
            new THREE.PointsMaterial(e)
        }
    },
    ParticleSystemMaterial: {
        value: function(e) {
            return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."),
            new THREE.PointsMaterial(e)
        }
    }
}),
Object.defineProperties(THREE.MeshPhongMaterial.prototype, {
    metal: {
        get: function() {
            return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."),
            !1
        },
        set: function(e) {
            console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
        }
    }
}),
Object.defineProperties(THREE.ShaderMaterial.prototype, {
    derivatives: {
        get: function() {
            return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
            this.extensions.derivatives
        },
        set: function(e) {
            console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."),
            this.extensions.derivatives = e
        }
    }
}),
Object.defineProperties(THREE.WebGLRenderer.prototype, {
    supportsFloatTextures: {
        value: function() {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."),
            this.extensions.get("OES_texture_float")
        }
    },
    supportsHalfFloatTextures: {
        value: function() {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."),
            this.extensions.get("OES_texture_half_float")
        }
    },
    supportsStandardDerivatives: {
        value: function() {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."),
            this.extensions.get("OES_standard_derivatives")
        }
    },
    supportsCompressedTextureS3TC: {
        value: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."),
            this.extensions.get("WEBGL_compressed_texture_s3tc")
        }
    },
    supportsCompressedTexturePVRTC: {
        value: function() {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."),
            this.extensions.get("WEBGL_compressed_texture_pvrtc")
        }
    },
    supportsBlendMinMax: {
        value: function() {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."),
            this.extensions.get("EXT_blend_minmax")
        }
    },
    supportsVertexTextures: {
        value: function() {
            return this.capabilities.vertexTextures
        }
    },
    supportsInstancedArrays: {
        value: function() {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."),
            this.extensions.get("ANGLE_instanced_arrays")
        }
    },
    enableScissorTest: {
        value: function(e) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."),
            this.setScissorTest(e)
        }
    },
    initMaterial: {
        value: function() {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }
    },
    addPrePlugin: {
        value: function() {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        }
    },
    addPostPlugin: {
        value: function() {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }
    },
    updateShadowMap: {
        value: function() {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }
    },
    shadowMapEnabled: {
        get: function() {
            return this.shadowMap.enabled
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."),
            this.shadowMap.enabled = e
        }
    },
    shadowMapType: {
        get: function() {
            return this.shadowMap.type
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."),
            this.shadowMap.type = e
        }
    },
    shadowMapCullFace: {
        get: function() {
            return this.shadowMap.cullFace
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace."),
            this.shadowMap.cullFace = e
        }
    }
}),
Object.defineProperties(THREE.WebGLRenderTarget.prototype, {
    wrapS: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
            this.texture.wrapS
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."),
            this.texture.wrapS = e
        }
    },
    wrapT: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
            this.texture.wrapT
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."),
            this.texture.wrapT = e
        }
    },
    magFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
            this.texture.magFilter
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."),
            this.texture.magFilter = e
        }
    },
    minFilter: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
            this.texture.minFilter
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."),
            this.texture.minFilter = e
        }
    },
    anisotropy: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
            this.texture.anisotropy
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."),
            this.texture.anisotropy = e
        }
    },
    offset: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
            this.texture.offset
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."),
            this.texture.offset = e
        }
    },
    repeat: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
            this.texture.repeat
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."),
            this.texture.repeat = e
        }
    },
    format: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
            this.texture.format
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."),
            this.texture.format = e
        }
    },
    type: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
            this.texture.type
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."),
            this.texture.type = e
        }
    },
    generateMipmaps: {
        get: function() {
            return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
            this.texture.generateMipmaps
        },
        set: function(e) {
            console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."),
            this.texture.generateMipmaps = e
        }
    }
}),
THREE.GeometryUtils = {
    merge: function(e, t, n) {
        console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.");
        var r;
        t instanceof THREE.Mesh && (t.matrixAutoUpdate && t.updateMatrix(), r = t.matrix, t = t.geometry),
        e.merge(t, r, n)
    },
    center: function(e) {
        return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."),
        e.center()
    }
},
THREE.ImageUtils = {
    crossOrigin: void 0,
    loadTexture: function(e, t, n, r) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var i = new THREE.TextureLoader;
        return i.setCrossOrigin(this.crossOrigin),
        e = i.load(e, n, void 0, r),
        t && (e.mapping = t),
        e
    },
    loadTextureCube: function(e, t, n, r) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var i = new THREE.CubeTextureLoader;
        return i.setCrossOrigin(this.crossOrigin),
        e = i.load(e, n, void 0, r),
        t && (e.mapping = t),
        e
    },
    loadCompressedTexture: function() {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    },
    loadCompressedTextureCube: function() {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }
},
THREE.Projector = function() {
    console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."),
    this.projectVector = function(e, t) {
        console.warn("THREE.Projector: .projectVector() is now vector.project()."),
        e.project(t)
    },
    this.unprojectVector = function(e, t) {
        console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),
        e.unproject(t)
    },
    this.pickingRay = function(e, t) {
        console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
    }
},
THREE.CanvasRenderer = function() {
    console.error("THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js"),
    this.domElement = document.createElement("canvas"),
    this.clear = function() {},
    this.render = function() {},
    this.setClearColor = function() {},
    this.setSize = function() {}
},
THREE.MeshFaceMaterial = THREE.MultiMaterial,
THREE.CurveUtils = {
    tangentQuadraticBezier: function(e, t, n, r) {
        return 2 * (1 - e) * (n - t) + 2 * e * (r - n)
    },
    tangentCubicBezier: function(e, t, n, r, i) {
        return - 3 * t * (1 - e) * (1 - e) + 3 * n * (1 - e) * (1 - e) - 6 * e * n * (1 - e) + 6 * e * r * (1 - e) - 3 * e * e * r + 3 * e * e * i
    },
    tangentSpline: function(e, t, n, r, i) {
        return 6 * e * e - 6 * e + (3 * e * e - 4 * e + 1) + ( - 6 * e * e + 6 * e) + (3 * e * e - 2 * e)
    },
    interpolate: function(e, t, n, r, i) {
        e = .5 * (n - e),
        r = .5 * (r - t);
        var s = i * i;
        return (2 * t - 2 * n + e + r) * i * s + ( - 3 * t + 3 * n - 2 * e - r) * s + e * i + t
    }
},
THREE.SceneUtils = {
    createMultiMaterialObject: function(e, t) {
        for (var n = new THREE.Group,
        r = 0,
        i = t.length; r < i; r++) n.add(new THREE.Mesh(e, t[r]));
        return n
    },
    detach: function(e, t, n) {
        e.applyMatrix(t.matrixWorld),
        t.remove(e),
        n.add(e)
    },
    attach: function(e, t, n) {
        var r = new THREE.Matrix4;
        r.getInverse(n.matrixWorld),
        e.applyMatrix(r),
        t.remove(e),
        n.add(e)
    }
},
THREE.ShapeUtils = {
    area: function(e) {
        for (var t = e.length,
        n = 0,
        r = t - 1,
        i = 0; i < t; r = i++) n += e[r].x * e[i].y - e[i].x * e[r].y;
        return.5 * n
    },
    triangulate: function() {
        return function(e, t) {
            var n = e.length;
            if (3 > n) return null;
            var r = [],
            i = [],
            s = [],
            o,
            u,
            a;
            if (0 < THREE.ShapeUtils.area(e)) for (u = 0; u < n; u++) i[u] = u;
            else for (u = 0; u < n; u++) i[u] = n - 1 - u;
            var f = 2 * n;
            for (u = n - 1; 2 < n;) {
                if (0 >= f--) {
                    console.warn("THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()");
                    break
                }
                o = u,
                n <= o && (o = 0),
                u = o + 1,
                n <= u && (u = 0),
                a = u + 1,
                n <= a && (a = 0);
                var l;
                e: {
                    var c = l = void 0,
                    h = void 0,
                    p = void 0,
                    d = void 0,
                    v = void 0,
                    m = void 0,
                    g = void 0,
                    y = void 0,
                    c = e[i[o]].x,
                    h = e[i[o]].y,
                    p = e[i[u]].x,
                    d = e[i[u]].y,
                    v = e[i[a]].x,
                    m = e[i[a]].y;
                    if (Number.EPSILON > (p - c) * (m - h) - (d - h) * (v - c)) l = !1;
                    else {
                        var b = void 0,
                        w = void 0,
                        E = void 0,
                        S = void 0,
                        x = void 0,
                        T = void 0,
                        N = void 0,
                        C = void 0,
                        k = void 0,
                        L = void 0,
                        k = C = N = y = g = void 0,
                        b = v - p,
                        w = m - d,
                        E = c - v,
                        S = h - m,
                        x = p - c,
                        T = d - h;
                        for (l = 0; l < n; l++) if (g = e[i[l]].x, y = e[i[l]].y, !(g === c && y === h || g === p && y === d || g === v && y === m) && (N = g - c, C = y - h, k = g - p, L = y - d, g -= v, y -= m, k = b * L - w * k, N = x * C - T * N, C = E * y - S * g, k >= -Number.EPSILON && C >= -Number.EPSILON && N >= -Number.EPSILON)) {
                            l = !1;
                            break e
                        }
                        l = !0
                    }
                }
                if (l) {
                    r.push([e[i[o]], e[i[u]], e[i[a]]]),
                    s.push([i[o], i[u], i[a]]),
                    o = u;
                    for (a = u + 1; a < n; o++, a++) i[o] = i[a];
                    n--,
                    f = 2 * n
                }
            }
            return t ? s: r
        }
    } (),
    triangulateShape: function(e, t) {
        function n(e, t, n) {
            return e.x !== t.x ? e.x < t.x ? e.x <= n.x && n.x <= t.x: t.x <= n.x && n.x <= e.x: e.y < t.y ? e.y <= n.y && n.y <= t.y: t.y <= n.y && n.y <= e.y
        }
        function r(e, t, r, i, s) {
            var o = t.x - e.x,
            u = t.y - e.y,
            a = i.x - r.x,
            f = i.y - r.y,
            l = e.x - r.x,
            c = e.y - r.y,
            h = u * a - o * f,
            p = u * l - o * c;
            if (Math.abs(h) > Number.EPSILON) {
                if (0 < h) {
                    if (0 > p || p > h) return [];
                    a = f * l - a * c;
                    if (0 > a || a > h) return []
                } else {
                    if (0 < p || p < h) return [];
                    a = f * l - a * c;
                    if (0 < a || a < h) return []
                }
                return 0 === a ? !s || 0 !== p && p !== h ? [e] : [] : a === h ? !s || 0 !== p && p !== h ? [t] : [] : 0 === p ? [r] : p === h ? [i] : (s = a / h, [{
                    x: e.x + s * o,
                    y: e.y + s * u
                }])
            }
            return 0 !== p || f * l !== a * c ? [] : (u = 0 === o && 0 === u, a = 0 === a && 0 === f, u && a ? e.x !== r.x || e.y !== r.y ? [] : [e] : u ? n(r, i, e) ? [e] : [] : a ? n(e, t, r) ? [r] : [] : (0 !== o ? (e.x < t.x ? (o = e, a = e.x, u = t, e = t.x) : (o = t, a = t.x, u = e, e = e.x), r.x < i.x ? (t = r, h = r.x, f = i, r = i.x) : (t = i, h = i.x, f = r, r = r.x)) : (e.y < t.y ? (o = e, a = e.y, u = t, e = t.y) : (o = t, a = t.y, u = e, e = e.y), r.y < i.y ? (t = r, h = r.y, f = i, r = i.y) : (t = i, h = i.y, f = r, r = r.y)), a <= h ? e < h ? [] : e === h ? s ? [] : [t] : e <= r ? [t, u] : [t, f] : a > r ? [] : a === r ? s ? [] : [o] : e <= r ? [o, u] : [o, f]))
        }
        function i(e, t, n, r) {
            var i = t.x - e.x,
            s = t.y - e.y;
            t = n.x - e.x,
            n = n.y - e.y;
            var o = r.x - e.x;
            return r = r.y - e.y,
            e = i * n - s * t,
            i = i * r - s * o,
            Math.abs(e) > Number.EPSILON ? (t = o * n - r * t, 0 < e ? 0 <= i && 0 <= t: 0 <= i || 0 <= t) : 0 < i
        }
        var s, o, u, a, f, l = {};
        u = e.concat(),
        s = 0;
        for (o = t.length; s < o; s++) Array.prototype.push.apply(u, t[s]);
        s = 0;
        for (o = u.length; s < o; s++) f = u[s].x + ":" + u[s].y,
        void 0 !== l[f] && console.warn("THREE.Shape: Duplicate point", f),
        l[f] = s;
        s = function(e, t) {
            function n(e, t) {
                var n = u.length - 1,
                r = e - 1;
                0 > r && (r = n);
                var s = e + 1;
                return s > n && (s = 0),
                n = i(u[e], u[r], u[s], a[t]),
                n ? (n = a.length - 1, r = t - 1, 0 > r && (r = n), s = t + 1, s > n && (s = 0), (n = i(a[t], a[r], a[s], u[e])) ? !0 : !1) : !1
            }
            function s(e, t) {
                var n, i;
                for (n = 0; n < u.length; n++) if (i = n + 1, i %= u.length, i = r(e, t, u[n], u[i], !0), 0 < i.length) return ! 0;
                return ! 1
            }
            function o(e, n) {
                var i, s, o, u;
                for (i = 0; i < f.length; i++) for (s = t[f[i]], o = 0; o < s.length; o++) if (u = o + 1, u %= s.length, u = r(e, n, s[o], s[u], !0), 0 < u.length) return ! 0;
                return ! 1
            }
            var u = e.concat(),
            a,
            f = [],
            l,
            c,
            h,
            p,
            v,
            m = [],
            g,
            y,
            b,
            w = 0;
            for (l = t.length; w < l; w++) f.push(w);
            g = 0;
            for (var E = 2 * f.length; 0 < f.length;) {
                E--;
                if (0 > E) {
                    console.log("Infinite Loop! Holes left:" + f.length + ", Probably Hole outside Shape!");
                    break
                }
                for (c = g; c < u.length; c++) {
                    h = u[c],
                    l = -1;
                    for (w = 0; w < f.length; w++) if (p = f[w], v = h.x + ":" + h.y + ":" + p, void 0 === m[v]) {
                        a = t[p];
                        for (y = 0; y < a.length; y++) if (p = a[y], n(c, y) && !s(h, p) && !o(h, p)) {
                            l = y,
                            f.splice(w, 1),
                            g = u.slice(0, c + 1),
                            p = u.slice(c),
                            y = a.slice(l),
                            b = a.slice(0, l + 1),
                            u = g.concat(y).concat(b).concat(p),
                            g = c;
                            break
                        }
                        if (0 <= l) break;
                        m[v] = !0
                    }
                    if (0 <= l) break
                }
            }
            return u
        } (e, t);
        var c = THREE.ShapeUtils.triangulate(s, !1);
        s = 0;
        for (o = c.length; s < o; s++) for (a = c[s], u = 0; 3 > u; u++) f = a[u].x + ":" + a[u].y,
        f = l[f],
        void 0 !== f && (a[u] = f);
        return c.concat()
    },
    isClockWise: function(e) {
        return 0 > THREE.ShapeUtils.area(e)
    },
    b2: function() {
        return function(e, t, n, r) {
            var i = 1 - e;
            return i * i * t + 2 * (1 - e) * e * n + e * e * r
        }
    } (),
    b3: function() {
        return function(e, t, n, r, i) {
            var s = 1 - e,
            o = 1 - e;
            return s * s * s * t + 3 * o * o * e * n + 3 * (1 - e) * e * e * r + e * e * e * i
        }
    } ()
},
THREE.Curve = function() {},
THREE.Curve.prototype = {
    constructor: THREE.Curve,
    getPoint: function(e) {
        return console.warn("THREE.Curve: Warning, getPoint() not implemented!"),
        null
    },
    getPointAt: function(e) {
        return e = this.getUtoTmapping(e),
        this.getPoint(e)
    },
    getPoints: function(e) {
        e || (e = 5);
        var t, n = [];
        for (t = 0; t <= e; t++) n.push(this.getPoint(t / e));
        return n
    },
    getSpacedPoints: function(e) {
        e || (e = 5);
        var t, n = [];
        for (t = 0; t <= e; t++) n.push(this.getPointAt(t / e));
        return n
    },
    getLength: function() {
        var e = this.getLengths();
        return e[e.length - 1]
    },
    getLengths: function(e) {
        e || (e = this.__arcLengthDivisions ? this.__arcLengthDivisions: 200);
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        var t = [],
        n,
        r = this.getPoint(0),
        i,
        s = 0;
        t.push(0);
        for (i = 1; i <= e; i++) n = this.getPoint(i / e),
        s += n.distanceTo(r),
        t.push(s),
        r = n;
        return this.cacheArcLengths = t
    },
    updateArcLengths: function() {
        this.needsUpdate = !0,
        this.getLengths()
    },
    getUtoTmapping: function(e, t) {
        var n = this.getLengths(),
        r = 0,
        i = n.length,
        s;
        s = t ? t: e * n[i - 1];
        for (var o = 0,
        u = i - 1,
        a; o <= u;) if (r = Math.floor(o + (u - o) / 2), a = n[r] - s, 0 > a) o = r + 1;
        else {
            if (! (0 < a)) {
                u = r;
                break
            }
            u = r - 1
        }
        return r = u,
        n[r] === s ? r / (i - 1) : (o = n[r], n = (r + (s - o) / (n[r + 1] - o)) / (i - 1))
    },
    getTangent: function(e) {
        var t = e - 1e-4;
        return e += 1e-4,
        0 > t && (t = 0),
        1 < e && (e = 1),
        t = this.getPoint(t),
        this.getPoint(e).clone().sub(t).normalize()
    },
    getTangentAt: function(e) {
        return e = this.getUtoTmapping(e),
        this.getTangent(e)
    }
},
THREE.Curve.create = function(e, t) {
    return e.prototype = Object.create(THREE.Curve.prototype),
    e.prototype.constructor = e,
    e.prototype.getPoint = t,
    e
},
THREE.CurvePath = function() {
    this.curves = [],
    this.autoClose = !1
},
THREE.CurvePath.prototype = Object.create(THREE.Curve.prototype),
THREE.CurvePath.prototype.constructor = THREE.CurvePath,
THREE.CurvePath.prototype.add = function(e) {
    this.curves.push(e)
},
THREE.CurvePath.prototype.closePath = function() {
    var e = this.curves[0].getPoint(0),
    t = this.curves[this.curves.length - 1].getPoint(1);
    e.equals(t) || this.curves.push(new THREE.LineCurve(t, e))
},
THREE.CurvePath.prototype.getPoint = function(e) {
    for (var t = e * this.getLength(), n = this.getCurveLengths(), r = 0; r < n.length;) {
        if (n[r] >= t) return e = this.curves[r],
        t = 1 - (n[r] - t) / e.getLength(),
        e.getPointAt(t);
        r++
    }
    return null
},
THREE.CurvePath.prototype.getLength = function() {
    var e = this.getCurveLengths();
    return e[e.length - 1]
},
THREE.CurvePath.prototype.getCurveLengths = function() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
    for (var e = [], t = 0, n = 0, r = this.curves.length; n < r; n++) t += this.curves[n].getLength(),
    e.push(t);
    return this.cacheLengths = e
},
THREE.CurvePath.prototype.createPointsGeometry = function(e) {
    return e = this.getPoints(e),
    this.createGeometry(e)
},
THREE.CurvePath.prototype.createSpacedPointsGeometry = function(e) {
    return e = this.getSpacedPoints(e),
    this.createGeometry(e)
},
THREE.CurvePath.prototype.createGeometry = function(e) {
    for (var t = new THREE.Geometry,
    n = 0,
    r = e.length; n < r; n++) {
        var i = e[n];
        t.vertices.push(new THREE.Vector3(i.x, i.y, i.z || 0))
    }
    return t
},
THREE.Font = function(e) {
    this.data = e
},
THREE.Font.prototype = {
    constructor: THREE.Font,
    generateShapes: function(e, t, n) {
        void 0 === t && (t = 100),
        void 0 === n && (n = 4);
        var r = this.data;
        e = String(e).split("");
        var i = t / r.resolution,
        s = 0;
        t = [];
        for (var o = 0; o < e.length; o++) {
            var u;
            u = i;
            var a = s,
            f = r.glyphs[e[o]] || r.glyphs["?"];
            if (f) {
                var l = new THREE.Path,
                c = [],
                h = THREE.ShapeUtils.b2,
                p = THREE.ShapeUtils.b3,
                d = void 0,
                v = void 0,
                m = v = d = void 0,
                g = void 0,
                y = void 0,
                b = void 0,
                w = void 0,
                E = void 0,
                g = void 0;
                if (f.o) for (var S = f._cachedOutline || (f._cachedOutline = f.o.split(" ")), x = 0, T = S.length; x < T;) switch (S[x++]) {
                case "m":
                    d = S[x++] * u + a,
                    v = S[x++] * u,
                    l.moveTo(d, v);
                    break;
                case "l":
                    d = S[x++] * u + a,
                    v = S[x++] * u,
                    l.lineTo(d, v);
                    break;
                case "q":
                    d = S[x++] * u + a,
                    v = S[x++] * u,
                    y = S[x++] * u + a,
                    b = S[x++] * u,
                    l.quadraticCurveTo(y, b, d, v);
                    if (g = c[c.length - 1]) for (var m = g.x,
                    g = g.y,
                    N = 1; N <= n; N++) {
                        var C = N / n;
                        h(C, m, y, d),
                        h(C, g, b, v)
                    }
                    break;
                case "b":
                    if (d = S[x++] * u + a, v = S[x++] * u, y = S[x++] * u + a, b = S[x++] * u, w = S[x++] * u + a, E = S[x++] * u, l.bezierCurveTo(y, b, w, E, d, v), g = c[c.length - 1]) for (m = g.x, g = g.y, N = 1; N <= n; N++) C = N / n,
                    p(C, m, y, w, d),
                    p(C, g, b, E, v)
                }
                u = {
                    offset: f.ha * u,
                    path: l
                }
            } else u = void 0;
            s += u.offset,
            t.push(u.path)
        }
        n = [],
        r = 0;
        for (e = t.length; r < e; r++) Array.prototype.push.apply(n, t[r].toShapes());
        return n
    }
},
THREE.Path = function(e) {
    THREE.CurvePath.call(this),
    this.actions = [],
    e && this.fromPoints(e)
},
THREE.Path.prototype = Object.create(THREE.CurvePath.prototype),
THREE.Path.prototype.constructor = THREE.Path,
THREE.Path.prototype.fromPoints = function(e) {
    this.moveTo(e[0].x, e[0].y);
    for (var t = 1,
    n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y)
},
THREE.Path.prototype.moveTo = function(e, t) {
    this.actions.push({
        action: "moveTo",
        args: [e, t]
    })
},
THREE.Path.prototype.lineTo = function(e, t) {
    var n = this.actions[this.actions.length - 1].args,
    n = new THREE.LineCurve(new THREE.Vector2(n[n.length - 2], n[n.length - 1]), new THREE.Vector2(e, t));
    this.curves.push(n),
    this.actions.push({
        action: "lineTo",
        args: [e, t]
    })
},
THREE.Path.prototype.quadraticCurveTo = function(e, t, n, r) {
    var i = this.actions[this.actions.length - 1].args,
    i = new THREE.QuadraticBezierCurve(new THREE.Vector2(i[i.length - 2], i[i.length - 1]), new THREE.Vector2(e, t), new THREE.Vector2(n, r));
    this.curves.push(i),
    this.actions.push({
        action: "quadraticCurveTo",
        args: [e, t, n, r]
    })
},
THREE.Path.prototype.bezierCurveTo = function(e, t, n, r, i, s) {
    var o = this.actions[this.actions.length - 1].args,
    o = new THREE.CubicBezierCurve(new THREE.Vector2(o[o.length - 2], o[o.length - 1]), new THREE.Vector2(e, t), new THREE.Vector2(n, r), new THREE.Vector2(i, s));
    this.curves.push(o),
    this.actions.push({
        action: "bezierCurveTo",
        args: [e, t, n, r, i, s]
    })
},
THREE.Path.prototype.splineThru = function(e) {
    var t = Array.prototype.slice.call(arguments),
    n = this.actions[this.actions.length - 1].args,
    n = [new THREE.Vector2(n[n.length - 2], n[n.length - 1])];
    Array.prototype.push.apply(n, e),
    n = new THREE.SplineCurve(n),
    this.curves.push(n),
    this.actions.push({
        action: "splineThru",
        args: t
    })
},
THREE.Path.prototype.arc = function(e, t, n, r, i, s) {
    var o = this.actions[this.actions.length - 1].args;
    this.absarc(e + o[o.length - 2], t + o[o.length - 1], n, r, i, s)
},
THREE.Path.prototype.absarc = function(e, t, n, r, i, s) {
    this.absellipse(e, t, n, n, r, i, s)
},
THREE.Path.prototype.ellipse = function(e, t, n, r, i, s, o, u) {
    var a = this.actions[this.actions.length - 1].args;
    this.absellipse(e + a[a.length - 2], t + a[a.length - 1], n, r, i, s, o, u)
},
THREE.Path.prototype.absellipse = function(e, t, n, r, i, s, o, u) {
    var a = [e, t, n, r, i, s, o, u || 0];
    e = new THREE.EllipseCurve(e, t, n, r, i, s, o, u),
    this.curves.push(e),
    e = e.getPoint(1),
    a.push(e.x),
    a.push(e.y),
    this.actions.push({
        action: "ellipse",
        args: a
    })
},
THREE.Path.prototype.getSpacedPoints = function(e) {
    e || (e = 40);
    for (var t = [], n = 0; n < e; n++) t.push(this.getPoint(n / e));
    return this.autoClose && t.push(t[0]),
    t
},
THREE.Path.prototype.getPoints = function(e) {
    e = e || 12;
    for (var t = THREE.ShapeUtils.b2,
    n = THREE.ShapeUtils.b3,
    r = [], i, s, o, u, a, f, l, c, h, p, d = 0, v = this.actions.length; d < v; d++) {
        h = this.actions[d];
        var m = h.args;
        switch (h.action) {
        case "moveTo":
            r.push(new THREE.Vector2(m[0], m[1]));
            break;
        case "lineTo":
            r.push(new THREE.Vector2(m[0], m[1]));
            break;
        case "quadraticCurveTo":
            i = m[2],
            s = m[3],
            a = m[0],
            f = m[1],
            0 < r.length ? (h = r[r.length - 1], l = h.x, c = h.y) : (h = this.actions[d - 1].args, l = h[h.length - 2], c = h[h.length - 1]);
            for (m = 1; m <= e; m++) p = m / e,
            h = t(p, l, a, i),
            p = t(p, c, f, s),
            r.push(new THREE.Vector2(h, p));
            break;
        case "bezierCurveTo":
            i = m[4],
            s = m[5],
            a = m[0],
            f = m[1],
            o = m[2],
            u = m[3],
            0 < r.length ? (h = r[r.length - 1], l = h.x, c = h.y) : (h = this.actions[d - 1].args, l = h[h.length - 2], c = h[h.length - 1]);
            for (m = 1; m <= e; m++) p = m / e,
            h = n(p, l, a, o, i),
            p = n(p, c, f, u, s),
            r.push(new THREE.Vector2(h, p));
            break;
        case "splineThru":
            h = this.actions[d - 1].args,
            p = [new THREE.Vector2(h[h.length - 2], h[h.length - 1])],
            h = e * m[0].length,
            p = p.concat(m[0]),
            p = new THREE.SplineCurve(p);
            for (m = 1; m <= h; m++) r.push(p.getPointAt(m / h));
            break;
        case "arc":
            i = m[0],
            s = m[1],
            f = m[2],
            o = m[3],
            h = m[4],
            a = !!m[5],
            l = h - o,
            c = 2 * e;
            for (m = 1; m <= c; m++) p = m / c,
            a || (p = 1 - p),
            p = o + p * l,
            h = i + f * Math.cos(p),
            p = s + f * Math.sin(p),
            r.push(new THREE.Vector2(h, p));
            break;
        case "ellipse":
            i = m[0],
            s = m[1],
            f = m[2],
            u = m[3],
            o = m[4],
            h = m[5],
            a = !!m[6];
            var g = m[7];
            l = h - o,
            c = 2 * e;
            var y, b;
            0 !== g && (y = Math.cos(g), b = Math.sin(g));
            for (m = 1; m <= c; m++) {
                p = m / c,
                a || (p = 1 - p),
                p = o + p * l,
                h = i + f * Math.cos(p),
                p = s + u * Math.sin(p);
                if (0 !== g) {
                    var w = h;
                    h = (w - i) * y - (p - s) * b + i,
                    p = (w - i) * b + (p - s) * y + s
                }
                r.push(new THREE.Vector2(h, p))
            }
        }
    }
    return e = r[r.length - 1],
    Math.abs(e.x - r[0].x) < Number.EPSILON && Math.abs(e.y - r[0].y) < Number.EPSILON && r.splice(r.length - 1, 1),
    this.autoClose && r.push(r[0]),
    r
},
THREE.Path.prototype.toShapes = function(e, t) {
    function n(e) {
        for (var t = [], n = 0, r = e.length; n < r; n++) {
            var i = e[n],
            s = new THREE.Shape;
            s.actions = i.actions,
            s.curves = i.curves,
            t.push(s)
        }
        return t
    }
    function r(e, t) {
        for (var n = t.length,
        r = !1,
        i = n - 1,
        s = 0; s < n; i = s++) {
            var o = t[i],
            u = t[s],
            a = u.x - o.x,
            f = u.y - o.y;
            if (Math.abs(f) > Number.EPSILON) {
                if (0 > f && (o = t[s], a = -a, u = t[i], f = -f), !(e.y < o.y || e.y > u.y)) if (e.y === o.y) {
                    if (e.x === o.x) return ! 0
                } else {
                    i = f * (e.x - o.x) - a * (e.y - o.y);
                    if (0 === i) return ! 0;
                    0 > i || (r = !r)
                }
            } else if (e.y === o.y && (u.x <= e.x && e.x <= o.x || o.x <= e.x && e.x <= u.x)) return ! 0
        }
        return r
    }
    var i = THREE.ShapeUtils.isClockWise,
    s = function(e) {
        for (var t = [], n = new THREE.Path, r = 0, i = e.length; r < i; r++) {
            var s = e[r],
            o = s.args,
            s = s.action;
            "moveTo" === s && 0 !== n.actions.length && (t.push(n), n = new THREE.Path),
            n[s].apply(n, o)
        }
        return 0 !== n.actions.length && t.push(n),
        t
    } (this.actions);
    if (0 === s.length) return [];
    if (!0 === t) return n(s);
    var o, u, a, f = [];
    if (1 === s.length) return u = s[0],
    a = new THREE.Shape,
    a.actions = u.actions,
    a.curves = u.curves,
    f.push(a),
    f;
    var l = !i(s[0].getPoints()),
    l = e ? !l: l;
    a = [];
    var c = [],
    h = [],
    p = 0,
    d;
    c[p] = void 0,
    h[p] = [];
    for (var v = 0,
    m = s.length; v < m; v++) u = s[v],
    d = u.getPoints(),
    o = i(d),
    (o = e ? !o: o) ? (!l && c[p] && p++, c[p] = {
        s: new THREE.Shape,
        p: d
    },
    c[p].s.actions = u.actions, c[p].s.curves = u.curves, l && p++, h[p] = []) : h[p].push({
        h: u,
        p: d[0]
    });
    if (!c[0]) return n(s);
    if (1 < c.length) {
        v = !1,
        u = [],
        i = 0;
        for (s = c.length; i < s; i++) a[i] = [];
        i = 0;
        for (s = c.length; i < s; i++) for (o = h[i], l = 0; l < o.length; l++) {
            p = o[l],
            d = !0;
            for (m = 0; m < c.length; m++) r(p.p, c[m].p) && (i !== m && u.push({
                froms: i,
                tos: m,
                hole: l
            }), d ? (d = !1, a[m].push(p)) : v = !0);
            d && a[i].push(p)
        }
        0 < u.length && (v || (h = a))
    }
    v = 0;
    for (i = c.length; v < i; v++) for (a = c[v].s, f.push(a), u = h[v], s = 0, o = u.length; s < o; s++) a.holes.push(u[s].h);
    return f
},
THREE.Shape = function() {
    THREE.Path.apply(this, arguments),
    this.holes = []
},
THREE.Shape.prototype = Object.create(THREE.Path.prototype),
THREE.Shape.prototype.constructor = THREE.Shape,
THREE.Shape.prototype.extrude = function(e) {
    return new THREE.ExtrudeGeometry(this, e)
},
THREE.Shape.prototype.makeGeometry = function(e) {
    return new THREE.ShapeGeometry(this, e)
},
THREE.Shape.prototype.getPointsHoles = function(e) {
    for (var t = [], n = 0, r = this.holes.length; n < r; n++) t[n] = this.holes[n].getPoints(e);
    return t
},
THREE.Shape.prototype.extractAllPoints = function(e) {
    return {
        shape: this.getPoints(e),
        holes: this.getPointsHoles(e)
    }
},
THREE.Shape.prototype.extractPoints = function(e) {
    return this.extractAllPoints(e)
},
THREE.LineCurve = function(e, t) {
    this.v1 = e,
    this.v2 = t
},
THREE.LineCurve.prototype = Object.create(THREE.Curve.prototype),
THREE.LineCurve.prototype.constructor = THREE.LineCurve,
THREE.LineCurve.prototype.getPoint = function(e) {
    var t = this.v2.clone().sub(this.v1);
    return t.multiplyScalar(e).add(this.v1),
    t
},
THREE.LineCurve.prototype.getPointAt = function(e) {
    return this.getPoint(e)
},
THREE.LineCurve.prototype.getTangent = function(e) {
    return this.v2.clone().sub(this.v1).normalize()
},
THREE.QuadraticBezierCurve = function(e, t, n) {
    this.v0 = e,
    this.v1 = t,
    this.v2 = n
},
THREE.QuadraticBezierCurve.prototype = Object.create(THREE.Curve.prototype),
THREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve,
THREE.QuadraticBezierCurve.prototype.getPoint = function(e) {
    var t = THREE.ShapeUtils.b2;
    return new THREE.Vector2(t(e, this.v0.x, this.v1.x, this.v2.x), t(e, this.v0.y, this.v1.y, this.v2.y))
},
THREE.QuadraticBezierCurve.prototype.getTangent = function(e) {
    var t = THREE.CurveUtils.tangentQuadraticBezier;
    return (new THREE.Vector2(t(e, this.v0.x, this.v1.x, this.v2.x), t(e, this.v0.y, this.v1.y, this.v2.y))).normalize()
},
THREE.CubicBezierCurve = function(e, t, n, r) {
    this.v0 = e,
    this.v1 = t,
    this.v2 = n,
    this.v3 = r
},
THREE.CubicBezierCurve.prototype = Object.create(THREE.Curve.prototype),
THREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve,
THREE.CubicBezierCurve.prototype.getPoint = function(e) {
    var t = THREE.ShapeUtils.b3;
    return new THREE.Vector2(t(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), t(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y))
},
THREE.CubicBezierCurve.prototype.getTangent = function(e) {
    var t = THREE.CurveUtils.tangentCubicBezier;
    return (new THREE.Vector2(t(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), t(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y))).normalize()
},
THREE.SplineCurve = function(e) {
    this.points = void 0 == e ? [] : e
},
THREE.SplineCurve.prototype = Object.create(THREE.Curve.prototype),
THREE.SplineCurve.prototype.constructor = THREE.SplineCurve,
THREE.SplineCurve.prototype.getPoint = function(e) {
    var t = this.points;
    e *= t.length - 1;
    var n = Math.floor(e);
    e -= n;
    var r = t[0 === n ? n: n - 1],
    i = t[n],
    s = t[n > t.length - 2 ? t.length - 1 : n + 1],
    t = t[n > t.length - 3 ? t.length - 1 : n + 2],
    n = THREE.CurveUtils.interpolate;
    return new THREE.Vector2(n(r.x, i.x, s.x, t.x, e), n(r.y, i.y, s.y, t.y, e))
},
THREE.EllipseCurve = function(e, t, n, r, i, s, o, u) {
    this.aX = e,
    this.aY = t,
    this.xRadius = n,
    this.yRadius = r,
    this.aStartAngle = i,
    this.aEndAngle = s,
    this.aClockwise = o,
    this.aRotation = u || 0
},
THREE.EllipseCurve.prototype = Object.create(THREE.Curve.prototype),
THREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve,
THREE.EllipseCurve.prototype.getPoint = function(e) {
    var t = this.aEndAngle - this.aStartAngle;
    0 > t && (t += 2 * Math.PI),
    t > 2 * Math.PI && (t -= 2 * Math.PI),
    t = !0 === this.aClockwise ? this.aEndAngle + (1 - e) * (2 * Math.PI - t) : this.aStartAngle + e * t,
    e = this.aX + this.xRadius * Math.cos(t);
    var n = this.aY + this.yRadius * Math.sin(t);
    if (0 !== this.aRotation) {
        var t = Math.cos(this.aRotation),
        r = Math.sin(this.aRotation),
        i = e;
        e = (i - this.aX) * t - (n - this.aY) * r + this.aX,
        n = (i - this.aX) * r + (n - this.aY) * t + this.aY
    }
    return new THREE.Vector2(e, n)
},
THREE.ArcCurve = function(e, t, n, r, i, s) {
    THREE.EllipseCurve.call(this, e, t, n, n, r, i, s)
},
THREE.ArcCurve.prototype = Object.create(THREE.EllipseCurve.prototype),
THREE.ArcCurve.prototype.constructor = THREE.ArcCurve,
THREE.LineCurve3 = THREE.Curve.create(function(e, t) {
    this.v1 = e,
    this.v2 = t
},
function(e) {
    var t = new THREE.Vector3;
    return t.subVectors(this.v2, this.v1),
    t.multiplyScalar(e),
    t.add(this.v1),
    t
}),
THREE.QuadraticBezierCurve3 = THREE.Curve.create(function(e, t, n) {
    this.v0 = e,
    this.v1 = t,
    this.v2 = n
},
function(e) {
    var t = THREE.ShapeUtils.b2;
    return new THREE.Vector3(t(e, this.v0.x, this.v1.x, this.v2.x), t(e, this.v0.y, this.v1.y, this.v2.y), t(e, this.v0.z, this.v1.z, this.v2.z))
}),
THREE.CubicBezierCurve3 = THREE.Curve.create(function(e, t, n, r) {
    this.v0 = e,
    this.v1 = t,
    this.v2 = n,
    this.v3 = r
},
function(e) {
    var t = THREE.ShapeUtils.b3;
    return new THREE.Vector3(t(e, this.v0.x, this.v1.x, this.v2.x, this.v3.x), t(e, this.v0.y, this.v1.y, this.v2.y, this.v3.y), t(e, this.v0.z, this.v1.z, this.v2.z, this.v3.z))
}),
THREE.SplineCurve3 = THREE.Curve.create(function(e) {
    console.warn("THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3"),
    this.points = void 0 == e ? [] : e
},
function(e) {
    var t = this.points;
    e *= t.length - 1;
    var n = Math.floor(e);
    e -= n;
    var r = t[0 == n ? n: n - 1],
    i = t[n],
    s = t[n > t.length - 2 ? t.length - 1 : n + 1],
    t = t[n > t.length - 3 ? t.length - 1 : n + 2],
    n = THREE.CurveUtils.interpolate;
    return new THREE.Vector3(n(r.x, i.x, s.x, t.x, e), n(r.y, i.y, s.y, t.y, e), n(r.z, i.z, s.z, t.z, e))
}),
THREE.CatmullRomCurve3 = function() {
    function e() {}
    var t = new THREE.Vector3,
    n = new e,
    r = new e,
    i = new e;
    return e.prototype.init = function(e, t, n, r) {
        this.c0 = e,
        this.c1 = n,
        this.c2 = -3 * e + 3 * t - 2 * n - r,
        this.c3 = 2 * e - 2 * t + n + r
    },
    e.prototype.initNonuniformCatmullRom = function(e, t, n, r, i, s, o) {
        e = ((t - e) / i - (n - e) / (i + s) + (n - t) / s) * s,
        r = ((n - t) / s - (r - t) / (s + o) + (r - n) / o) * s,
        this.init(t, n, e, r)
    },
    e.prototype.initCatmullRom = function(e, t, n, r, i) {
        this.init(t, n, i * (n - e), i * (r - t))
    },
    e.prototype.calc = function(e) {
        var t = e * e;
        return this.c0 + this.c1 * e + this.c2 * t + this.c3 * t * e
    },
    THREE.Curve.create(function(e) {
        this.points = e || [],
        this.closed = !1
    },
    function(e) {
        var s = this.points,
        o, u;
        u = s.length,
        2 > u && console.log("duh, you need at least 2 points"),
        e *= u - (this.closed ? 0 : 1),
        o = Math.floor(e),
        e -= o,
        this.closed ? o += 0 < o ? 0 : (Math.floor(Math.abs(o) / s.length) + 1) * s.length: 0 === e && o === u - 1 && (o = u - 2, e = 1);
        var a, f, l;
        this.closed || 0 < o ? a = s[(o - 1) % u] : (t.subVectors(s[0], s[1]).add(s[0]), a = t),
        f = s[o % u],
        l = s[(o + 1) % u],
        this.closed || o + 2 < u ? s = s[(o + 2) % u] : (t.subVectors(s[u - 1], s[u - 2]).add(s[u - 1]), s = t);
        if (void 0 === this.type || "centripetal" === this.type || "chordal" === this.type) {
            var h = "chordal" === this.type ? .5 : .25;
            u = Math.pow(a.distanceToSquared(f), h),
            o = Math.pow(f.distanceToSquared(l), h),
            h = Math.pow(l.distanceToSquared(s), h),
            1e-4 > o && (o = 1),
            1e-4 > u && (u = o),
            1e-4 > h && (h = o),
            n.initNonuniformCatmullRom(a.x, f.x, l.x, s.x, u, o, h),
            r.initNonuniformCatmullRom(a.y, f.y, l.y, s.y, u, o, h),
            i.initNonuniformCatmullRom(a.z, f.z, l.z, s.z, u, o, h)
        } else "catmullrom" === this.type && (u = void 0 !== this.tension ? this.tension: .5, n.initCatmullRom(a.x, f.x, l.x, s.x, u), r.initCatmullRom(a.y, f.y, l.y, s.y, u), i.initCatmullRom(a.z, f.z, l.z, s.z, u));
        return new THREE.Vector3(n.calc(e), r.calc(e), i.calc(e))
    })
} (),
THREE.ClosedSplineCurve3 = function(e) {
    console.warn("THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3."),
    THREE.CatmullRomCurve3.call(this, e),
    this.type = "catmullrom",
    this.closed = !0
},
THREE.ClosedSplineCurve3.prototype = Object.create(THREE.CatmullRomCurve3.prototype),
THREE.BoxGeometry = function(e, t, n, r, i, s) {
    THREE.Geometry.call(this),
    this.type = "BoxGeometry",
    this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: r,
        heightSegments: i,
        depthSegments: s
    },
    this.fromBufferGeometry(new THREE.BoxBufferGeometry(e, t, n, r, i, s)),
    this.mergeVertices()
},
THREE.BoxGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry,
THREE.CubeGeometry = THREE.BoxGeometry,
THREE.BoxBufferGeometry = function(e, t, n, r, i, s) {
    function o(e, t, n, r, i, s, o, a, f, b, E) {
        var S = s / f,
        x = o / b,
        T = s / 2,
        N = o / 2,
        C = a / 2;
        o = f + 1;
        for (var k = b + 1,
        L = s = 0,
        A = new THREE.Vector3,
        O = 0; O < k; O++) for (var M = O * x - N,
        _ = 0; _ < o; _++) A[e] = (_ * S - T) * r,
        A[t] = M * i,
        A[n] = C,
        c[d] = A.x,
        c[d + 1] = A.y,
        c[d + 2] = A.z,
        A[e] = 0,
        A[t] = 0,
        A[n] = 0 < a ? 1 : -1,
        h[d] = A.x,
        h[d + 1] = A.y,
        h[d + 2] = A.z,
        p[v] = _ / f,
        p[v + 1] = 1 - O / b,
        d += 3,
        v += 2,
        s += 1;
        for (O = 0; O < b; O++) for (_ = 0; _ < f; _++) e = g + _ + o * (O + 1),
        t = g + (_ + 1) + o * (O + 1),
        n = g + (_ + 1) + o * O,
        l[m] = g + _ + o * O,
        l[m + 1] = e,
        l[m + 2] = n,
        l[m + 3] = e,
        l[m + 4] = t,
        l[m + 5] = n,
        m += 6,
        L += 6;
        u.addGroup(y, L, E),
        y += L,
        g += s
    }
    THREE.BufferGeometry.call(this),
    this.type = "BoxBufferGeometry",
    this.parameters = {
        width: e,
        height: t,
        depth: n,
        widthSegments: r,
        heightSegments: i,
        depthSegments: s
    };
    var u = this;
    r = Math.floor(r) || 1,
    i = Math.floor(i) || 1,
    s = Math.floor(s) || 1;
    var a = function(e, t, n) {
        return e = 0 + e * t * 2 + e * n * 2,
        e += n * t * 2,
        4 * e
    } (r, i, s),
    f = a / 4 * 6,
    l = new(65535 < f ? Uint32Array: Uint16Array)(f),
    c = new Float32Array(3 * a),
    h = new Float32Array(3 * a),
    p = new Float32Array(2 * a),
    d = 0,
    v = 0,
    m = 0,
    g = 0,
    y = 0;
    o("z", "y", "x", -1, -1, n, t, e, s, i, 0),
    o("z", "y", "x", 1, -1, n, t, -e, s, i, 1),
    o("x", "z", "y", 1, 1, e, n, t, r, s, 2),
    o("x", "z", "y", 1, -1, e, n, -t, r, s, 3),
    o("x", "y", "z", 1, -1, e, t, n, r, i, 4),
    o("x", "y", "z", -1, -1, e, t, -n, r, i, 5),
    this.setIndex(new THREE.BufferAttribute(l, 1)),
    this.addAttribute("position", new THREE.BufferAttribute(c, 3)),
    this.addAttribute("normal", new THREE.BufferAttribute(h, 3)),
    this.addAttribute("uv", new THREE.BufferAttribute(p, 2))
},
THREE.BoxBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
THREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry,
THREE.CircleGeometry = function(e, t, n, r) {
    THREE.Geometry.call(this),
    this.type = "CircleGeometry",
    this.parameters = {
        radius: e,
        segments: t,
        thetaStart: n,
        thetaLength: r
    },
    this.fromBufferGeometry(new THREE.CircleBufferGeometry(e, t, n, r))
},
THREE.CircleGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry,
THREE.CircleBufferGeometry = function(e, t, n, r) {
    THREE.BufferGeometry.call(this),
    this.type = "CircleBufferGeometry",
    this.parameters = {
        radius: e,
        segments: t,
        thetaStart: n,
        thetaLength: r
    },
    e = e || 50,
    t = void 0 !== t ? Math.max(3, t) : 8,
    n = void 0 !== n ? n: 0,
    r = void 0 !== r ? r: 2 * Math.PI;
    var i = t + 2,
    s = new Float32Array(3 * i),
    o = new Float32Array(3 * i),
    i = new Float32Array(2 * i);
    o[2] = 1,
    i[0] = .5,
    i[1] = .5;
    for (var u = 0,
    a = 3,
    f = 2; u <= t; u++, a += 3, f += 2) {
        var l = n + u / t * r;
        s[a] = e * Math.cos(l),
        s[a + 1] = e * Math.sin(l),
        o[a + 2] = 1,
        i[f] = (s[a] / e + 1) / 2,
        i[f + 1] = (s[a + 1] / e + 1) / 2
    }
    n = [];
    for (a = 1; a <= t; a++) n.push(a, a + 1, 0);
    this.setIndex(new THREE.BufferAttribute(new Uint16Array(n), 1)),
    this.addAttribute("position", new THREE.BufferAttribute(s, 3)),
    this.addAttribute("normal", new THREE.BufferAttribute(o, 3)),
    this.addAttribute("uv", new THREE.BufferAttribute(i, 2)),
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3, e)
},
THREE.CircleBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
THREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry,
THREE.CylinderBufferGeometry = function(e, t, n, r, i, s, o, u) {
    function a(n) {
        var i, s, a;
        a = new THREE.Vector2;
        var f = new THREE.Vector3,
        l = !0 === n ? e: t,
        g = !0 === n ? 1 : -1;
        s = v;
        for (i = 1; i <= r; i++) h.setXYZ(v, 0, y * g, 0),
        p.setXYZ(v, 0, g, 0),
        !0 === n ? (a.x = i / r, a.y = 0) : (a.x = (i - 1) / r, a.y = 1),
        d.setXY(v, a.x, a.y),
        v++;
        a = v;
        for (i = 0; i <= r; i++) {
            var E = i / r;
            f.x = l * Math.sin(E * u + o),
            f.y = y * g,
            f.z = l * Math.cos(E * u + o),
            h.setXYZ(v, f.x, f.y, f.z),
            p.setXYZ(v, 0, g, 0),
            d.setXY(v, E, !0 === n ? 1 : 0),
            v++
        }
        for (i = 0; i < r; i++) f = s + i,
        l = a + i,
        !0 === n ? (c.setX(m, l), m++, c.setX(m, l + 1)) : (c.setX(m, l + 1), m++, c.setX(m, l)),
        m++,
        c.setX(m, f),
        m++
    }
    THREE.BufferGeometry.call(this),
    this.type = "CylinderBufferGeometry",
    this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: n,
        radialSegments: r,
        heightSegments: i,
        openEnded: s,
        thetaStart: o,
        thetaLength: u
    },
    e = void 0 !== e ? e: 20,
    t = void 0 !== t ? t: 20,
    n = void 0 !== n ? n: 100,
    r = Math.floor(r) || 8,
    i = Math.floor(i) || 1,
    s = void 0 !== s ? s: !1,
    o = void 0 !== o ? o: 0,
    u = void 0 !== u ? u: 2 * Math.PI;
    var f = function() {
        var e = (r + 1) * (i + 1);
        return ! 1 === s && (e += 2 * (r + 1) + 2 * r),
        e
    } (),
    l = function() {
        var e = r * i * 6;
        return ! 1 === s && (e += 6 * r),
        e
    } (),
    c = new THREE.BufferAttribute(new(65535 < l ? Uint32Array: Uint16Array)(l), 1),
    h = new THREE.BufferAttribute(new Float32Array(3 * f), 3),
    p = new THREE.BufferAttribute(new Float32Array(3 * f), 3),
    d = new THREE.BufferAttribute(new Float32Array(2 * f), 2),
    v = 0,
    m = 0,
    g = [],
    y = n / 2; (function() {
        var s, a, f = new THREE.Vector3,
        l = new THREE.Vector3,
        E = (t - e) / n;
        for (a = 0; a <= i; a++) {
            var S = [],
            x = a / i,
            T = x * (t - e) + e;
            for (s = 0; s <= r; s++) {
                var N = s / r;
                l.x = T * Math.sin(N * u + o),
                l.y = -x * n + y,
                l.z = T * Math.cos(N * u + o),
                h.setXYZ(v, l.x, l.y, l.z),
                f.copy(l);
                if (0 === e && 0 === a || 0 === t && a === i) f.x = Math.sin(N * u + o),
                f.z = Math.cos(N * u + o);
                f.setY(Math.sqrt(f.x * f.x + f.z * f.z) * E).normalize(),
                p.setXYZ(v, f.x, f.y, f.z),
                d.setXY(v, N, 1 - x),
                S.push(v),
                v++
            }
            g.push(S)
        }
        for (s = 0; s < r; s++) for (a = 0; a < i; a++) f = g[a + 1][s],
        l = g[a + 1][s + 1],
        E = g[a][s + 1],
        c.setX(m, g[a][s]),
        m++,
        c.setX(m, f),
        m++,
        c.setX(m, E),
        m++,
        c.setX(m, f),
        m++,
        c.setX(m, l),
        m++,
        c.setX(m, E),
        m++
    })(),
    !1 === s && (0 < e && a(!0), 0 < t && a(!1)),
    this.setIndex(c),
    this.addAttribute("position", h),
    this.addAttribute("normal", p),
    this.addAttribute("uv", d)
},
THREE.CylinderBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
THREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry,
THREE.CylinderGeometry = function(e, t, n, r, i, s, o, u) {
    THREE.Geometry.call(this),
    this.type = "CylinderGeometry",
    this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: n,
        radialSegments: r,
        heightSegments: i,
        openEnded: s,
        thetaStart: o,
        thetaLength: u
    },
    this.fromBufferGeometry(new THREE.CylinderBufferGeometry(e, t, n, r, i, s, o, u)),
    this.mergeVertices()
},
THREE.CylinderGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry,
THREE.EdgesGeometry = function(e, t) {
    function n(e, t) {
        return e - t
    }
    THREE.BufferGeometry.call(this);
    var r = Math.cos(THREE.Math.degToRad(void 0 !== t ? t: 1)),
    i = [0, 0],
    s = {},
    o = ["a", "b", "c"],
    u;
    e instanceof THREE.BufferGeometry ? (u = new THREE.Geometry, u.fromBufferGeometry(e)) : u = e.clone(),
    u.mergeVertices(),
    u.computeFaceNormals();
    var a = u.vertices;
    u = u.faces;
    for (var f = 0,
    l = u.length; f < l; f++) for (var c = u[f], h = 0; 3 > h; h++) {
        i[0] = c[o[h]],
        i[1] = c[o[(h + 1) % 3]],
        i.sort(n);
        var p = i.toString();
        void 0 === s[p] ? s[p] = {
            vert1: i[0],
            vert2: i[1],
            face1: f,
            face2: void 0
        }: s[p].face2 = f
    }
    i = [];
    for (p in s) if (o = s[p], void 0 === o.face2 || u[o.face1].normal.dot(u[o.face2].normal) <= r) f = a[o.vert1],
    i.push(f.x),
    i.push(f.y),
    i.push(f.z),
    f = a[o.vert2],
    i.push(f.x),
    i.push(f.y),
    i.push(f.z);
    this.addAttribute("position", new THREE.BufferAttribute(new Float32Array(i), 3))
},
THREE.EdgesGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
THREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry,
THREE.ExtrudeGeometry = function(e, t) {
    "undefined" != typeof e && (THREE.Geometry.call(this), this.type = "ExtrudeGeometry", e = Array.isArray(e) ? e: [e], this.addShapeList(e, t), this.computeFaceNormals())
},
THREE.ExtrudeGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry,
THREE.ExtrudeGeometry.prototype.addShapeList = function(e, t) {
    for (var n = e.length,
    r = 0; r < n; r++) this.addShape(e[r], t)
},
THREE.ExtrudeGeometry.prototype.addShape = function(e, t) {
    function n(e, t, n) {
        return t || console.error("THREE.ExtrudeGeometry: vec does not exist"),
        t.clone().multiplyScalar(n).add(e)
    }
    function r(e, t, n) {
        var r = 1,
        r = e.x - t.x,
        i = e.y - t.y,
        s = n.x - e.x,
        o = n.y - e.y,
        u = r * r + i * i;
        if (Math.abs(r * o - i * s) > Number.EPSILON) {
            var a = Math.sqrt(u),
            f = Math.sqrt(s * s + o * o),
            u = t.x - i / a;
            t = t.y + r / a,
            s = ((n.x - o / f - u) * o - (n.y + s / f - t) * s) / (r * o - i * s),
            n = u + r * s - e.x,
            e = t + i * s - e.y,
            r = n * n + e * e;
            if (2 >= r) return new THREE.Vector2(n, e);
            r = Math.sqrt(r / 2)
        } else e = !1,
        r > Number.EPSILON ? s > Number.EPSILON && (e = !0) : r < -Number.EPSILON ? s < -Number.EPSILON && (e = !0) : Math.sign(i) === Math.sign(o) && (e = !0),
        e ? (n = -i, e = r, r = Math.sqrt(u)) : (n = r, e = i, r = Math.sqrt(u / 2));
        return new THREE.Vector2(n / r, e / r)
    }
    function i(e, t) {
        var n, r;
        for (F = e.length; 0 <= --F;) {
            n = F,
            r = F - 1,
            0 > r && (r = e.length - 1);
            for (var i = 0,
            s = p + 2 * l,
            i = 0; i < s; i++) {
                var o = H * i,
                u = H * (i + 1),
                a = t + n + o,
                o = t + r + o,
                f = t + r + u,
                u = t + n + u,
                a = a + C,
                o = o + C,
                f = f + C,
                u = u + C;
                N.faces.push(new THREE.Face3(a, o, u, null, null, 1)),
                N.faces.push(new THREE.Face3(o, f, u, null, null, 1)),
                a = g.generateSideWallUV(N, a, o, f, u),
                N.faceVertexUvs[0].push([a[0], a[1], a[3]]),
                N.faceVertexUvs[0].push([a[1], a[2], a[3]])
            }
        }
    }
    function s(e, t, n) {
        N.vertices.push(new THREE.Vector3(e, t, n))
    }
    function o(e, t, n) {
        e += C,
        t += C,
        n += C,
        N.faces.push(new THREE.Face3(e, t, n, null, null, 0)),
        e = g.generateTopUV(N, e, t, n),
        N.faceVertexUvs[0].push(e)
    }
    var u = void 0 !== t.amount ? t.amount: 100,
    a = void 0 !== t.bevelThickness ? t.bevelThickness: 6,
    f = void 0 !== t.bevelSize ? t.bevelSize: a - 2,
    l = void 0 !== t.bevelSegments ? t.bevelSegments: 3,
    c = void 0 !== t.bevelEnabled ? t.bevelEnabled: !0,
    h = void 0 !== t.curveSegments ? t.curveSegments: 12,
    p = void 0 !== t.steps ? t.steps: 1,
    d = t.extrudePath,
    v,
    m = !1,
    g = void 0 !== t.UVGenerator ? t.UVGenerator: THREE.ExtrudeGeometry.WorldUVGenerator,
    y,
    b,
    w,
    E;
    d && (v = d.getSpacedPoints(p), m = !0, c = !1, y = void 0 !== t.frames ? t.frames: new THREE.TubeGeometry.FrenetFrames(d, p, !1), b = new THREE.Vector3, w = new THREE.Vector3, E = new THREE.Vector3),
    c || (f = a = l = 0);
    var S, x, T, N = this,
    C = this.vertices.length,
    d = e.extractPoints(h),
    h = d.shape,
    k = d.holes;
    if (d = !THREE.ShapeUtils.isClockWise(h)) {
        h = h.reverse(),
        x = 0;
        for (T = k.length; x < T; x++) S = k[x],
        THREE.ShapeUtils.isClockWise(S) && (k[x] = S.reverse());
        d = !1
    }
    var L = THREE.ShapeUtils.triangulateShape(h, k),
    A = h;
    x = 0;
    for (T = k.length; x < T; x++) S = k[x],
    h = h.concat(S);
    var O, M, _, D, P, H = h.length,
    B, j = L.length,
    d = [],
    F = 0;
    _ = A.length,
    O = _ - 1;
    for (M = F + 1; F < _; F++, O++, M++) O === _ && (O = 0),
    M === _ && (M = 0),
    d[F] = r(A[F], A[O], A[M]);
    var I = [],
    q,
    R = d.concat();
    x = 0;
    for (T = k.length; x < T; x++) {
        S = k[x],
        q = [],
        F = 0,
        _ = S.length,
        O = _ - 1;
        for (M = F + 1; F < _; F++, O++, M++) O === _ && (O = 0),
        M === _ && (M = 0),
        q[F] = r(S[F], S[O], S[M]);
        I.push(q),
        R = R.concat(q)
    }
    for (O = 0; O < l; O++) {
        _ = O / l,
        D = a * (1 - _),
        M = f * Math.sin(_ * Math.PI / 2),
        F = 0;
        for (_ = A.length; F < _; F++) P = n(A[F], d[F], M),
        s(P.x, P.y, -D);
        x = 0;
        for (T = k.length; x < T; x++) for (S = k[x], q = I[x], F = 0, _ = S.length; F < _; F++) P = n(S[F], q[F], M),
        s(P.x, P.y, -D)
    }
    M = f;
    for (F = 0; F < H; F++) P = c ? n(h[F], R[F], M) : h[F],
    m ? (w.copy(y.normals[0]).multiplyScalar(P.x), b.copy(y.binormals[0]).multiplyScalar(P.y), E.copy(v[0]).add(w).add(b), s(E.x, E.y, E.z)) : s(P.x, P.y, 0);
    for (_ = 1; _ <= p; _++) for (F = 0; F < H; F++) P = c ? n(h[F], R[F], M) : h[F],
    m ? (w.copy(y.normals[_]).multiplyScalar(P.x), b.copy(y.binormals[_]).multiplyScalar(P.y), E.copy(v[_]).add(w).add(b), s(E.x, E.y, E.z)) : s(P.x, P.y, u / p * _);
    for (O = l - 1; 0 <= O; O--) {
        _ = O / l,
        D = a * (1 - _),
        M = f * Math.sin(_ * Math.PI / 2),
        F = 0;
        for (_ = A.length; F < _; F++) P = n(A[F], d[F], M),
        s(P.x, P.y, u + D);
        x = 0;
        for (T = k.length; x < T; x++) for (S = k[x], q = I[x], F = 0, _ = S.length; F < _; F++) P = n(S[F], q[F], M),
        m ? s(P.x, P.y + v[p - 1].y, v[p - 1].x + D) : s(P.x, P.y, u + D)
    } (function() {
        if (c) {
            var e;
            e = 0 * H;
            for (F = 0; F < j; F++) B = L[F],
            o(B[2] + e, B[1] + e, B[0] + e);
            e = p + 2 * l,
            e *= H;
            for (F = 0; F < j; F++) B = L[F],
            o(B[0] + e, B[1] + e, B[2] + e)
        } else {
            for (F = 0; F < j; F++) B = L[F],
            o(B[2], B[1], B[0]);
            for (F = 0; F < j; F++) B = L[F],
            o(B[0] + H * p, B[1] + H * p, B[2] + H * p)
        }
    })(),
    function() {
        var e = 0;
        i(A, e),
        e += A.length,
        x = 0;
        for (T = k.length; x < T; x++) S = k[x],
        i(S, e),
        e += S.length
    } ()
},
THREE.ExtrudeGeometry.WorldUVGenerator = {
    generateTopUV: function(e, t, n, r) {
        return e = e.vertices,
        t = e[t],
        n = e[n],
        r = e[r],
        [new THREE.Vector2(t.x, t.y), new THREE.Vector2(n.x, n.y), new THREE.Vector2(r.x, r.y)]
    },
    generateSideWallUV: function(e, t, n, r, i) {
        return e = e.vertices,
        t = e[t],
        n = e[n],
        r = e[r],
        i = e[i],
        .01 > Math.abs(t.y - n.y) ? [new THREE.Vector2(t.x, 1 - t.z), new THREE.Vector2(n.x, 1 - n.z), new THREE.Vector2(r.x, 1 - r.z), new THREE.Vector2(i.x, 1 - i.z)] : [new THREE.Vector2(t.y, 1 - t.z), new THREE.Vector2(n.y, 1 - n.z), new THREE.Vector2(r.y, 1 - r.z), new THREE.Vector2(i.y, 1 - i.z)]
    }
},
THREE.ShapeGeometry = function(e, t) {
    THREE.Geometry.call(this),
    this.type = "ShapeGeometry",
    !1 === Array.isArray(e) && (e = [e]),
    this.addShapeList(e, t),
    this.computeFaceNormals()
},
THREE.ShapeGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry,
THREE.ShapeGeometry.prototype.addShapeList = function(e, t) {
    for (var n = 0,
    r = e.length; n < r; n++) this.addShape(e[n], t);
    return this
},
THREE.ShapeGeometry.prototype.addShape = function(e, t) {
    void 0 === t && (t = {});
    var n = t.material,
    r = void 0 === t.UVGenerator ? THREE.ExtrudeGeometry.WorldUVGenerator: t.UVGenerator,
    i,
    s,
    o,
    u = this.vertices.length;
    i = e.extractPoints(void 0 !== t.curveSegments ? t.curveSegments: 12);
    var a = i.shape,
    f = i.holes;
    if (!THREE.ShapeUtils.isClockWise(a)) for (a = a.reverse(), i = 0, s = f.length; i < s; i++) o = f[i],
    THREE.ShapeUtils.isClockWise(o) && (f[i] = o.reverse());
    var l = THREE.ShapeUtils.triangulateShape(a, f);
    i = 0;
    for (s = f.length; i < s; i++) o = f[i],
    a = a.concat(o);
    f = a.length,
    s = l.length;
    for (i = 0; i < f; i++) o = a[i],
    this.vertices.push(new THREE.Vector3(o.x, o.y, 0));
    for (i = 0; i < s; i++) f = l[i],
    a = f[0] + u,
    o = f[1] + u,
    f = f[2] + u,
    this.faces.push(new THREE.Face3(a, o, f, null, null, n)),
    this.faceVertexUvs[0].push(r.generateTopUV(this, a, o, f))
},
THREE.LatheBufferGeometry = function(e, t, n, r) {
    THREE.BufferGeometry.call(this),
    this.type = "LatheBufferGeometry",
    this.parameters = {
        points: e,
        segments: t,
        phiStart: n,
        phiLength: r
    },
    t = Math.floor(t) || 12,
    n = n || 0,
    r = r || 2 * Math.PI,
    r = THREE.Math.clamp(r, 0, 2 * Math.PI);
    for (var i = (t + 1) * e.length, s = t * e.length * 6, o = new THREE.BufferAttribute(new(65535 < s ? Uint32Array: Uint16Array)(s), 1), u = new THREE.BufferAttribute(new Float32Array(3 * i), 3), a = new THREE.BufferAttribute(new Float32Array(2 * i), 2), f = 0, l = 0, c = 1 / t, h = new THREE.Vector3, p = new THREE.Vector2, i = 0; i <= t; i++) for (var s = n + i * c * r,
    d = Math.sin(s), v = Math.cos(s), s = 0; s <= e.length - 1; s++) h.x = e[s].x * d,
    h.y = e[s].y,
    h.z = e[s].x * v,
    u.setXYZ(f, h.x, h.y, h.z),
    p.x = i / t,
    p.y = s / (e.length - 1),
    a.setXY(f, p.x, p.y),
    f++;
    for (i = 0; i < t; i++) for (s = 0; s < e.length - 1; s++) n = s + i * e.length,
    f = n + e.length,
    c = n + e.length + 1,
    h = n + 1,
    o.setX(l, n),
    l++,
    o.setX(l, f),
    l++,
    o.setX(l, h),
    l++,
    o.setX(l, f),
    l++,
    o.setX(l, c),
    l++,
    o.setX(l, h),
    l++;
    this.setIndex(o),
    this.addAttribute("position", u),
    this.addAttribute("uv", a),
    this.computeVertexNormals();
    if (r === 2 * Math.PI) for (r = this.attributes.normal.array, o = new THREE.Vector3, u = new THREE.Vector3, a = new THREE.Vector3, n = t * e.length * 3, s = i = 0; i < e.length; i++, s += 3) o.x = r[s + 0],
    o.y = r[s + 1],
    o.z = r[s + 2],
    u.x = r[n + s + 0],
    u.y = r[n + s + 1],
    u.z = r[n + s + 2],
    a.addVectors(o, u).normalize(),
    r[s + 0] = r[n + s + 0] = a.x,
    r[s + 1] = r[n + s + 1] = a.y,
    r[s + 2] = r[n + s + 2] = a.z
},
THREE.LatheBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
THREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry,
THREE.LatheGeometry = function(e, t, n, r) {
    THREE.Geometry.call(this),
    this.type = "LatheGeometry",
    this.parameters = {
        points: e,
        segments: t,
        phiStart: n,
        phiLength: r
    },
    this.fromBufferGeometry(new THREE.LatheBufferGeometry(e, t, n, r)),
    this.mergeVertices()
},
THREE.LatheGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry,
THREE.PlaneGeometry = function(e, t, n, r) {
    THREE.Geometry.call(this),
    this.type = "PlaneGeometry",
    this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: r
    },
    this.fromBufferGeometry(new THREE.PlaneBufferGeometry(e, t, n, r))
},
THREE.PlaneGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry,
THREE.PlaneBufferGeometry = function(e, t, n, r) {
    THREE.BufferGeometry.call(this),
    this.type = "PlaneBufferGeometry",
    this.parameters = {
        width: e,
        height: t,
        widthSegments: n,
        heightSegments: r
    };
    var i = e / 2,
    s = t / 2;
    n = Math.floor(n) || 1,
    r = Math.floor(r) || 1;
    var o = n + 1,
    u = r + 1,
    a = e / n,
    f = t / r;
    t = new Float32Array(o * u * 3),
    e = new Float32Array(o * u * 3);
    for (var l = new Float32Array(o * u * 2), c = 0, h = 0, p = 0; p < u; p++) for (var d = p * f - s,
    v = 0; v < o; v++) t[c] = v * a - i,
    t[c + 1] = -d,
    e[c + 2] = 1,
    l[h] = v / n,
    l[h + 1] = 1 - p / r,
    c += 3,
    h += 2;
    c = 0,
    i = new(65535 < t.length / 3 ? Uint32Array: Uint16Array)(n * r * 6);
    for (p = 0; p < r; p++) for (v = 0; v < n; v++) s = v + o * (p + 1),
    u = v + 1 + o * (p + 1),
    a = v + 1 + o * p,
    i[c] = v + o * p,
    i[c + 1] = s,
    i[c + 2] = a,
    i[c + 3] = s,
    i[c + 4] = u,
    i[c + 5] = a,
    c += 6;
    this.setIndex(new THREE.BufferAttribute(i, 1)),
    this.addAttribute("position", new THREE.BufferAttribute(t, 3)),
    this.addAttribute("normal", new THREE.BufferAttribute(e, 3)),
    this.addAttribute("uv", new THREE.BufferAttribute(l, 2))
},
THREE.PlaneBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
THREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry,
THREE.RingBufferGeometry = function(e, t, n, r, i, s) {
    THREE.BufferGeometry.call(this),
    this.type = "RingBufferGeometry",
    this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: n,
        phiSegments: r,
        thetaStart: i,
        thetaLength: s
    },
    e = e || 20,
    t = t || 50,
    i = void 0 !== i ? i: 0,
    s = void 0 !== s ? s: 2 * Math.PI,
    n = void 0 !== n ? Math.max(3, n) : 8,
    r = void 0 !== r ? Math.max(1, r) : 1;
    var o = (n + 1) * (r + 1),
    u = n * r * 6,
    u = new THREE.BufferAttribute(new(65535 < u ? Uint32Array: Uint16Array)(u), 1),
    a = new THREE.BufferAttribute(new Float32Array(3 * o), 3),
    f = new THREE.BufferAttribute(new Float32Array(3 * o), 3),
    o = new THREE.BufferAttribute(new Float32Array(2 * o), 2),
    l = 0,
    c = 0,
    h,
    p = e,
    d = (t - e) / r,
    v = new THREE.Vector3,
    m = new THREE.Vector2,
    g;
    for (e = 0; e <= r; e++) {
        for (g = 0; g <= n; g++) h = i + g / n * s,
        v.x = p * Math.cos(h),
        v.y = p * Math.sin(h),
        a.setXYZ(l, v.x, v.y, v.z),
        f.setXYZ(l, 0, 0, 1),
        m.x = (v.x / t + 1) / 2,
        m.y = (v.y / t + 1) / 2,
        o.setXY(l, m.x, m.y),
        l++;
        p += d
    }
    for (e = 0; e < r; e++) for (t = e * (n + 1), g = 0; g < n; g++) i = h = g + t,
    s = h + n + 1,
    l = h + n + 2,
    h += 1,
    u.setX(c, i),
    c++,
    u.setX(c, s),
    c++,
    u.setX(c, l),
    c++,
    u.setX(c, i),
    c++,
    u.setX(c, l),
    c++,
    u.setX(c, h),
    c++;
    this.setIndex(u),
    this.addAttribute("position", a),
    this.addAttribute("normal", f),
    this.addAttribute("uv", o)
},
THREE.RingBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
THREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry,
THREE.RingGeometry = function(e, t, n, r, i, s) {
    THREE.Geometry.call(this),
    this.type = "RingGeometry",
    this.parameters = {
        innerRadius: e,
        outerRadius: t,
        thetaSegments: n,
        phiSegments: r,
        thetaStart: i,
        thetaLength: s
    },
    this.fromBufferGeometry(new THREE.RingBufferGeometry(e, t, n, r, i, s))
},
THREE.RingGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.RingGeometry.prototype.constructor = THREE.RingGeometry,
THREE.SphereGeometry = function(e, t, n, r, i, s, o) {
    THREE.Geometry.call(this),
    this.type = "SphereGeometry",
    this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: n,
        phiStart: r,
        phiLength: i,
        thetaStart: s,
        thetaLength: o
    },
    this.fromBufferGeometry(new THREE.SphereBufferGeometry(e, t, n, r, i, s, o))
},
THREE.SphereGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry,
THREE.SphereBufferGeometry = function(e, t, n, r, i, s, o) {
    THREE.BufferGeometry.call(this),
    this.type = "SphereBufferGeometry",
    this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: n,
        phiStart: r,
        phiLength: i,
        thetaStart: s,
        thetaLength: o
    },
    e = e || 50,
    t = Math.max(3, Math.floor(t) || 8),
    n = Math.max(2, Math.floor(n) || 6),
    r = void 0 !== r ? r: 0,
    i = void 0 !== i ? i: 2 * Math.PI,
    s = void 0 !== s ? s: 0,
    o = void 0 !== o ? o: Math.PI;
    for (var u = s + o,
    a = (t + 1) * (n + 1), f = new THREE.BufferAttribute(new Float32Array(3 * a), 3), l = new THREE.BufferAttribute(new Float32Array(3 * a), 3), a = new THREE.BufferAttribute(new Float32Array(2 * a), 2), c = 0, h = [], p = new THREE.Vector3, d = 0; d <= n; d++) {
        for (var v = [], m = d / n, g = 0; g <= t; g++) {
            var y = g / t,
            b = -e * Math.cos(r + y * i) * Math.sin(s + m * o),
            w = e * Math.cos(s + m * o),
            E = e * Math.sin(r + y * i) * Math.sin(s + m * o);
            p.set(b, w, E).normalize(),
            f.setXYZ(c, b, w, E),
            l.setXYZ(c, p.x, p.y, p.z),
            a.setXY(c, y, 1 - m),
            v.push(c),
            c++
        }
        h.push(v)
    }
    r = [];
    for (d = 0; d < n; d++) for (g = 0; g < t; g++) i = h[d][g + 1],
    o = h[d][g],
    c = h[d + 1][g],
    p = h[d + 1][g + 1],
    (0 !== d || 0 < s) && r.push(i, o, p),
    (d !== n - 1 || u < Math.PI) && r.push(o, c, p);
    this.setIndex(new(65535 < f.count ? THREE.Uint32Attribute: THREE.Uint16Attribute)(r, 1)),
    this.addAttribute("position", f),
    this.addAttribute("normal", l),
    this.addAttribute("uv", a),
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3, e)
},
THREE.SphereBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
THREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry,
THREE.TextGeometry = function(e, t) {
    t = t || {};
    var n = t.font;
    if (0 == n instanceof THREE.Font) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."),
    new THREE.Geometry;
    n = n.generateShapes(e, t.size, t.curveSegments),
    t.amount = void 0 !== t.height ? t.height: 50,
    void 0 === t.bevelThickness && (t.bevelThickness = 10),
    void 0 === t.bevelSize && (t.bevelSize = 8),
    void 0 === t.bevelEnabled && (t.bevelEnabled = !1),
    THREE.ExtrudeGeometry.call(this, n, t),
    this.type = "TextGeometry"
},
THREE.TextGeometry.prototype = Object.create(THREE.ExtrudeGeometry.prototype),
THREE.TextGeometry.prototype.constructor = THREE.TextGeometry,
THREE.TorusBufferGeometry = function(e, t, n, r, i) {
    THREE.BufferGeometry.call(this),
    this.type = "TorusBufferGeometry",
    this.parameters = {
        radius: e,
        tube: t,
        radialSegments: n,
        tubularSegments: r,
        arc: i
    },
    e = e || 100,
    t = t || 40,
    n = Math.floor(n) || 8,
    r = Math.floor(r) || 6,
    i = i || 2 * Math.PI;
    var s = (n + 1) * (r + 1),
    o = n * r * 6,
    o = new(65535 < o ? Uint32Array: Uint16Array)(o),
    u = new Float32Array(3 * s),
    a = new Float32Array(3 * s),
    s = new Float32Array(2 * s),
    f = 0,
    l = 0,
    c = 0,
    h = new THREE.Vector3,
    p = new THREE.Vector3,
    d = new THREE.Vector3,
    v,
    m;
    for (v = 0; v <= n; v++) for (m = 0; m <= r; m++) {
        var g = m / r * i,
        y = v / n * Math.PI * 2;
        p.x = (e + t * Math.cos(y)) * Math.cos(g),
        p.y = (e + t * Math.cos(y)) * Math.sin(g),
        p.z = t * Math.sin(y),
        u[f] = p.x,
        u[f + 1] = p.y,
        u[f + 2] = p.z,
        h.x = e * Math.cos(g),
        h.y = e * Math.sin(g),
        d.subVectors(p, h).normalize(),
        a[f] = d.x,
        a[f + 1] = d.y,
        a[f + 2] = d.z,
        s[l] = m / r,
        s[l + 1] = v / n,
        f += 3,
        l += 2
    }
    for (v = 1; v <= n; v++) for (m = 1; m <= r; m++) e = (r + 1) * (v - 1) + m - 1,
    t = (r + 1) * (v - 1) + m,
    i = (r + 1) * v + m,
    o[c] = (r + 1) * v + m - 1,
    o[c + 1] = e,
    o[c + 2] = i,
    o[c + 3] = e,
    o[c + 4] = t,
    o[c + 5] = i,
    c += 6;
    this.setIndex(new THREE.BufferAttribute(o, 1)),
    this.addAttribute("position", new THREE.BufferAttribute(u, 3)),
    this.addAttribute("normal", new THREE.BufferAttribute(a, 3)),
    this.addAttribute("uv", new THREE.BufferAttribute(s, 2))
},
THREE.TorusBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
THREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry,
THREE.TorusGeometry = function(e, t, n, r, i) {
    THREE.Geometry.call(this),
    this.type = "TorusGeometry",
    this.parameters = {
        radius: e,
        tube: t,
        radialSegments: n,
        tubularSegments: r,
        arc: i
    },
    this.fromBufferGeometry(new THREE.TorusBufferGeometry(e, t, n, r, i))
},
THREE.TorusGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry,
THREE.TorusKnotBufferGeometry = function(e, t, n, r, i, s) {
    function o(e, t, n, r, i) {
        var s = Math.cos(e),
        o = Math.sin(e);
        e *= n / t,
        t = Math.cos(e),
        i.x = r * (2 + t) * .5 * s,
        i.y = r * (2 + t) * o * .5,
        i.z = r * Math.sin(e) * .5
    }
    THREE.BufferGeometry.call(this),
    this.type = "TorusKnotBufferGeometry",
    this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: n,
        radialSegments: r,
        p: i,
        q: s
    },
    e = e || 100,
    t = t || 40,
    n = Math.floor(n) || 64,
    r = Math.floor(r) || 8,
    i = i || 2,
    s = s || 3;
    var u = (r + 1) * (n + 1),
    a = r * n * 6,
    a = new THREE.BufferAttribute(new(65535 < a ? Uint32Array: Uint16Array)(a), 1),
    f = new THREE.BufferAttribute(new Float32Array(3 * u), 3),
    l = new THREE.BufferAttribute(new Float32Array(3 * u), 3),
    u = new THREE.BufferAttribute(new Float32Array(2 * u), 2),
    c,
    h,
    p = 0,
    d = 0,
    v = new THREE.Vector3,
    m = new THREE.Vector3,
    g = new THREE.Vector2,
    y = new THREE.Vector3,
    b = new THREE.Vector3,
    w = new THREE.Vector3,
    E = new THREE.Vector3,
    S = new THREE.Vector3;
    for (c = 0; c <= n; ++c) for (h = c / n * i * Math.PI * 2, o(h, i, s, e, y), o(h + .01, i, s, e, b), E.subVectors(b, y), S.addVectors(b, y), w.crossVectors(E, S), S.crossVectors(w, E), w.normalize(), S.normalize(), h = 0; h <= r; ++h) {
        var x = h / r * Math.PI * 2,
        T = -t * Math.cos(x),
        x = t * Math.sin(x);
        v.x = y.x + (T * S.x + x * w.x),
        v.y = y.y + (T * S.y + x * w.y),
        v.z = y.z + (T * S.z + x * w.z),
        f.setXYZ(p, v.x, v.y, v.z),
        m.subVectors(v, y).normalize(),
        l.setXYZ(p, m.x, m.y, m.z),
        g.x = c / n,
        g.y = h / r,
        u.setXY(p, g.x, g.y),
        p++
    }
    for (h = 1; h <= n; h++) for (c = 1; c <= r; c++) e = (r + 1) * h + (c - 1),
    t = (r + 1) * h + c,
    i = (r + 1) * (h - 1) + c,
    a.setX(d, (r + 1) * (h - 1) + (c - 1)),
    d++,
    a.setX(d, e),
    d++,
    a.setX(d, i),
    d++,
    a.setX(d, e),
    d++,
    a.setX(d, t),
    d++,
    a.setX(d, i),
    d++;
    this.setIndex(a),
    this.addAttribute("position", f),
    this.addAttribute("normal", l),
    this.addAttribute("uv", u)
},
THREE.TorusKnotBufferGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
THREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry,
THREE.TorusKnotGeometry = function(e, t, n, r, i, s, o) {
    THREE.Geometry.call(this),
    this.type = "TorusKnotGeometry",
    this.parameters = {
        radius: e,
        tube: t,
        tubularSegments: n,
        radialSegments: r,
        p: i,
        q: s
    },
    void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."),
    this.fromBufferGeometry(new THREE.TorusKnotBufferGeometry(e, t, n, r, i, s)),
    this.mergeVertices()
},
THREE.TorusKnotGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry,
THREE.TubeGeometry = function(e, t, n, r, i, s) {
    THREE.Geometry.call(this),
    this.type = "TubeGeometry",
    this.parameters = {
        path: e,
        segments: t,
        radius: n,
        radialSegments: r,
        closed: i,
        taper: s
    },
    t = t || 64,
    n = n || 1,
    r = r || 8,
    i = i || !1,
    s = s || THREE.TubeGeometry.NoTaper;
    var o = [],
    u,
    a,
    f = t + 1,
    l,
    c,
    h,
    p,
    d,
    v = new THREE.Vector3,
    m,
    g,
    y;
    m = new THREE.TubeGeometry.FrenetFrames(e, t, i),
    g = m.normals,
    y = m.binormals,
    this.tangents = m.tangents,
    this.normals = g,
    this.binormals = y;
    for (m = 0; m < f; m++) for (o[m] = [], l = m / (f - 1), d = e.getPointAt(l), u = g[m], a = y[m], h = n * s(l), l = 0; l < r; l++) c = l / r * 2 * Math.PI,
    p = -h * Math.cos(c),
    c = h * Math.sin(c),
    v.copy(d),
    v.x += p * u.x + c * a.x,
    v.y += p * u.y + c * a.y,
    v.z += p * u.z + c * a.z,
    o[m][l] = this.vertices.push(new THREE.Vector3(v.x, v.y, v.z)) - 1;
    for (m = 0; m < t; m++) for (l = 0; l < r; l++) s = i ? (m + 1) % t: m + 1,
    f = (l + 1) % r,
    e = o[m][l],
    n = o[s][l],
    s = o[s][f],
    f = o[m][f],
    v = new THREE.Vector2(m / t, l / r),
    g = new THREE.Vector2((m + 1) / t, l / r),
    y = new THREE.Vector2((m + 1) / t, (l + 1) / r),
    u = new THREE.Vector2(m / t, (l + 1) / r),
    this.faces.push(new THREE.Face3(e, n, f)),
    this.faceVertexUvs[0].push([v, g, u]),
    this.faces.push(new THREE.Face3(n, s, f)),
    this.faceVertexUvs[0].push([g.clone(), y, u.clone()]);
    this.computeFaceNormals(),
    this.computeVertexNormals()
},
THREE.TubeGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry,
THREE.TubeGeometry.NoTaper = function(e) {
    return 1
},
THREE.TubeGeometry.SinusoidalTaper = function(e) {
    return Math.sin(Math.PI * e)
},
THREE.TubeGeometry.FrenetFrames = function(e, t, n) {
    var r = new THREE.Vector3,
    i = [],
    s = [],
    o = [],
    u = new THREE.Vector3,
    a = new THREE.Matrix4;
    t += 1;
    var f, l, c;
    this.tangents = i,
    this.normals = s,
    this.binormals = o;
    for (f = 0; f < t; f++) l = f / (t - 1),
    i[f] = e.getTangentAt(l),
    i[f].normalize();
    s[0] = new THREE.Vector3,
    o[0] = new THREE.Vector3,
    e = Number.MAX_VALUE,
    f = Math.abs(i[0].x),
    l = Math.abs(i[0].y),
    c = Math.abs(i[0].z),
    f <= e && (e = f, r.set(1, 0, 0)),
    l <= e && (e = l, r.set(0, 1, 0)),
    c <= e && r.set(0, 0, 1),
    u.crossVectors(i[0], r).normalize(),
    s[0].crossVectors(i[0], u),
    o[0].crossVectors(i[0], s[0]);
    for (f = 1; f < t; f++) s[f] = s[f - 1].clone(),
    o[f] = o[f - 1].clone(),
    u.crossVectors(i[f - 1], i[f]),
    u.length() > Number.EPSILON && (u.normalize(), r = Math.acos(THREE.Math.clamp(i[f - 1].dot(i[f]), -1, 1)), s[f].applyMatrix4(a.makeRotationAxis(u, r))),
    o[f].crossVectors(i[f], s[f]);
    if (n) for (r = Math.acos(THREE.Math.clamp(s[0].dot(s[t - 1]), -1, 1)), r /= t - 1, 0 < i[0].dot(u.crossVectors(s[0], s[t - 1])) && (r = -r), f = 1; f < t; f++) s[f].applyMatrix4(a.makeRotationAxis(i[f], r * f)),
    o[f].crossVectors(i[f], s[f])
},
THREE.PolyhedronGeometry = function(e, t, n, r) {
    function i(e) {
        var t = e.normalize().clone();
        t.index = a.vertices.push(t) - 1;
        var n = Math.atan2(e.z, -e.x) / 2 / Math.PI + .5;
        return e = Math.atan2( - e.y, Math.sqrt(e.x * e.x + e.z * e.z)) / Math.PI + .5,
        t.uv = new THREE.Vector2(n, 1 - e),
        t
    }
    function s(e, t, n, r) {
        r = new THREE.Face3(e.index, t.index, n.index, [e.clone(), t.clone(), n.clone()], void 0, r),
        a.faces.push(r),
        m.copy(e).add(t).add(n).divideScalar(3),
        r = Math.atan2(m.z, -m.x),
        a.faceVertexUvs[0].push([u(e.uv, e, r), u(t.uv, t, r), u(n.uv, n, r)])
    }
    function o(e, t) {
        for (var n = Math.pow(2, t), r = i(a.vertices[e.a]), o = i(a.vertices[e.b]), u = i(a.vertices[e.c]), f = [], l = e.materialIndex, c = 0; c <= n; c++) {
            f[c] = [];
            for (var h = i(r.clone().lerp(u, c / n)), p = i(o.clone().lerp(u, c / n)), d = n - c, v = 0; v <= d; v++) f[c][v] = 0 === v && c === n ? h: i(h.clone().lerp(p, v / d))
        }
        for (c = 0; c < n; c++) for (v = 0; v < 2 * (n - c) - 1; v++) r = Math.floor(v / 2),
        0 === v % 2 ? s(f[c][r + 1], f[c + 1][r], f[c][r], l) : s(f[c][r + 1], f[c + 1][r + 1], f[c + 1][r], l)
    }
    function u(e, t, n) {
        return 0 > n && 1 === e.x && (e = new THREE.Vector2(e.x - 1, e.y)),
        0 === t.x && 0 === t.z && (e = new THREE.Vector2(n / 2 / Math.PI + .5, e.y)),
        e.clone()
    }
    THREE.Geometry.call(this),
    this.type = "PolyhedronGeometry",
    this.parameters = {
        vertices: e,
        indices: t,
        radius: n,
        detail: r
    },
    n = n || 1,
    r = r || 0;
    for (var a = this,
    f = 0,
    l = e.length; f < l; f += 3) i(new THREE.Vector3(e[f], e[f + 1], e[f + 2]));
    e = this.vertices;
    for (var c = [], h = f = 0, l = t.length; f < l; f += 3, h++) {
        var p = e[t[f]],
        d = e[t[f + 1]],
        v = e[t[f + 2]];
        c[h] = new THREE.Face3(p.index, d.index, v.index, [p.clone(), d.clone(), v.clone()], void 0, h)
    }
    for (var m = new THREE.Vector3,
    f = 0,
    l = c.length; f < l; f++) o(c[f], r);
    f = 0;
    for (l = this.faceVertexUvs[0].length; f < l; f++) t = this.faceVertexUvs[0][f],
    r = t[0].x,
    e = t[1].x,
    c = t[2].x,
    h = Math.max(r, e, c),
    p = Math.min(r, e, c),
    .9 < h && .1 > p && (.2 > r && (t[0].x += 1), .2 > e && (t[1].x += 1), .2 > c && (t[2].x += 1));
    f = 0;
    for (l = this.vertices.length; f < l; f++) this.vertices[f].multiplyScalar(n);
    this.mergeVertices(),
    this.computeFaceNormals(),
    this.boundingSphere = new THREE.Sphere(new THREE.Vector3, n)
},
THREE.PolyhedronGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry,
THREE.DodecahedronGeometry = function(e, t) {
    var n = (1 + Math.sqrt(5)) / 2,
    r = 1 / n;
    THREE.PolyhedronGeometry.call(this, [ - 1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, -r, -n, 0, -r, n, 0, r, -n, 0, r, n, 0, -n, 0, -r, n, 0, -r, -n, 0, r, n, 0, r], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], e, t),
    this.type = "DodecahedronGeometry",
    this.parameters = {
        radius: e,
        detail: t
    }
},
THREE.DodecahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype),
THREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry,
THREE.IcosahedronGeometry = function(e, t) {
    var n = (1 + Math.sqrt(5)) / 2;
    THREE.PolyhedronGeometry.call(this, [ - 1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], e, t),
    this.type = "IcosahedronGeometry",
    this.parameters = {
        radius: e,
        detail: t
    }
},
THREE.IcosahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype),
THREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry,
THREE.OctahedronGeometry = function(e, t) {
    THREE.PolyhedronGeometry.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], e, t),
    this.type = "OctahedronGeometry",
    this.parameters = {
        radius: e,
        detail: t
    }
},
THREE.OctahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype),
THREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry,
THREE.TetrahedronGeometry = function(e, t) {
    THREE.PolyhedronGeometry.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], e, t),
    this.type = "TetrahedronGeometry",
    this.parameters = {
        radius: e,
        detail: t
    }
},
THREE.TetrahedronGeometry.prototype = Object.create(THREE.PolyhedronGeometry.prototype),
THREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry,
THREE.ParametricGeometry = function(e, t, n) {
    THREE.Geometry.call(this),
    this.type = "ParametricGeometry",
    this.parameters = {
        func: e,
        slices: t,
        stacks: n
    };
    var r = this.vertices,
    i = this.faces,
    s = this.faceVertexUvs[0],
    o,
    u,
    a,
    f,
    l = t + 1;
    for (o = 0; o <= n; o++) for (f = o / n, u = 0; u <= t; u++) a = u / t,
    a = e(a, f),
    r.push(a);
    var c, h, p, d;
    for (o = 0; o < n; o++) for (u = 0; u < t; u++) e = o * l + u,
    r = o * l + u + 1,
    f = (o + 1) * l + u + 1,
    a = (o + 1) * l + u,
    c = new THREE.Vector2(u / t, o / n),
    h = new THREE.Vector2((u + 1) / t, o / n),
    p = new THREE.Vector2((u + 1) / t, (o + 1) / n),
    d = new THREE.Vector2(u / t, (o + 1) / n),
    i.push(new THREE.Face3(e, r, a)),
    s.push([c, h, d]),
    i.push(new THREE.Face3(r, f, a)),
    s.push([h.clone(), p, d.clone()]);
    this.computeFaceNormals(),
    this.computeVertexNormals()
},
THREE.ParametricGeometry.prototype = Object.create(THREE.Geometry.prototype),
THREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry,
THREE.WireframeGeometry = function(e) {
    function t(e, t) {
        return e - t
    }
    THREE.BufferGeometry.call(this);
    var n = [0, 0],
    r = {},
    i = ["a", "b", "c"];
    if (e instanceof THREE.Geometry) {
        var s = e.vertices,
        o = e.faces,
        u = 0,
        a = new Uint32Array(6 * o.length);
        e = 0;
        for (var f = o.length; e < f; e++) for (var l = o[e], c = 0; 3 > c; c++) {
            n[0] = l[i[c]],
            n[1] = l[i[(c + 1) % 3]],
            n.sort(t);
            var h = n.toString();
            void 0 === r[h] && (a[2 * u] = n[0], a[2 * u + 1] = n[1], r[h] = !0, u++)
        }
        n = new Float32Array(6 * u),
        e = 0;
        for (f = u; e < f; e++) for (c = 0; 2 > c; c++) r = s[a[2 * e + c]],
        u = 6 * e + 3 * c,
        n[u + 0] = r.x,
        n[u + 1] = r.y,
        n[u + 2] = r.z;
        this.addAttribute("position", new THREE.BufferAttribute(n, 3))
    } else if (e instanceof THREE.BufferGeometry) {
        if (null !== e.index) {
            f = e.index.array,
            s = e.attributes.position,
            i = e.groups,
            u = 0,
            0 === i.length && e.addGroup(0, f.length),
            a = new Uint32Array(2 * f.length),
            o = 0;
            for (l = i.length; o < l; ++o) {
                e = i[o],
                c = e.start,
                h = e.count,
                e = c;
                for (var p = c + h; e < p; e += 3) for (c = 0; 3 > c; c++) n[0] = f[e + c],
                n[1] = f[e + (c + 1) % 3],
                n.sort(t),
                h = n.toString(),
                void 0 === r[h] && (a[2 * u] = n[0], a[2 * u + 1] = n[1], r[h] = !0, u++)
            }
            n = new Float32Array(6 * u),
            e = 0;
            for (f = u; e < f; e++) for (c = 0; 2 > c; c++) u = 6 * e + 3 * c,
            r = a[2 * e + c],
            n[u + 0] = s.getX(r),
            n[u + 1] = s.getY(r),
            n[u + 2] = s.getZ(r)
        } else for (s = e.attributes.position.array, u = s.length / 3, a = u / 3, n = new Float32Array(6 * u), e = 0, f = a; e < f; e++) for (c = 0; 3 > c; c++) u = 18 * e + 6 * c,
        a = 9 * e + 3 * c,
        n[u + 0] = s[a],
        n[u + 1] = s[a + 1],
        n[u + 2] = s[a + 2],
        r = 9 * e + (c + 1) % 3 * 3,
        n[u + 3] = s[r],
        n[u + 4] = s[r + 1],
        n[u + 5] = s[r + 2];
        this.addAttribute("position", new THREE.BufferAttribute(n, 3))
    }
},
THREE.WireframeGeometry.prototype = Object.create(THREE.BufferGeometry.prototype),
THREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry,
THREE.AxisHelper = function(e) {
    e = e || 1;
    var t = new Float32Array([0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e]),
    n = new Float32Array([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1]);
    e = new THREE.BufferGeometry,
    e.addAttribute("position", new THREE.BufferAttribute(t, 3)),
    e.addAttribute("color", new THREE.BufferAttribute(n, 3)),
    t = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    }),
    THREE.LineSegments.call(this, e, t)
},
THREE.AxisHelper.prototype = Object.create(THREE.LineSegments.prototype),
THREE.AxisHelper.prototype.constructor = THREE.AxisHelper,
THREE.ArrowHelper = function() {
    var e = new THREE.Geometry;
    e.vertices.push(new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0));
    var t = new THREE.CylinderGeometry(0, .5, 1, 5, 1);
    return t.translate(0, -0.5, 0),
    function(n, r, i, s, o, u) {
        THREE.Object3D.call(this),
        void 0 === s && (s = 16776960),
        void 0 === i && (i = 1),
        void 0 === o && (o = .2 * i),
        void 0 === u && (u = .2 * o),
        this.position.copy(r),
        this.line = new THREE.Line(e, new THREE.LineBasicMaterial({
            color: s
        })),
        this.line.matrixAutoUpdate = !1,
        this.add(this.line),
        this.cone = new THREE.Mesh(t, new THREE.MeshBasicMaterial({
            color: s
        })),
        this.cone.matrixAutoUpdate = !1,
        this.add(this.cone),
        this.setDirection(n),
        this.setLength(i, o, u)
    }
} (),
THREE.ArrowHelper.prototype = Object.create(THREE.Object3D.prototype),
THREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper,
THREE.ArrowHelper.prototype.setDirection = function() {
    var e = new THREE.Vector3,
    t;
    return function(n) {.99999 < n.y ? this.quaternion.set(0, 0, 0, 1) : -0.99999 > n.y ? this.quaternion.set(1, 0, 0, 0) : (e.set(n.z, 0, -n.x).normalize(), t = Math.acos(n.y), this.quaternion.setFromAxisAngle(e, t))
    }
} (),
THREE.ArrowHelper.prototype.setLength = function(e, t, n) {
    void 0 === t && (t = .2 * e),
    void 0 === n && (n = .2 * t),
    this.line.scale.set(1, Math.max(0, e - t), 1),
    this.line.updateMatrix(),
    this.cone.scale.set(n, t, n),
    this.cone.position.y = e,
    this.cone.updateMatrix()
},
THREE.ArrowHelper.prototype.setColor = function(e) {
    this.line.material.color.set(e),
    this.cone.material.color.set(e)
},
THREE.BoxHelper = function(e) {
    var t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
    n = new Float32Array(24),
    r = new THREE.BufferGeometry;
    r.setIndex(new THREE.BufferAttribute(t, 1)),
    r.addAttribute("position", new THREE.BufferAttribute(n, 3)),
    THREE.LineSegments.call(this, r, new THREE.LineBasicMaterial({
        color: 16776960
    })),
    void 0 !== e && this.update(e)
},
THREE.BoxHelper.prototype = Object.create(THREE.LineSegments.prototype),
THREE.BoxHelper.prototype.constructor = THREE.BoxHelper,
THREE.BoxHelper.prototype.update = function() {
    var e = new THREE.Box3;
    return function(t) {
        e.setFromObject(t);
        if (!e.isEmpty()) {
            t = e.min;
            var n = e.max,
            r = this.geometry.attributes.position,
            i = r.array;
            i[0] = n.x,
            i[1] = n.y,
            i[2] = n.z,
            i[3] = t.x,
            i[4] = n.y,
            i[5] = n.z,
            i[6] = t.x,
            i[7] = t.y,
            i[8] = n.z,
            i[9] = n.x,
            i[10] = t.y,
            i[11] = n.z,
            i[12] = n.x,
            i[13] = n.y,
            i[14] = t.z,
            i[15] = t.x,
            i[16] = n.y,
            i[17] = t.z,
            i[18] = t.x,
            i[19] = t.y,
            i[20] = t.z,
            i[21] = n.x,
            i[22] = t.y,
            i[23] = t.z,
            r.needsUpdate = !0,
            this.geometry.computeBoundingSphere()
        }
    }
} (),
THREE.BoundingBoxHelper = function(e, t) {
    var n = void 0 !== t ? t: 8947848;
    this.object = e,
    this.box = new THREE.Box3,
    THREE.Mesh.call(this, new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({
        color: n,
        wireframe: !0
    }))
},
THREE.BoundingBoxHelper.prototype = Object.create(THREE.Mesh.prototype),
THREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper,
THREE.BoundingBoxHelper.prototype.update = function() {
    this.box.setFromObject(this.object),
    this.box.size(this.scale),
    this.box.center(this.position)
},
THREE.CameraHelper = function(e) {
    function t(e, t, r) {
        n(e, r),
        n(t, r)
    }
    function n(e, t) {
        r.vertices.push(new THREE.Vector3),
        r.colors.push(new THREE.Color(t)),
        void 0 === s[e] && (s[e] = []),
        s[e].push(r.vertices.length - 1)
    }
    var r = new THREE.Geometry,
    i = new THREE.LineBasicMaterial({
        color: 16777215,
        vertexColors: THREE.FaceColors
    }),
    s = {};
    t("n1", "n2", 16755200),
    t("n2", "n4", 16755200),
    t("n4", "n3", 16755200),
    t("n3", "n1", 16755200),
    t("f1", "f2", 16755200),
    t("f2", "f4", 16755200),
    t("f4", "f3", 16755200),
    t("f3", "f1", 16755200),
    t("n1", "f1", 16755200),
    t("n2", "f2", 16755200),
    t("n3", "f3", 16755200),
    t("n4", "f4", 16755200),
    t("p", "n1", 16711680),
    t("p", "n2", 16711680),
    t("p", "n3", 16711680),
    t("p", "n4", 16711680),
    t("u1", "u2", 43775),
    t("u2", "u3", 43775),
    t("u3", "u1", 43775),
    t("c", "t", 16777215),
    t("p", "c", 3355443),
    t("cn1", "cn2", 3355443),
    t("cn3", "cn4", 3355443),
    t("cf1", "cf2", 3355443),
    t("cf3", "cf4", 3355443),
    THREE.LineSegments.call(this, r, i),
    this.camera = e,
    this.camera.updateProjectionMatrix(),
    this.matrix = e.matrixWorld,
    this.matrixAutoUpdate = !1,
    this.pointMap = s,
    this.update()
},
THREE.CameraHelper.prototype = Object.create(THREE.LineSegments.prototype),
THREE.CameraHelper.prototype.constructor = THREE.CameraHelper,
THREE.CameraHelper.prototype.update = function() {
    function e(e, s, o, u) {
        r.set(s, o, u).unproject(i),
        e = n[e];
        if (void 0 !== e) for (s = 0, o = e.length; s < o; s++) t.vertices[e[s]].copy(r)
    }
    var t, n, r = new THREE.Vector3,
    i = new THREE.Camera;
    return function() {
        t = this.geometry,
        n = this.pointMap,
        i.projectionMatrix.copy(this.camera.projectionMatrix),
        e("c", 0, 0, -1),
        e("t", 0, 0, 1),
        e("n1", -1, -1, -1),
        e("n2", 1, -1, -1),
        e("n3", -1, 1, -1),
        e("n4", 1, 1, -1),
        e("f1", -1, -1, 1),
        e("f2", 1, -1, 1),
        e("f3", -1, 1, 1),
        e("f4", 1, 1, 1),
        e("u1", .7, 1.1, -1),
        e("u2", -0.7, 1.1, -1),
        e("u3", 0, 2, -1),
        e("cf1", -1, 0, 1),
        e("cf2", 1, 0, 1),
        e("cf3", 0, -1, 1),
        e("cf4", 0, 1, 1),
        e("cn1", -1, 0, -1),
        e("cn2", 1, 0, -1),
        e("cn3", 0, -1, -1),
        e("cn4", 0, 1, -1),
        t.verticesNeedUpdate = !0
    }
} (),
THREE.DirectionalLightHelper = function(e, t) {
    THREE.Object3D.call(this),
    this.light = e,
    this.light.updateMatrixWorld(),
    this.matrix = e.matrixWorld,
    this.matrixAutoUpdate = !1,
    t = t || 1;
    var n = new THREE.Geometry;
    n.vertices.push(new THREE.Vector3( - t, t, 0), new THREE.Vector3(t, t, 0), new THREE.Vector3(t, -t, 0), new THREE.Vector3( - t, -t, 0), new THREE.Vector3( - t, t, 0));
    var r = new THREE.LineBasicMaterial({
        fog: !1
    });
    r.color.copy(this.light.color).multiplyScalar(this.light.intensity),
    this.lightPlane = new THREE.Line(n, r),
    this.add(this.lightPlane),
    n = new THREE.Geometry,
    n.vertices.push(new THREE.Vector3, new THREE.Vector3),
    r = new THREE.LineBasicMaterial({
        fog: !1
    }),
    r.color.copy(this.light.color).multiplyScalar(this.light.intensity),
    this.targetLine = new THREE.Line(n, r),
    this.add(this.targetLine),
    this.update()
},
THREE.DirectionalLightHelper.prototype = Object.create(THREE.Object3D.prototype),
THREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper,
THREE.DirectionalLightHelper.prototype.dispose = function() {
    this.lightPlane.geometry.dispose(),
    this.lightPlane.material.dispose(),
    this.targetLine.geometry.dispose(),
    this.targetLine.material.dispose()
},
THREE.DirectionalLightHelper.prototype.update = function() {
    var e = new THREE.Vector3,
    t = new THREE.Vector3,
    n = new THREE.Vector3;
    return function() {
        e.setFromMatrixPosition(this.light.matrixWorld),
        t.setFromMatrixPosition(this.light.target.matrixWorld),
        n.subVectors(t, e),
        this.lightPlane.lookAt(n),
        this.lightPlane.material.color.copy(this.light.color).multiplyScalar(this.light.intensity),
        this.targetLine.geometry.vertices[1].copy(n),
        this.targetLine.geometry.verticesNeedUpdate = !0,
        this.targetLine.material.color.copy(this.lightPlane.material.color)
    }
} (),
THREE.EdgesHelper = function(e, t, n) {
    t = void 0 !== t ? t: 16777215,
    THREE.LineSegments.call(this, new THREE.EdgesGeometry(e.geometry, n), new THREE.LineBasicMaterial({
        color: t
    })),
    this.matrix = e.matrixWorld,
    this.matrixAutoUpdate = !1
},
THREE.EdgesHelper.prototype = Object.create(THREE.LineSegments.prototype),
THREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper,
THREE.FaceNormalsHelper = function(e, t, n, r) {
    this.object = e,
    this.size = void 0 !== t ? t: 1,
    e = void 0 !== n ? n: 16776960,
    r = void 0 !== r ? r: 1,
    t = 0,
    n = this.object.geometry,
    n instanceof THREE.Geometry ? t = n.faces.length: console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."),
    n = new THREE.BufferGeometry,
    t = new THREE.Float32Attribute(6 * t, 3),
    n.addAttribute("position", t),
    THREE.LineSegments.call(this, n, new THREE.LineBasicMaterial({
        color: e,
        linewidth: r
    })),
    this.matrixAutoUpdate = !1,
    this.update()
},
THREE.FaceNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype),
THREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper,
THREE.FaceNormalsHelper.prototype.update = function() {
    var e = new THREE.Vector3,
    t = new THREE.Vector3,
    n = new THREE.Matrix3;
    return function() {
        this.object.updateMatrixWorld(!0),
        n.getNormalMatrix(this.object.matrixWorld);
        for (var r = this.object.matrixWorld,
        i = this.geometry.attributes.position,
        s = this.object.geometry,
        o = s.vertices,
        s = s.faces,
        u = 0,
        f = 0,
        l = s.length; f < l; f++) {
            var h = s[f],
            p = h.normal;
            e.copy(o[h.a]).add(o[h.b]).add(o[h.c]).divideScalar(3).applyMatrix4(r),
            t.copy(p).applyMatrix3(n).normalize().multiplyScalar(this.size).add(e),
            i.setXYZ(u, e.x, e.y, e.z),
            u += 1,
            i.setXYZ(u, t.x, t.y, t.z),
            u += 1
        }
        return i.needsUpdate = !0,
        this
    }
} (),
THREE.GridHelper = function(e, t) {
    var n = new THREE.Geometry,
    r = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors
    });
    this.color1 = new THREE.Color(4473924),
    this.color2 = new THREE.Color(8947848);
    for (var i = -e; i <= e; i += t) {
        n.vertices.push(new THREE.Vector3( - e, 0, i), new THREE.Vector3(e, 0, i), new THREE.Vector3(i, 0, -e), new THREE.Vector3(i, 0, e));
        var s = 0 === i ? this.color1: this.color2;
        n.colors.push(s, s, s, s)
    }
    THREE.LineSegments.call(this, n, r)
},
THREE.GridHelper.prototype = Object.create(THREE.LineSegments.prototype),
THREE.GridHelper.prototype.constructor = THREE.GridHelper,
THREE.GridHelper.prototype.setColors = function(e, t) {
    this.color1.set(e),
    this.color2.set(t),
    this.geometry.colorsNeedUpdate = !0
},
THREE.HemisphereLightHelper = function(e, t) {
    THREE.Object3D.call(this),
    this.light = e,
    this.light.updateMatrixWorld(),
    this.matrix = e.matrixWorld,
    this.matrixAutoUpdate = !1,
    this.colors = [new THREE.Color, new THREE.Color];
    var n = new THREE.SphereGeometry(t, 4, 2);
    n.rotateX( - Math.PI / 2);
    for (var r = 0; 8 > r; r++) n.faces[r].color = this.colors[4 > r ? 0 : 1];
    r = new THREE.MeshBasicMaterial({
        vertexColors: THREE.FaceColors,
        wireframe: !0
    }),
    this.lightSphere = new THREE.Mesh(n, r),
    this.add(this.lightSphere),
    this.update()
},
THREE.HemisphereLightHelper.prototype = Object.create(THREE.Object3D.prototype),
THREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper,
THREE.HemisphereLightHelper.prototype.dispose = function() {
    this.lightSphere.geometry.dispose(),
    this.lightSphere.material.dispose()
},
THREE.HemisphereLightHelper.prototype.update = function() {
    var e = new THREE.Vector3;
    return function() {
        this.colors[0].copy(this.light.color).multiplyScalar(this.light.intensity),
        this.colors[1].copy(this.light.groundColor).multiplyScalar(this.light.intensity),
        this.lightSphere.lookAt(e.setFromMatrixPosition(this.light.matrixWorld).negate()),
        this.lightSphere.geometry.colorsNeedUpdate = !0
    }
} (),
THREE.PointLightHelper = function(e, t) {
    this.light = e,
    this.light.updateMatrixWorld();
    var n = new THREE.SphereGeometry(t, 4, 2),
    r = new THREE.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    r.color.copy(this.light.color).multiplyScalar(this.light.intensity),
    THREE.Mesh.call(this, n, r),
    this.matrix = this.light.matrixWorld,
    this.matrixAutoUpdate = !1
},
THREE.PointLightHelper.prototype = Object.create(THREE.Mesh.prototype),
THREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper,
THREE.PointLightHelper.prototype.dispose = function() {
    this.geometry.dispose(),
    this.material.dispose()
},
THREE.PointLightHelper.prototype.update = function() {
    this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
},
THREE.SkeletonHelper = function(e) {
    this.bones = this.getBoneList(e);
    for (var t = new THREE.Geometry,
    n = 0; n < this.bones.length; n++) this.bones[n].parent instanceof THREE.Bone && (t.vertices.push(new THREE.Vector3), t.vertices.push(new THREE.Vector3), t.colors.push(new THREE.Color(0, 0, 1)), t.colors.push(new THREE.Color(0, 1, 0)));
    t.dynamic = !0,
    n = new THREE.LineBasicMaterial({
        vertexColors: THREE.VertexColors,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0
    }),
    THREE.LineSegments.call(this, t, n),
    this.root = e,
    this.matrix = e.matrixWorld,
    this.matrixAutoUpdate = !1,
    this.update()
},
THREE.SkeletonHelper.prototype = Object.create(THREE.LineSegments.prototype),
THREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper,
THREE.SkeletonHelper.prototype.getBoneList = function(e) {
    var t = [];
    e instanceof THREE.Bone && t.push(e);
    for (var n = 0; n < e.children.length; n++) t.push.apply(t, this.getBoneList(e.children[n]));
    return t
},
THREE.SkeletonHelper.prototype.update = function() {
    for (var e = this.geometry,
    t = (new THREE.Matrix4).getInverse(this.root.matrixWorld), n = new THREE.Matrix4, r = 0, i = 0; i < this.bones.length; i++) {
        var s = this.bones[i];
        s.parent instanceof THREE.Bone && (n.multiplyMatrices(t, s.matrixWorld), e.vertices[r].setFromMatrixPosition(n), n.multiplyMatrices(t, s.parent.matrixWorld), e.vertices[r + 1].setFromMatrixPosition(n), r += 2)
    }
    e.verticesNeedUpdate = !0,
    e.computeBoundingSphere()
},
THREE.SpotLightHelper = function(e) {
    THREE.Object3D.call(this),
    this.light = e,
    this.light.updateMatrixWorld(),
    this.matrix = e.matrixWorld,
    this.matrixAutoUpdate = !1,
    e = new THREE.CylinderGeometry(0, 1, 1, 8, 1, !0),
    e.translate(0, -0.5, 0),
    e.rotateX( - Math.PI / 2);
    var t = new THREE.MeshBasicMaterial({
        wireframe: !0,
        fog: !1
    });
    this.cone = new THREE.Mesh(e, t),
    this.add(this.cone),
    this.update()
},
THREE.SpotLightHelper.prototype = Object.create(THREE.Object3D.prototype),
THREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper,
THREE.SpotLightHelper.prototype.dispose = function() {
    this.cone.geometry.dispose(),
    this.cone.material.dispose()
},
THREE.SpotLightHelper.prototype.update = function() {
    var e = new THREE.Vector3,
    t = new THREE.Vector3;
    return function() {
        var n = this.light.distance ? this.light.distance: 1e4,
        r = n * Math.tan(this.light.angle);
        this.cone.scale.set(r, r, n),
        e.setFromMatrixPosition(this.light.matrixWorld),
        t.setFromMatrixPosition(this.light.target.matrixWorld),
        this.cone.lookAt(t.sub(e)),
        this.cone.material.color.copy(this.light.color).multiplyScalar(this.light.intensity)
    }
} (),
THREE.VertexNormalsHelper = function(e, t, n, r) {
    this.object = e,
    this.size = void 0 !== t ? t: 1,
    e = void 0 !== n ? n: 16711680,
    r = void 0 !== r ? r: 1,
    t = 0,
    n = this.object.geometry,
    n instanceof THREE.Geometry ? t = 3 * n.faces.length: n instanceof THREE.BufferGeometry && (t = n.attributes.normal.count),
    n = new THREE.BufferGeometry,
    t = new THREE.Float32Attribute(6 * t, 3),
    n.addAttribute("position", t),
    THREE.LineSegments.call(this, n, new THREE.LineBasicMaterial({
        color: e,
        linewidth: r
    })),
    this.matrixAutoUpdate = !1,
    this.update()
},
THREE.VertexNormalsHelper.prototype = Object.create(THREE.LineSegments.prototype),
THREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper,
THREE.VertexNormalsHelper.prototype.update = function() {
    var e = new THREE.Vector3,
    t = new THREE.Vector3,
    n = new THREE.Matrix3;
    return function() {
        var r = ["a", "b", "c"];
        this.object.updateMatrixWorld(!0),
        n.getNormalMatrix(this.object.matrixWorld);
        var i = this.object.matrixWorld,
        s = this.geometry.attributes.position,
        o = this.object.geometry;
        if (o instanceof THREE.Geometry) for (var u = o.vertices,
        f = o.faces,
        l = o = 0,
        h = f.length; l < h; l++) for (var p = f[l], d = 0, v = p.vertexNormals.length; d < v; d++) {
            var m = p.vertexNormals[d];
            e.copy(u[p[r[d]]]).applyMatrix4(i),
            t.copy(m).applyMatrix3(n).normalize().multiplyScalar(this.size).add(e),
            s.setXYZ(o, e.x, e.y, e.z),
            o += 1,
            s.setXYZ(o, t.x, t.y, t.z),
            o += 1
        } else if (o instanceof THREE.BufferGeometry) for (r = o.attributes.position, u = o.attributes.normal, d = o = 0, v = r.count; d < v; d++) e.set(r.getX(d), r.getY(d), r.getZ(d)).applyMatrix4(i),
        t.set(u.getX(d), u.getY(d), u.getZ(d)),
        t.applyMatrix3(n).normalize().multiplyScalar(this.size).add(e),
        s.setXYZ(o, e.x, e.y, e.z),
        o += 1,
        s.setXYZ(o, t.x, t.y, t.z),
        o += 1;
        return s.needsUpdate = !0,
        this
    }
} (),
THREE.WireframeHelper = function(e, t) {
    var n = void 0 !== t ? t: 16777215;
    THREE.LineSegments.call(this, new THREE.WireframeGeometry(e.geometry), new THREE.LineBasicMaterial({
        color: n
    })),
    this.matrix = e.matrixWorld,
    this.matrixAutoUpdate = !1
},
THREE.WireframeHelper.prototype = Object.create(THREE.LineSegments.prototype),
THREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper,
THREE.ImmediateRenderObject = function(e) {
    THREE.Object3D.call(this),
    this.material = e,
    this.render = function(e) {}
},
THREE.ImmediateRenderObject.prototype = Object.create(THREE.Object3D.prototype),
THREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject,
THREE.MorphBlendMesh = function(e, t) {
    THREE.Mesh.call(this, e, t),
    this.animationsMap = {},
    this.animationsList = [];
    var n = this.geometry.morphTargets.length;
    this.createAnimation("__default", 0, n - 1, n / 1),
    this.setAnimationWeight("__default", 1)
},
THREE.MorphBlendMesh.prototype = Object.create(THREE.Mesh.prototype),
THREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh,
THREE.MorphBlendMesh.prototype.createAnimation = function(e, t, n, r) {
    t = {
        start: t,
        end: n,
        length: n - t + 1,
        fps: r,
        duration: (n - t) / r,
        lastFrame: 0,
        currentFrame: 0,
        active: !1,
        time: 0,
        direction: 1,
        weight: 1,
        directionBackwards: !1,
        mirroredLoop: !1
    },
    this.animationsMap[e] = t,
    this.animationsList.push(t)
},
THREE.MorphBlendMesh.prototype.autoCreateAnimations = function(e) {
    for (var t = /([a-z]+)_?(\d+)/i,
    n, r = {},
    i = this.geometry,
    s = 0,
    o = i.morphTargets.length; s < o; s++) {
        var u = i.morphTargets[s].name.match(t);
        if (u && 1 < u.length) {
            var a = u[1];
            r[a] || (r[a] = {
                start: Infinity,
                end: -Infinity
            }),
            u = r[a],
            s < u.start && (u.start = s),
            s > u.end && (u.end = s),
            n || (n = a)
        }
    }
    for (a in r) u = r[a],
    this.createAnimation(a, u.start, u.end, e);
    this.firstAnimation = n
},
THREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function(e) {
    if (e = this.animationsMap[e]) e.direction = 1,
    e.directionBackwards = !1
},
THREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function(e) {
    if (e = this.animationsMap[e]) e.direction = -1,
    e.directionBackwards = !0
},
THREE.MorphBlendMesh.prototype.setAnimationFPS = function(e, t) {
    var n = this.animationsMap[e];
    n && (n.fps = t, n.duration = (n.end - n.start) / n.fps)
},
THREE.MorphBlendMesh.prototype.setAnimationDuration = function(e, t) {
    var n = this.animationsMap[e];
    n && (n.duration = t, n.fps = (n.end - n.start) / n.duration)
},
THREE.MorphBlendMesh.prototype.setAnimationWeight = function(e, t) {
    var n = this.animationsMap[e];
    n && (n.weight = t)
},
THREE.MorphBlendMesh.prototype.setAnimationTime = function(e, t) {
    var n = this.animationsMap[e];
    n && (n.time = t)
},
THREE.MorphBlendMesh.prototype.getAnimationTime = function(e) {
    var t = 0;
    if (e = this.animationsMap[e]) t = e.time;
    return t
},
THREE.MorphBlendMesh.prototype.getAnimationDuration = function(e) {
    var t = -1;
    if (e = this.animationsMap[e]) t = e.duration;
    return t
},
THREE.MorphBlendMesh.prototype.playAnimation = function(e) {
    var t = this.animationsMap[e];
    t ? (t.time = 0, t.active = !0) : console.warn("THREE.MorphBlendMesh: animation[" + e + "] undefined in .playAnimation()")
},
THREE.MorphBlendMesh.prototype.stopAnimation = function(e) {
    if (e = this.animationsMap[e]) e.active = !1
},
THREE.MorphBlendMesh.prototype.update = function(e) {
    for (var t = 0,
    n = this.animationsList.length; t < n; t++) {
        var r = this.animationsList[t];
        if (r.active) {
            var i = r.duration / r.length;
            r.time += r.direction * e;
            if (r.mirroredLoop) {
                if (r.time > r.duration || 0 > r.time) r.direction *= -1,
                r.time > r.duration && (r.time = r.duration, r.directionBackwards = !0),
                0 > r.time && (r.time = 0, r.directionBackwards = !1)
            } else r.time %= r.duration,
            0 > r.time && (r.time += r.duration);
            var s = r.start + THREE.Math.clamp(Math.floor(r.time / i), 0, r.length - 1),
            o = r.weight;
            s !== r.currentFrame && (this.morphTargetInfluences[r.lastFrame] = 0, this.morphTargetInfluences[r.currentFrame] = 1 * o, this.morphTargetInfluences[s] = 0, r.lastFrame = r.currentFrame, r.currentFrame = s),
            i = r.time % i / i,
            r.directionBackwards && (i = 1 - i),
            r.currentFrame !== r.lastFrame ? (this.morphTargetInfluences[r.currentFrame] = i * o, this.morphTargetInfluences[r.lastFrame] = (1 - i) * o) : this.morphTargetInfluences[r.currentFrame] = o
        }
    }
},
THREE.RenderableObject = function() {
    this.id = 0,
    this.object = null,
    this.z = 0,
    this.renderOrder = 0
},
THREE.RenderableFace = function() {
    this.id = 0,
    this.v1 = new THREE.RenderableVertex,
    this.v2 = new THREE.RenderableVertex,
    this.v3 = new THREE.RenderableVertex,
    this.normalModel = new THREE.Vector3,
    this.vertexNormalsModel = [new THREE.Vector3, new THREE.Vector3, new THREE.Vector3],
    this.vertexNormalsLength = 0,
    this.color = new THREE.Color,
    this.material = null,
    this.uvs = [new THREE.Vector2, new THREE.Vector2, new THREE.Vector2],
    this.z = 0,
    this.renderOrder = 0
},
THREE.RenderableVertex = function() {
    this.position = new THREE.Vector3,
    this.positionWorld = new THREE.Vector3,
    this.positionScreen = new THREE.Vector4,
    this.visible = !0
},
THREE.RenderableVertex.prototype.copy = function(e) {
    this.positionWorld.copy(e.positionWorld),
    this.positionScreen.copy(e.positionScreen)
},
THREE.RenderableLine = function() {
    this.id = 0,
    this.v1 = new THREE.RenderableVertex,
    this.v2 = new THREE.RenderableVertex,
    this.vertexColors = [new THREE.Color, new THREE.Color],
    this.material = null,
    this.z = 0,
    this.renderOrder = 0
},
THREE.RenderableSprite = function() {
    this.id = 0,
    this.object = null,
    this.x = 0,
    this.y = 0,
    this.z = 0,
    this.rotation = 0,
    this.scale = new THREE.Vector2,
    this.material = null,
    this.renderOrder = 0
},
THREE.Projector = function() {
    function j() {
        if (t === r) {
            var e = new THREE.RenderableObject;
            return n.push(e),
            r++,
            t++,
            e
        }
        return n[t++]
    }
    function F() {
        if (s === u) {
            var e = new THREE.RenderableVertex;
            return o.push(e),
            u++,
            s++,
            e
        }
        return o[s++]
    }
    function I() {
        if (f === c) {
            var e = new THREE.RenderableFace;
            return l.push(e),
            c++,
            f++,
            e
        }
        return l[f++]
    }
    function q() {
        if (p === v) {
            var e = new THREE.RenderableLine;
            return d.push(e),
            v++,
            p++,
            e
        }
        return d[p++]
    }
    function R() {
        if (g === b) {
            var e = new THREE.RenderableSprite;
            return y.push(e),
            b++,
            g++,
            e
        }
        return y[g++]
    }
    function U(e, t) {
        return e.renderOrder !== t.renderOrder ? e.renderOrder - t.renderOrder: e.z !== t.z ? t.z - e.z: e.id !== t.id ? e.id - t.id: 0
    }
    function z(e, t) {
        var n = 0,
        r = 1,
        i = e.z + e.w,
        s = t.z + t.w,
        o = -e.z + e.w,
        u = -t.z + t.w;
        return i >= 0 && s >= 0 && o >= 0 && u >= 0 ? !0 : i < 0 && s < 0 || o < 0 && u < 0 ? !1 : (i < 0 ? n = Math.max(n, i / (i - s)) : s < 0 && (r = Math.min(r, i / (i - s))), o < 0 ? n = Math.max(n, o / (o - u)) : u < 0 && (r = Math.min(r, o / (o - u))), r < n ? !1 : (e.lerp(t, n), t.lerp(e, 1 - r), !0))
    }
    var e, t, n = [],
    r = 0,
    i,
    s,
    o = [],
    u = 0,
    a,
    f,
    l = [],
    c = 0,
    h,
    p,
    d = [],
    v = 0,
    m,
    g,
    y = [],
    b = 0,
    w = {
        objects: [],
        lights: [],
        elements: []
    },
    E = new THREE.Vector3,
    S = new THREE.Vector4,
    x = new THREE.Box3(new THREE.Vector3( - 1, -1, -1), new THREE.Vector3(1, 1, 1)),
    T = new THREE.Box3,
    N = new Array(3),
    C = new Array(4),
    k = new THREE.Matrix4,
    L = new THREE.Matrix4,
    A,
    O = new THREE.Matrix4,
    M = new THREE.Matrix3,
    _ = new THREE.Frustum,
    D = new THREE.Vector4,
    P = new THREE.Vector4;
    this.projectVector = function(e, t) {
        console.warn("THREE.Projector: .projectVector() is now vector.project()."),
        e.project(t)
    },
    this.unprojectVector = function(e, t) {
        console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."),
        e.unproject(t)
    },
    this.pickingRay = function(e, t) {
        console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
    };
    var H = function() {
        function u(i) {
            n = i,
            r = n.material,
            s.getNormalMatrix(n.matrixWorld),
            e.length = 0,
            t.length = 0
        }
        function f(e) {
            var t = e.position,
            n = e.positionWorld,
            r = e.positionScreen;
            n.copy(t).applyMatrix4(A),
            r.copy(n).applyMatrix4(L);
            var i = 1 / r.w;
            r.x *= i,
            r.y *= i,
            r.z *= i,
            e.visible = r.x >= -1 && r.x <= 1 && r.y >= -1 && r.y <= 1 && r.z >= -1 && r.z <= 1
        }
        function l(e, t, n) {
            i = F(),
            i.position.set(e, t, n),
            f(i)
        }
        function c(t, n, r) {
            e.push(t, n, r)
        }
        function p(e, n) {
            t.push(e, n)
        }
        function d(e, t, n) {
            return e.visible === !0 || t.visible === !0 || n.visible === !0 ? !0 : (N[0] = e.positionScreen, N[1] = t.positionScreen, N[2] = n.positionScreen, x.intersectsBox(T.setFromPoints(N)))
        }
        function v(e, t, n) {
            return (n.positionScreen.x - e.positionScreen.x) * (t.positionScreen.y - e.positionScreen.y) - (n.positionScreen.y - e.positionScreen.y) * (t.positionScreen.x - e.positionScreen.x) < 0
        }
        function m(e, t) {
            var r = o[e],
            i = o[t];
            h = q(),
            h.id = n.id,
            h.v1.copy(r),
            h.v2.copy(i),
            h.z = (r.positionScreen.z + i.positionScreen.z) / 2,
            h.renderOrder = n.renderOrder,
            h.material = n.material,
            w.elements.push(h)
        }
        function g(i, u, f) {
            var l = o[i],
            c = o[u],
            h = o[f];
            if (d(l, c, h) === !1) return;
            if (r.side === THREE.DoubleSide || v(l, c, h) === !0) {
                a = I(),
                a.id = n.id,
                a.v1.copy(l),
                a.v2.copy(c),
                a.v3.copy(h),
                a.z = (l.positionScreen.z + c.positionScreen.z + h.positionScreen.z) / 3,
                a.renderOrder = n.renderOrder,
                a.normalModel.fromArray(e, i * 3),
                a.normalModel.applyMatrix3(s).normalize();
                for (var p = 0; p < 3; p++) {
                    var m = a.vertexNormalsModel[p];
                    m.fromArray(e, arguments[p] * 3),
                    m.applyMatrix3(s).normalize();
                    var g = a.uvs[p];
                    g.fromArray(t, arguments[p] * 2)
                }
                a.vertexNormalsLength = 3,
                a.material = n.material,
                w.elements.push(a)
            }
        }
        var e = [],
        t = [],
        n = null,
        r = null,
        s = new THREE.Matrix3;
        return {
            setObject: u,
            projectVertex: f,
            checkTriangleVisibility: d,
            checkBackfaceCulling: v,
            pushVertex: l,
            pushNormal: c,
            pushUv: p,
            pushLine: m,
            pushTriangle: g
        }
    },
    B = new H;
    this.projectScene = function(n, r, i, u) {
        f = 0,
        p = 0,
        g = 0,
        w.elements.length = 0,
        n.autoUpdate === !0 && n.updateMatrixWorld(),
        r.parent === null && r.updateMatrixWorld(),
        k.copy(r.matrixWorldInverse.getInverse(r.matrixWorld)),
        L.multiplyMatrices(r.projectionMatrix, k),
        _.setFromMatrix(L),
        t = 0,
        w.objects.length = 0,
        w.lights.length = 0,
        n.traverseVisible(function(t) {
            if (t instanceof THREE.Light) w.lights.push(t);
            else if (t instanceof THREE.Mesh || t instanceof THREE.Line || t instanceof THREE.Sprite) {
                var n = t.material;
                if (n.visible === !1) return;
                if (t.frustumCulled === !1 || _.intersectsObject(t) === !0) e = j(),
                e.id = t.id,
                e.object = t,
                E.setFromMatrixPosition(t.matrixWorld),
                E.applyProjection(L),
                e.z = E.z,
                e.renderOrder = t.renderOrder,
                w.objects.push(e)
            }
        }),
        i === !0 && w.objects.sort(U);
        for (var l = 0,
        c = w.objects.length; l < c; l++) {
            var d = w.objects[l].object,
            v = d.geometry;
            B.setObject(d),
            A = d.matrixWorld,
            s = 0;
            if (d instanceof THREE.Mesh) {
                if (v instanceof THREE.BufferGeometry) {
                    var y = v.attributes,
                    b = v.groups;
                    if (y.position === undefined) continue;
                    var x = y.position.array;
                    for (var T = 0,
                    N = x.length; T < N; T += 3) B.pushVertex(x[T], x[T + 1], x[T + 2]);
                    if (y.normal !== undefined) {
                        var C = y.normal.array;
                        for (var T = 0,
                        N = C.length; T < N; T += 3) B.pushNormal(C[T], C[T + 1], C[T + 2])
                    }
                    if (y.uv !== undefined) {
                        var H = y.uv.array;
                        for (var T = 0,
                        N = H.length; T < N; T += 2) B.pushUv(H[T], H[T + 1])
                    }
                    if (v.index !== null) {
                        var W = v.index.array;
                        if (b.length > 0) for (var l = 0; l < b.length; l++) {
                            var X = b[l];
                            for (var T = X.start,
                            N = X.start + X.count; T < N; T += 3) B.pushTriangle(W[T], W[T + 1], W[T + 2])
                        } else for (var T = 0,
                        N = W.length; T < N; T += 3) B.pushTriangle(W[T], W[T + 1], W[T + 2])
                    } else for (var T = 0,
                    N = x.length / 3; T < N; T += 3) B.pushTriangle(T, T + 1, T + 2)
                } else if (v instanceof THREE.Geometry) {
                    var V = v.vertices,
                    $ = v.faces,
                    J = v.faceVertexUvs[0];
                    M.getNormalMatrix(A);
                    var K = d.material,
                    Q = K instanceof THREE.MultiMaterial,
                    G = Q === !0 ? d.material: null;
                    for (var Y = 0,
                    Z = V.length; Y < Z; Y++) {
                        var et = V[Y];
                        E.copy(et);
                        if (K.morphTargets === !0) {
                            var tt = v.morphTargets,
                            nt = d.morphTargetInfluences;
                            for (var rt = 0,
                            it = tt.length; rt < it; rt++) {
                                var st = nt[rt];
                                if (st === 0) continue;
                                var ot = tt[rt],
                                ut = ot.vertices[Y];
                                E.x += (ut.x - et.x) * st,
                                E.y += (ut.y - et.y) * st,
                                E.z += (ut.z - et.z) * st
                            }
                        }
                        B.pushVertex(E.x, E.y, E.z)
                    }
                    for (var at = 0,
                    ft = $.length; at < ft; at++) {
                        var lt = $[at];
                        K = Q === !0 ? G.materials[lt.materialIndex] : d.material;
                        if (K === undefined) continue;
                        var ct = K.side,
                        ht = o[lt.a],
                        pt = o[lt.b],
                        dt = o[lt.c];
                        if (B.checkTriangleVisibility(ht, pt, dt) === !1) continue;
                        var vt = B.checkBackfaceCulling(ht, pt, dt);
                        if (ct !== THREE.DoubleSide) {
                            if (ct === THREE.FrontSide && vt === !1) continue;
                            if (ct === THREE.BackSide && vt === !0) continue
                        }
                        a = I(),
                        a.id = d.id,
                        a.v1.copy(ht),
                        a.v2.copy(pt),
                        a.v3.copy(dt),
                        a.normalModel.copy(lt.normal),
                        vt === !1 && (ct === THREE.BackSide || ct === THREE.DoubleSide) && a.normalModel.negate(),
                        a.normalModel.applyMatrix3(M).normalize();
                        var mt = lt.vertexNormals;
                        for (var gt = 0,
                        yt = Math.min(mt.length, 3); gt < yt; gt++) {
                            var bt = a.vertexNormalsModel[gt];
                            bt.copy(mt[gt]),
                            vt === !1 && (ct === THREE.BackSide || ct === THREE.DoubleSide) && bt.negate(),
                            bt.applyMatrix3(M).normalize()
                        }
                        a.vertexNormalsLength = mt.length;
                        var wt = J[at];
                        if (wt !== undefined) for (var Et = 0; Et < 3; Et++) a.uvs[Et].copy(wt[Et]);
                        a.color = lt.color,
                        a.material = K,
                        a.z = (ht.positionScreen.z + pt.positionScreen.z + dt.positionScreen.z) / 3,
                        a.renderOrder = d.renderOrder,
                        w.elements.push(a)
                    }
                }
            } else if (d instanceof THREE.Line) {
                if (v instanceof THREE.BufferGeometry) {
                    var y = v.attributes;
                    if (y.position !== undefined) {
                        var x = y.position.array;
                        for (var T = 0,
                        N = x.length; T < N; T += 3) B.pushVertex(x[T], x[T + 1], x[T + 2]);
                        if (v.index !== null) {
                            var W = v.index.array;
                            for (var T = 0,
                            N = W.length; T < N; T += 2) B.pushLine(W[T], W[T + 1])
                        } else {
                            var St = d instanceof THREE.LineSegments ? 2 : 1;
                            for (var T = 0,
                            N = x.length / 3 - 1; T < N; T += St) B.pushLine(T, T + 1)
                        }
                    }
                } else if (v instanceof THREE.Geometry) {
                    O.multiplyMatrices(L, A);
                    var V = d.geometry.vertices;
                    if (V.length === 0) continue;
                    ht = F(),
                    ht.positionScreen.copy(V[0]).applyMatrix4(O);
                    var St = d instanceof THREE.LineSegments ? 2 : 1;
                    for (var Y = 1,
                    Z = V.length; Y < Z; Y++) {
                        ht = F(),
                        ht.positionScreen.copy(V[Y]).applyMatrix4(O);
                        if ((Y + 1) % St > 0) continue;
                        pt = o[s - 2],
                        D.copy(ht.positionScreen),
                        P.copy(pt.positionScreen),
                        z(D, P) === !0 && (D.multiplyScalar(1 / D.w), P.multiplyScalar(1 / P.w), h = q(), h.id = d.id, h.v1.positionScreen.copy(D), h.v2.positionScreen.copy(P), h.z = Math.max(D.z, P.z), h.renderOrder = d.renderOrder, h.material = d.material, d.material.vertexColors === THREE.VertexColors && (h.vertexColors[0].copy(d.geometry.colors[Y]), h.vertexColors[1].copy(d.geometry.colors[Y - 1])), w.elements.push(h))
                    }
                }
            } else if (d instanceof THREE.Sprite) {
                S.set(A.elements[12], A.elements[13], A.elements[14], 1),
                S.applyMatrix4(L);
                var xt = 1 / S.w;
                S.z *= xt,
                S.z >= -1 && S.z <= 1 && (m = R(), m.id = d.id, m.x = S.x * xt, m.y = S.y * xt, m.z = S.z, m.renderOrder = d.renderOrder, m.object = d, m.rotation = d.rotation, m.scale.x = d.scale.x * Math.abs(m.x - (S.x + r.projectionMatrix.elements[0]) / (S.w + r.projectionMatrix.elements[12])), m.scale.y = d.scale.y * Math.abs(m.y - (S.y + r.projectionMatrix.elements[5]) / (S.w + r.projectionMatrix.elements[13])), m.material = d.material, w.elements.push(m))
            }
        }
        return u === !0 && w.elements.sort(U),
        w
    }
},
define("projector", ["three"],
function() {}),
THREE.SpriteCanvasMaterial = function(e) {
    THREE.Material.call(this),
    this.type = "SpriteCanvasMaterial",
    this.color = new THREE.Color(16777215),
    this.program = function(e, t) {},
    this.setValues(e)
},
THREE.SpriteCanvasMaterial.prototype = Object.create(THREE.Material.prototype),
THREE.SpriteCanvasMaterial.prototype.constructor = THREE.SpriteCanvasMaterial,
THREE.SpriteCanvasMaterial.prototype.clone = function() {
    var e = new THREE.SpriteCanvasMaterial;
    return e.copy(this),
    e.color.copy(this.color),
    e.program = this.program,
    e
},
THREE.CanvasRenderer = function(e) {
    function bt() {
        ht.setRGB(0, 0, 0),
        pt.setRGB(0, 0, 0),
        dt.setRGB(0, 0, 0);
        for (var e = 0,
        t = i.length; e < t; e++) {
            var n = i[e],
            r = n.color;
            n instanceof THREE.AmbientLight ? ht.add(r) : n instanceof THREE.DirectionalLight ? pt.add(r) : n instanceof THREE.PointLight && dt.add(r)
        }
    }
    function wt(e, t, n) {
        for (var r = 0,
        s = i.length; r < s; r++) {
            var o = i[r];
            Z.copy(o.color);
            if (o instanceof THREE.DirectionalLight) {
                var u = vt.setFromMatrixPosition(o.matrixWorld).normalize(),
                a = t.dot(u);
                if (a <= 0) continue;
                a *= o.intensity,
                n.add(Z.multiplyScalar(a))
            } else if (o instanceof THREE.PointLight) {
                var u = vt.setFromMatrixPosition(o.matrixWorld),
                a = t.dot(vt.subVectors(u, e).normalize());
                if (a <= 0) continue;
                a *= o.distance == 0 ? 1 : 1 - Math.min(e.distanceTo(u) / o.distance, 1);
                if (a == 0) continue;
                a *= o.intensity,
                n.add(Z.multiplyScalar(a))
            }
        }
    }
    function Et(e, t, n) {
        Mt(n.opacity),
        _t(n.blending);
        var r = t.scale.x * f,
        i = t.scale.y * l,
        s = .5 * Math.sqrt(r * r + i * i);
        ct.min.set(e.x - s, e.y - s),
        ct.max.set(e.x + s, e.y + s);
        if (n instanceof THREE.SpriteMaterial) {
            var o = n.map;
            if (o !== null) {
                var u = et[o.id];
                if (u === undefined || u.version !== o.version) u = kt(o),
                et[o.id] = u;
                if (u.canvas !== undefined) {
                    jt(u.canvas);
                    var a = o.image,
                    c = a.width * o.offset.x,
                    h = a.height * o.offset.y,
                    p = a.width * o.repeat.x,
                    d = a.height * o.repeat.y,
                    v = r / p,
                    g = i / d;
                    m.save(),
                    m.translate(e.x, e.y),
                    n.rotation !== 0 && m.rotate(n.rotation),
                    m.translate( - r / 2, -i / 2),
                    m.scale(v, g),
                    m.translate( - c, -h),
                    m.fillRect(c, h, p, d),
                    m.restore()
                }
            } else jt(n.color.getStyle()),
            m.save(),
            m.translate(e.x, e.y),
            n.rotation !== 0 && m.rotate(n.rotation),
            m.scale(r, -i),
            m.fillRect( - 0.5, -0.5, 1, 1),
            m.restore()
        } else n instanceof THREE.SpriteCanvasMaterial && (Bt(n.color.getStyle()), jt(n.color.getStyle()), m.save(), m.translate(e.x, e.y), n.rotation !== 0 && m.rotate(n.rotation), m.scale(r, i), n.program(m), m.restore())
    }
    function St(e, t, n, r) {
        Mt(r.opacity),
        _t(r.blending),
        m.beginPath(),
        m.moveTo(e.positionScreen.x, e.positionScreen.y),
        m.lineTo(t.positionScreen.x, t.positionScreen.y);
        if (r instanceof THREE.LineBasicMaterial) {
            Dt(r.linewidth),
            Pt(r.linecap),
            Ht(r.linejoin);
            if (r.vertexColors !== THREE.VertexColors) Bt(r.color.getStyle());
            else {
                var i = n.vertexColors[0].getStyle(),
                s = n.vertexColors[1].getStyle();
                if (i === s) Bt(i);
                else {
                    try {
                        var o = m.createLinearGradient(e.positionScreen.x, e.positionScreen.y, t.positionScreen.x, t.positionScreen.y);
                        o.addColorStop(0, i),
                        o.addColorStop(1, s)
                    } catch(u) {
                        o = i
                    }
                    Bt(o)
                }
            }
            m.stroke(),
            ct.expandByScalar(r.linewidth * 2)
        } else r instanceof THREE.LineDashedMaterial && (Dt(r.linewidth), Pt(r.linecap), Ht(r.linejoin), Bt(r.color.getStyle()), Ft([r.dashSize, r.gapSize]), m.stroke(), ct.expandByScalar(r.linewidth * 2), Ft([]))
    }
    function xt(e, n, r, i, s, o, u, a) {
        t.info.render.vertices += 3,
        t.info.render.faces++,
        Mt(a.opacity),
        _t(a.blending),
        P = e.positionScreen.x,
        H = e.positionScreen.y,
        B = n.positionScreen.x,
        j = n.positionScreen.y,
        F = r.positionScreen.x,
        I = r.positionScreen.y,
        Tt(P, H, B, j, F, I);
        if ((a instanceof THREE.MeshLambertMaterial || a instanceof THREE.MeshPhongMaterial) && a.map === null) G.copy(a.color),
        Y.copy(a.emissive),
        a.vertexColors === THREE.FaceColors && G.multiply(u.color),
        V.copy(ht),
        mt.copy(e.positionWorld).add(n.positionWorld).add(r.positionWorld).divideScalar(3),
        wt(mt, u.normalModel, V),
        V.multiply(G).add(Y),
        a.wireframe === !0 ? Nt(V, a.wireframeLinewidth, a.wireframeLinecap, a.wireframeLinejoin) : Ct(V);
        else if (a instanceof THREE.MeshBasicMaterial || a instanceof THREE.MeshLambertMaterial || a instanceof THREE.MeshPhongMaterial) if (a.map !== null) {
            var f = a.map.mapping;
            f === THREE.UVMapping && (nt = u.uvs, Lt(P, H, B, j, F, I, nt[i].x, nt[i].y, nt[s].x, nt[s].y, nt[o].x, nt[o].y, a.map))
        } else a.envMap !== null ? a.envMap.mapping === THREE.SphericalReflectionMapping && (gt.copy(u.vertexNormalsModel[i]).applyMatrix3(yt), rt = .5 * gt.x + .5, it = .5 * gt.y + .5, gt.copy(u.vertexNormalsModel[s]).applyMatrix3(yt), st = .5 * gt.x + .5, ot = .5 * gt.y + .5, gt.copy(u.vertexNormalsModel[o]).applyMatrix3(yt), ut = .5 * gt.x + .5, at = .5 * gt.y + .5, Lt(P, H, B, j, F, I, rt, it, st, ot, ut, at, a.envMap)) : (V.copy(a.color), a.vertexColors === THREE.FaceColors && V.multiply(u.color), a.wireframe === !0 ? Nt(V, a.wireframeLinewidth, a.wireframeLinecap, a.wireframeLinejoin) : Ct(V));
        else a instanceof THREE.MeshNormalMaterial ? (gt.copy(u.normalModel).applyMatrix3(yt), V.setRGB(gt.x, gt.y, gt.z).multiplyScalar(.5).addScalar(.5), a.wireframe === !0 ? Nt(V, a.wireframeLinewidth, a.wireframeLinecap, a.wireframeLinejoin) : Ct(V)) : (V.setRGB(1, 1, 1), a.wireframe === !0 ? Nt(V, a.wireframeLinewidth, a.wireframeLinecap, a.wireframeLinejoin) : Ct(V))
    }
    function Tt(e, t, n, r, i, s) {
        m.beginPath(),
        m.moveTo(e, t),
        m.lineTo(n, r),
        m.lineTo(i, s),
        m.closePath()
    }
    function Nt(e, t, n, r) {
        Dt(t),
        Pt(n),
        Ht(r),
        Bt(e.getStyle()),
        m.stroke(),
        ct.expandByScalar(t * 2)
    }
    function Ct(e) {
        jt(e.getStyle()),
        m.fill()
    }
    function kt(e) {
        if (e.version === 0 || e instanceof THREE.CompressedTexture || e instanceof THREE.DataTexture) return {
            canvas: undefined,
            version: e.version
        };
        var t = e.image;
        if (t.complete === !1) return {
            canvas: undefined,
            version: 0
        };
        var n = document.createElement("canvas");
        n.width = t.width,
        n.height = t.height;
        var r = n.getContext("2d");
        r.setTransform(1, 0, 0, -1, 0, t.height),
        r.drawImage(t, 0, 0);
        var i = e.wrapS === THREE.RepeatWrapping,
        s = e.wrapT === THREE.RepeatWrapping,
        o = "no-repeat";
        i === !0 && s === !0 ? o = "repeat": i === !0 ? o = "repeat-x": s === !0 && (o = "repeat-y");
        var u = m.createPattern(n, o);
        return e.onUpdate && e.onUpdate(e),
        {
            canvas: u,
            version: e.version
        }
    }
    function Lt(e, t, n, r, i, s, o, u, a, f, l, c, h) {
        var p = et[h.id];
        if (p === undefined || p.version !== h.version) p = kt(h),
        et[h.id] = p;
        if (p.canvas === undefined) {
            jt("rgba( 0, 0, 0, 1)"),
            m.fill();
            return
        }
        jt(p.canvas);
        var d, v, g, y, b, w, E, S, x = h.offset.x / h.repeat.x,
        T = h.offset.y / h.repeat.y,
        N = h.image.width * h.repeat.x,
        C = h.image.height * h.repeat.y;
        o = (o + x) * N,
        u = (u + T) * C,
        a = (a + x) * N,
        f = (f + T) * C,
        l = (l + x) * N,
        c = (c + T) * C,
        n -= e,
        r -= t,
        i -= e,
        s -= t,
        a -= o,
        f -= u,
        l -= o,
        c -= u,
        E = a * c - l * f;
        if (E === 0) return;
        S = 1 / E,
        d = (c * n - f * i) * S,
        v = (c * r - f * s) * S,
        g = (a * i - l * n) * S,
        y = (a * s - l * r) * S,
        b = e - d * o - g * u,
        w = t - v * o - y * u,
        m.save(),
        m.transform(d, v, g, y, b, w),
        m.fill(),
        m.restore()
    }
    function At(e, t, n, r, i, s, o, u, a, f, l, c, h) {
        var p, d, v, g, y, b, w, E, S = h.width - 1,
        x = h.height - 1;
        o *= S,
        u *= x,
        a *= S,
        f *= x,
        l *= S,
        c *= x,
        n -= e,
        r -= t,
        i -= e,
        s -= t,
        a -= o,
        f -= u,
        l -= o,
        c -= u,
        w = a * c - l * f,
        E = 1 / w,
        p = (c * n - f * i) * E,
        d = (c * r - f * s) * E,
        v = (a * i - l * n) * E,
        g = (a * s - l * r) * E,
        y = e - p * o - v * u,
        b = t - d * o - g * u,
        m.save(),
        m.transform(p, d, v, g, y, b),
        m.clip(),
        m.drawImage(h, 0, 0),
        m.restore()
    }
    function Ot(e, t, n) {
        var r = t.x - e.x,
        i = t.y - e.y,
        s = r * r + i * i,
        o;
        if (s === 0) return;
        o = n / Math.sqrt(s),
        r *= o,
        i *= o,
        t.x += r,
        t.y += i,
        e.x -= r,
        e.y -= i
    }
    function Mt(e) {
        b !== e && (m.globalAlpha = e, b = e)
    }
    function _t(e) {
        w !== e && (e === THREE.NormalBlending ? m.globalCompositeOperation = "source-over": e === THREE.AdditiveBlending ? m.globalCompositeOperation = "lighter": e === THREE.SubtractiveBlending && (m.globalCompositeOperation = "darker"), w = e)
    }
    function Dt(e) {
        x !== e && (m.lineWidth = e, x = e)
    }
    function Pt(e) {
        T !== e && (m.lineCap = e, T = e)
    }
    function Ht(e) {
        N !== e && (m.lineJoin = e, N = e)
    }
    function Bt(e) {
        E !== e && (m.strokeStyle = e, E = e)
    }
    function jt(e) {
        S !== e && (m.fillStyle = e, S = e)
    }
    function Ft(e) {
        C.length !== e.length && (m.setLineDash(e), C = e)
    }
    console.log("THREE.CanvasRenderer", THREE.REVISION),
    e = e || {};
    var t = this,
    n, r, i, s = new THREE.Projector,
    o = e.canvas !== undefined ? e.canvas: document.createElement("canvas"),
    u = o.width,
    a = o.height,
    f = Math.floor(u / 2),
    l = Math.floor(a / 2),
    c = 0,
    h = 0,
    p = u,
    d = a,
    v = 1,
    m = o.getContext("2d", {
        alpha: e.alpha === !0
    }),
    g = new THREE.Color(0),
    y = e.alpha === !0 ? 0 : 1,
    b = 1,
    w = 0,
    E = null,
    S = null,
    x = null,
    T = null,
    N = null,
    C = [],
    k,
    L,
    A,
    O,
    M,
    _ = new THREE.RenderableVertex,
    D = new THREE.RenderableVertex,
    P,
    H,
    B,
    j,
    F,
    I,
    q,
    R,
    U,
    z,
    W,
    X,
    V = new THREE.Color,
    $ = new THREE.Color,
    J = new THREE.Color,
    K = new THREE.Color,
    Q = new THREE.Color,
    G = new THREE.Color,
    Y = new THREE.Color,
    Z = new THREE.Color,
    et = {},
    tt,
    nt,
    rt,
    it,
    st,
    ot,
    ut,
    at,
    ft = new THREE.Box2,
    lt = new THREE.Box2,
    ct = new THREE.Box2,
    ht = new THREE.Color,
    pt = new THREE.Color,
    dt = new THREE.Color,
    vt = new THREE.Vector3,
    mt = new THREE.Vector3,
    gt = new THREE.Vector3,
    yt = new THREE.Matrix3;
    m.setLineDash === undefined && (m.setLineDash = function() {}),
    this.domElement = o,
    this.autoClear = !0,
    this.sortObjects = !0,
    this.sortElements = !0,
    this.info = {
        render: {
            vertices: 0,
            faces: 0
        }
    },
    this.supportsVertexTextures = function() {},
    this.setFaceCulling = function() {},
    this.getContext = function() {
        return m
    },
    this.getContextAttributes = function() {
        return m.getContextAttributes()
    },
    this.getPixelRatio = function() {
        return v
    },
    this.setPixelRatio = function(e) {
        e !== undefined && (v = e)
    },
    this.setSize = function(e, t, n) {
        u = e * v,
        a = t * v,
        o.width = u,
        o.height = a,
        f = Math.floor(u / 2),
        l = Math.floor(a / 2),
        n !== !1 && (o.style.width = e + "px", o.style.height = t + "px"),
        ft.min.set( - f, -l),
        ft.max.set(f, l),
        lt.min.set( - f, -l),
        lt.max.set(f, l),
        b = 1,
        w = 0,
        E = null,
        S = null,
        x = null,
        T = null,
        N = null,
        this.setViewport(0, 0, e, t)
    },
    this.setViewport = function(e, t, n, r) {
        c = e * v,
        h = t * v,
        p = n * v,
        d = r * v
    },
    this.setScissor = function() {},
    this.setScissorTest = function() {},
    this.setClearColor = function(e, t) {
        g.set(e),
        y = t !== undefined ? t: 1,
        lt.min.set( - f, -l),
        lt.max.set(f, l)
    },
    this.setClearColorHex = function(e, t) {
        console.warn("THREE.CanvasRenderer: .setClearColorHex() is being removed. Use .setClearColor() instead."),
        this.setClearColor(e, t)
    },
    this.getClearColor = function() {
        return g
    },
    this.getClearAlpha = function() {
        return y
    },
    this.getMaxAnisotropy = function() {
        return 0
    },
    this.clear = function() {
        lt.isEmpty() === !1 && (lt.intersect(ft), lt.expandByScalar(2), lt.min.x = lt.min.x + f, lt.min.y = -lt.min.y + l, lt.max.x = lt.max.x + f, lt.max.y = -lt.max.y + l, y < 1 && m.clearRect(lt.min.x | 0, lt.max.y | 0, lt.max.x - lt.min.x | 0, lt.min.y - lt.max.y | 0), y > 0 && (_t(THREE.NormalBlending), Mt(1), jt("rgba(" + Math.floor(g.r * 255) + "," + Math.floor(g.g * 255) + "," + Math.floor(g.b * 255) + "," + y + ")"), m.fillRect(lt.min.x | 0, lt.max.y | 0, lt.max.x - lt.min.x | 0, lt.min.y - lt.max.y | 0)), lt.makeEmpty())
    },
    this.clearColor = function() {},
    this.clearDepth = function() {},
    this.clearStencil = function() {},
    this.render = function(e, o) {
        if (o instanceof THREE.Camera == 0) {
            console.error("THREE.CanvasRenderer.render: camera is not an instance of THREE.Camera.");
            return
        }
        this.autoClear === !0 && this.clear(),
        t.info.render.vertices = 0,
        t.info.render.faces = 0,
        m.setTransform(p / u, 0, 0, -d / a, c, a - h),
        m.translate(f, l),
        n = s.projectScene(e, o, this.sortObjects, this.sortElements),
        r = n.elements,
        i = n.lights,
        k = o,
        yt.getNormalMatrix(o.matrixWorldInverse),
        bt();
        for (var v = 0,
        g = r.length; v < g; v++) {
            var y = r[v],
            b = y.material;
            if (b === undefined || b.opacity === 0) continue;
            ct.makeEmpty();
            if (y instanceof THREE.RenderableSprite) L = y,
            L.x *= f,
            L.y *= l,
            Et(L, y, b);
            else if (y instanceof THREE.RenderableLine) L = y.v1,
            A = y.v2,
            L.positionScreen.x *= f,
            L.positionScreen.y *= l,
            A.positionScreen.x *= f,
            A.positionScreen.y *= l,
            ct.setFromPoints([L.positionScreen, A.positionScreen]),
            ft.intersectsBox(ct) === !0 && St(L, A, y, b);
            else if (y instanceof THREE.RenderableFace) {
                L = y.v1,
                A = y.v2,
                O = y.v3;
                if (L.positionScreen.z < -1 || L.positionScreen.z > 1) continue;
                if (A.positionScreen.z < -1 || A.positionScreen.z > 1) continue;
                if (O.positionScreen.z < -1 || O.positionScreen.z > 1) continue;
                L.positionScreen.x *= f,
                L.positionScreen.y *= l,
                A.positionScreen.x *= f,
                A.positionScreen.y *= l,
                O.positionScreen.x *= f,
                O.positionScreen.y *= l,
                b.overdraw > 0 && (Ot(L.positionScreen, A.positionScreen, b.overdraw), Ot(A.positionScreen, O.positionScreen, b.overdraw), Ot(O.positionScreen, L.positionScreen, b.overdraw)),
                ct.setFromPoints([L.positionScreen, A.positionScreen, O.positionScreen]),
                ft.intersectsBox(ct) === !0 && xt(L, A, O, 0, 1, 2, y, b)
            }
            lt.union(ct)
        }
        m.setTransform(1, 0, 0, 1, 0, 0)
    }
},
define("canvasRenderer", ["three"],
function() {});
var Bird = function() {
    function t(t, n, r) {
        e.vertices.push(new THREE.Vector3(t, n, r))
    }
    function n(t, n, r) {
        e.faces.push(new THREE.Face3(t, n, r))
    }
    var e = this;
    THREE.Geometry.call(this),
    t(5, 0, 0),
    t( - 5, -2, 1),
    t( - 5, 0, 0),
    t( - 5, -2, -1),
    t(0, 2, -6),
    t(0, 2, 6),
    t(2, 0, 0),
    t( - 3, 0, 0),
    n(0, 2, 1),
    n(4, 7, 6),
    n(5, 6, 7),
    this.computeFaceNormals()
};
Bird.prototype = Object.create(THREE.Geometry.prototype),
Bird.prototype.constructor = Bird,
define("bird", ["three"],
function() {}),
function() {
    var e, t, n, r, i, s, o, u, a, f, l, c, h, p, d, v, m, g, y, b, w, E, S, x, T, N, C = Object.prototype.hasOwnProperty,
    k = function(e, t) {
        function r() {
            this.constructor = e
        }
        for (var n in t) C.call(t, n) && (e[n] = t[n]);
        return r.prototype = t.prototype,
        e.prototype = new r,
        e.__super__ = t.prototype,
        e
    };
    n = {
        METHOD_NEAREST: "nearest",
        METHOD_LINEAR: "linear",
        METHOD_CUBIC: "cubic",
        METHOD_LANCZOS: "lanczos",
        METHOD_SINC: "sinc",
        CLIP_CLAMP: "clamp",
        CLIP_ZERO: "zero",
        CLIP_PERIODIC: "periodic",
        CLIP_MIRROR: "mirror",
        CUBIC_TENSION_DEFAULT: 0,
        CUBIC_TENSION_CATMULL_ROM: 0
    },
    c = {
        method: n.METHOD_CUBIC,
        cubicTension: n.CUBIC_TENSION_DEFAULT,
        clip: n.CLIP_CLAMP,
        scaleTo: 0,
        sincFilterSize: 2,
        sincWindow: void 0
    },
    a = function(e, t) {
        return Math.max(0, Math.min(e, t - 1))
    },
    l = function(e, t) {
        return e %= t,
        e < 0 && (e += t),
        e
    },
    f = function(e, t) {
        var n;
        return n = 2 * (t - 1),
        e = l(e, n),
        e > t - 1 && (e = n - e),
        e
    },
    e = function() {
        function e(e, t) {
            this.array = e.slice(0),
            this.length = this.array.length;
            if (! (this.clipHelper = {
                clamp: this.clipHelperClamp,
                zero: this.clipHelperZero,
                periodic: this.clipHelperPeriodic,
                mirror: this.clipHelperMirror
            } [t.clip])) throw "Invalid clip: " + t.clip
        }
        return e.prototype.getClippedInput = function(e) {
            return 0 <= e && e < this.length ? this.array[e] : this.clipHelper(e)
        },
        e.prototype.clipHelperClamp = function(e) {
            return this.array[a(e, this.length)]
        },
        e.prototype.clipHelperZero = function(e) {
            return 0
        },
        e.prototype.clipHelperPeriodic = function(e) {
            return this.array[l(e, this.length)]
        },
        e.prototype.clipHelperMirror = function(e) {
            return this.array[f(e, this.length)]
        },
        e.prototype.interpolate = function(e) {
            throw "Subclasses of AbstractInterpolator must override the interpolate() method."
        },
        e
    } (),
    i = function(e) {
        function t() {
            t.__super__.constructor.apply(this, arguments)
        }
        return k(t, e),
        t.prototype.interpolate = function(e) {
            return this.getClippedInput(Math.round(e))
        },
        t
    } (e),
    r = function(e) {
        function t() {
            t.__super__.constructor.apply(this, arguments)
        }
        return k(t, e),
        t.prototype.interpolate = function(e) {
            var t;
            return t = Math.floor(e),
            e -= t,
            (1 - e) * this.getClippedInput(t) + e * this.getClippedInput(t + 1)
        },
        t
    } (e),
    t = function(e) {
        function t(e, n) {
            this.tangentFactor = 1 - Math.max(0, Math.min(1, n.cubicTension)),
            t.__super__.constructor.apply(this, arguments)
        }
        return k(t, e),
        t.prototype.getTangent = function(e) {
            return this.tangentFactor * (this.getClippedInput(e + 1) - this.getClippedInput(e - 1)) / 2
        },
        t.prototype.interpolate = function(e) {
            var t, n, r, i, s;
            return t = Math.floor(e),
            n = [this.getTangent(t), this.getTangent(t + 1)],
            r = [this.getClippedInput(t), this.getClippedInput(t + 1)],
            e -= t,
            i = e * e,
            s = e * i,
            (2 * s - 3 * i + 1) * r[0] + (s - 2 * i + e) * n[0] + ( - 2 * s + 3 * i) * r[1] + (s - i) * n[1]
        },
        t
    } (e),
    E = Math.sin,
    s = Math.PI,
    S = function(e) {
        return e === 0 ? 1 : E(s * e) / (s * e)
    },
    m = function(e) {
        return function(t) {
            return S(t / e)
        }
    },
    y = function(e) {
        return function(t) {
            return S(t) * e(t)
        }
    },
    o = function(e) {
        function t(e, n) {
            t.__super__.constructor.apply(this, arguments),
            this.a = n.sincFilterSize;
            if (!n.sincWindow) throw "No sincWindow provided";
            this.kernel = y(n.sincWindow)
        }
        return k(t, e),
        t.prototype.interpolate = function(e) {
            var t, n, r, i, s;
            t = Math.floor(e),
            r = 0;
            for (n = i = t - this.a + 1, s = t + this.a; i <= s ? n <= s: n >= s; i <= s ? n++:n--) r += this.kernel(e - n) * this.getClippedInput(n);
            return r
        },
        t
    } (e),
    h = function(e, t) {
        var n, r, i, s;
        s = [];
        for (r = 0, i = e.length; r < i; r++) n = e[r],
        s.push(n[t]);
        return s
    },
    g = function(e, t, n) {
        var r, i;
        return n.join === "0,1" ? e: (r = t / (n[1] - n[0]), i = n[0],
        function(t) {
            return e(r * (t - i))
        })
    },
    p = function(e) {
        return Object.prototype.toString.call(e).slice("[object ".length, -1)
    },
    T = function(e) {
        if (isNaN(e)) throw "NaN in Smooth() input";
        if (p(e) !== "Number") throw "Non-number in Smooth() input";
        if (!isFinite(e)) throw "Infinity in Smooth() input"
    },
    N = function(e, t) {
        var n, r, i;
        if (p(e) !== "Array") throw "Non-vector in Smooth() input";
        if (e.length !== t) throw "Inconsistent dimension in Smooth() input";
        for (r = 0, i = e.length; r < i; r++) n = e[r],
        T(n)
    },
    d = function(e) {
        return p(e) === "Number" && isFinite(e) && !isNaN(e)
    },
    b = function(e) {
        var t;
        t = "scaleTo param must be number or array of two numbers";
        switch (p(e)) {
        case "Number":
            if (!d(e)) throw t;
            e = [0, e];
            break;
        case "Array":
            if (e.length !== 2) throw t;
            if (!d(e[0]) || !d(e[1])) throw t;
            break;
        default:
            throw t
        }
        return e
    },
    w = function(e) {
        var t, n, r;
        t = {};
        for (n in e) {
            if (!C.call(e, n)) continue;
            r = e[n],
            t[n] = r
        }
        return t
    },
    u = function(e, n) {
        var s, a, f, l, d, v, y, E, S, x, k;
        n == null && (n = {}),
        S = {},
        n = w(n),
        S.config = w(n),
        n.scaleTo == null && (n.scaleTo = n.period),
        n.sincFilterSize == null && (n.sincFilterSize = n.lanczosFilterSize);
        for (y in c) {
            if (!C.call(c, y)) continue;
            k = c[y],
            n[y] == null && (n[y] = k)
        }
        if (! (d = {
            nearest: i,
            linear: r,
            cubic: t,
            lanczos: o,
            sinc: o
        } [n.method])) throw "Invalid method: " + n.method;
        n.method === "lanczos" && (n.sincWindow = m(n.sincFilterSize));
        if (e.length < 2) throw "Array must have at least two elements";
        S.count = e.length,
        x = function() {
            var t, r, i, s;
            switch (p(e[0])) {
            case "Number":
                S.dimension = "scalar";
                if (u.deepValidation) for (t = 0, i = e.length; t < i; t++) E = e[t],
                T(E);
                return l = new d(e, n),
                function(e) {
                    return l.interpolate(e)
                };
            case "Array":
                S.dimension = a = e[0].length;
                if (!a) throw "Vectors must be non-empty";
                if (u.deepValidation) for (r = 0, s = e.length; r < s; r++) k = e[r],
                N(k, a);
                return v = function() {
                    var t;
                    t = [];
                    for (f = 0; 0 <= a ? f < a: f > a; 0 <= a ? f++:f--) t.push(new d(h(e, f), n));
                    return t
                } (),
                function(e) {
                    var t, n, r, i;
                    i = [];
                    for (n = 0, r = v.length; n < r; n++) t = v[n],
                    i.push(t.interpolate(e));
                    return i
                };
            default:
                throw "Invalid element type: " + p(e[0])
            }
        } (),
        n.clip === "periodic" ? s = e.length: s = e.length - 1,
        n.scaleTo || (n.scaleTo = s),
        S.domain = b(n.scaleTo),
        x = g(x, s, S.domain),
        S.domain.sort();
        for (y in S) {
            if (!C.call(S, y)) continue;
            k = S[y],
            x[y] = k
        }
        return x
    };
    for (v in n) {
        if (!C.call(n, v)) continue;
        x = n[v],
        u[v] = x
    }
    u.deepValidation = !0,
    (typeof exports != "undefined" && exports !== null ? exports: window).Smooth = u
}.call(this),
define("Smooth",
function() {}),
function(e) {
    e.fn.inViewport = function(t) {
        var n = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame ||
        function(e) {
            return setTimeout(e, 1e3 / 60)
        },
        r = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame || window.clearInterval,
        i = this,
        s,
        o,
        u = null,
        a,
        f,
        l,
        c,
        h,
        p,
        d,
        v,
        m,
        g = 0,
        y = !1,
        b = !1,
        w = e.extend({
            enterOffset: 0,
            exitOffset: 0,
            latencyRate: 0,
            onChangeInView: null,
            onEnterInView: null,
            onExitInView: null
        },
        t);
        this.init = function() {
            i._init()
        },
        this.start = function() {
            y = !0
        },
        this.stop = function() {
            y = !1
        },
        this.update = function() {
            i._update()
        },
        this.destroy = function() {
            y = !1,
            b = !0,
            r(m),
            i._destroyResize()
        },
        this._init = function() {
            s = (new Date).valueOf().toString() + Math.random().toString(),
            i._findStaticValues(),
            i._initRaf(),
            i._initOnResize()
        },
        this._update = function() {
            i._updateStaticValues()
        },
        this._findStaticValues = function() {
            w.latencyRate == 1 && (w.latencyRate = 0),
            i._findStaticPageValues(),
            l = null,
            l = [],
            i.each(function(t) {
                var n = e(this),
                r = {};
                r.id = t,
                r.$elem = n,
                l.push(r)
            }),
            c = l.length,
            i._findStaticElemValues()
        },
        this._findStaticPageValues = function() {
            a = e(window),
            f = a.height()
        },
        this._findStaticElemValues = function() {
            for (var e = 0; e < c; e++) {
                var t = l[e],
                n = t.$elem;
                t.height = n.height(),
                t.inView = t.inView || !1,
                t.offTopY = n.offset().top,
                t.offBotY = t.offTopY + t.height
            }
        },
        this._updateStaticValues = function() {
            i._findStaticPageValues(),
            i._findStaticElemValues()
        },
        this._initRaf = function() {
            m = n(i._doRaf)
        },
        this._doRaf = function() {
            if (b) return;
            if (!y) {
                m = n(i._doRaf);
                return
            }
            g++;
            if (w.latencyRate && g % w.latencyRate) {
                m = n(i._doRaf);
                return
            }
            i._findDynamicValues(),
            i._checkInViewport(),
            m = n(i._doRaf)
        };
        var E, S;
        return this._findDynamicValues = function() {
            E = a.scrollTop(),
            S = E + f
        },
        this._checkInViewport = function() {
            for (var e = 0; e < c; e++) {
                var t = l[e],
                n = t.inView,
                r = S > t.offTopY ? !0 : !1,
                i = t.offBotY > E ? !0 : !1;
                r && i ? n = !0 : n = !1,
                t.inView != n && (t.inView = n, w.onChangeInView && w.onChangeInView(t), w.onEnterInView && t.inView && w.onEnterInView(t), w.onExitInView && !t.inView && w.onExitInView(t))
            }
        },
        this._initOnResize = function() {
            o = "resize." + s,
            a.on(o,
            function() {
                i._resize()
            })
        },
        this._resize = function() {
            i._update()
        },
        this._destroyResize = function() {
            a.off(o)
        },
        i.init(),
        this
    }
} (jQuery),
define("jquery.inViewport", ["jquery"],
function() {}),
!
function(e) {
    "function" == typeof define && define.amd ? define("jquery.mousewheel", ["jquery"], e) : "object" == typeof exports ? module.exports = e: e(jQuery)
} (function(e) {
    function t(t) {
        var o = t || window.event,
        u = a.call(arguments, 1),
        f = 0,
        h = 0,
        p = 0,
        v = 0,
        m = 0,
        g = 0;
        if (t = e.event.fix(o), t.type = "mousewheel", "detail" in o && (p = -1 * o.detail), "wheelDelta" in o && (p = o.wheelDelta), "wheelDeltaY" in o && (p = o.wheelDeltaY), "wheelDeltaX" in o && (h = -1 * o.wheelDeltaX), "axis" in o && o.axis === o.HORIZONTAL_AXIS && (h = -1 * p, p = 0), f = 0 === p ? h: p, "deltaY" in o && (p = -1 * o.deltaY, f = p), "deltaX" in o && (h = o.deltaX, 0 === p && (f = -1 * h)), 0 !== p || 0 !== h) {
            if (1 === o.deltaMode) {
                var y = e.data(this, "mousewheel-line-height");
                f *= y,
                p *= y,
                h *= y
            } else if (2 === o.deltaMode) {
                var b = e.data(this, "mousewheel-page-height");
                f *= b,
                p *= b,
                h *= b
            }
            if (v = Math.max(Math.abs(p), Math.abs(h)), (!s || s > v) && (s = v, r(o, v) && (s /= 40)), r(o, v) && (f /= 40, h /= 40, p /= 40), f = Math[f >= 1 ? "floor": "ceil"](f / s), h = Math[h >= 1 ? "floor": "ceil"](h / s), p = Math[p >= 1 ? "floor": "ceil"](p / s), l.settings.normalizeOffset && this.getBoundingClientRect) {
                var w = this.getBoundingClientRect();
                m = t.clientX - w.left,
                g = t.clientY - w.top
            }
            return t.deltaX = h,
            t.deltaY = p,
            t.deltaFactor = s,
            t.offsetX = m,
            t.offsetY = g,
            t.deltaMode = 0,
            u.unshift(t, f, h, p),
            i && clearTimeout(i),
            i = setTimeout(n, 200),
            (e.event.dispatch || e.event.handle).apply(this, u)
        }
    }
    function n() {
        s = null
    }
    function r(e, t) {
        return l.settings.adjustOldDeltas && "mousewheel" === e.type && t % 120 === 0
    }
    var i, s, o = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
    u = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
    a = Array.prototype.slice;
    if (e.event.fixHooks) for (var f = o.length; f;) e.event.fixHooks[o[--f]] = e.event.mouseHooks;
    var l = e.event.special.mousewheel = {
        version: "3.1.12",
        setup: function() {
            if (this.addEventListener) for (var n = u.length; n;) this.addEventListener(u[--n], t, !1);
            else this.onmousewheel = t;
            e.data(this, "mousewheel-line-height", l.getLineHeight(this)),
            e.data(this, "mousewheel-page-height", l.getPageHeight(this))
        },
        teardown: function() {
            if (this.removeEventListener) for (var n = u.length; n;) this.removeEventListener(u[--n], t, !1);
            else this.onmousewheel = null;
            e.removeData(this, "mousewheel-line-height"),
            e.removeData(this, "mousewheel-page-height")
        },
        getLineHeight: function(t) {
            var n = e(t),
            r = n["offsetParent" in e.fn ? "offsetParent": "parent"]();
            return r.length || (r = e("body")),
            parseInt(r.css("fontSize"), 10) || parseInt(n.css("fontSize"), 10) || 16
        },
        getPageHeight: function(t) {
            return e(t).height()
        },
        settings: {
            adjustOldDeltas: !0,
            normalizeOffset: !0
        }
    };
    e.fn.extend({
        mousewheel: function(e) {
            return e ? this.bind("mousewheel", e) : this.trigger("mousewheel")
        },
        unmousewheel: function(e) {
            return this.unbind("mousewheel", e)
        }
    })
}),
function(e) {
    function t(t, n, r, i) {
        var s = t.text().split(n),
        o = "";
        s.length && (e(s).each(function(e, t) {
            o += '<span class="' + r + (e + 1) + '">' + t + "</span>" + i
        }), t.empty().append(o))
    }
    var n = {
        init: function() {
            return this.each(function() {
                t(e(this), "", "char", "")
            })
        },
        words: function() {
            return this.each(function() {
                t(e(this), " ", "word", " ")
            })
        },
        lines: function() {
            return this.each(function() {
                var n = "eefec303079ad17405c889e092e105b0";
                t(e(this).children("br").replaceWith(n).end(), n, "line", "")
            })
        }
    };
    e.fn.lettering = function(t) {
        return t && n[t] ? n[t].apply(this, [].slice.call(arguments, 1)) : t === "letters" || !t ? n.init.apply(this, [].slice.call(arguments, 0)) : (e.error("Method " + t + " does not exist on jQuery.lettering"), this)
    }
} (jQuery),
define("jquery.lettering", ["jquery"],
function() {}),
function(e) {
    function t(t) {
        return /In/.test(t) || e.inArray(t, e.fn.textillate.defaults.inEffects) >= 0
    }
    function n(t) {
        return /Out/.test(t) || e.inArray(t, e.fn.textillate.defaults.outEffects) >= 0
    }
    function r(e) {
        return e !== "true" && e !== "false" ? e: e === "true"
    }
    function i(t) {
        var n = t.attributes || [],
        i = {};
        return n.length ? (e.each(n,
        function(e, t) {
            var n = t.nodeName.replace(/delayscale/, "delayScale");
            /^data-in-*/.test(n) ? (i. in =i. in ||{},
            i. in [n.replace(/data-in-/, "")] = r(t.nodeValue)) : /^data-out-*/.test(n) ? (i.out = i.out || {},
            i.out[n.replace(/data-out-/, "")] = r(t.nodeValue)) : /^data-*/.test(n) && (i[n.replace(/data-/, "")] = r(t.nodeValue))
        }), i) : i
    }
    function s(e) {
        for (var t, n, r = e.length; r; t = parseInt(Math.random() * r), n = e[--r], e[r] = e[t], e[t] = n);
        return e
    }
    function o(e, t, n) {
        e.addClass("animated " + t).css("visibility", "visible").show(),
        e.one("webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend",
        function() {
            e.removeClass("animated " + t),
            n && n()
        })
    }
    function u(r, i, u) {
        var a = this,
        f = r.length;
        if (!f) {
            u && u();
            return
        }
        i.shuffle && (r = s(r)),
        i.reverse && (r = r.toArray().reverse()),
        e.each(r,
        function(r, s) {
            function l() {
                t(i.effect) ? a.css("visibility", "visible") : n(i.effect) && a.css("visibility", "hidden"),
                f -= 1,
                !f && u && u()
            }
            var a = e(s),
            c = i.sync ? i.delay: i.delay * r * i.delayScale;
            a.text() ? setTimeout(function() {
                o(a, i.effect, l)
            },
            c) : l()
        })
    }
    var a = function(r, s) {
        var o = this,
        a = e(r);
        o.init = function() {
            o.$texts = a.find(s.selector),
            o.$texts.length || (o.$texts = e('<ul class="texts"><li>' + a.html() + "</li></ul>"), a.html(o.$texts)),
            o.$texts.hide(),
            o.$current = e("<span>").html(o.$texts.find(":first-child").html()).prependTo(a),
            t(s. in .effect) ? o.$current.css("visibility", "hidden") : n(s.out.effect) && o.$current.css("visibility", "visible"),
            o.setOptions(s),
            o.timeoutRun = null,
            setTimeout(function() {
                o.options.autoStart && o.start()
            },
            o.options.initialDelay)
        },
        o.setOptions = function(e) {
            o.options = e
        },
        o.triggerEvent = function(t) {
            var n = e.Event(t + ".tlt");
            return a.trigger(n, o),
            n
        },
        o. in =function(r, s) {
            r = r || 0;
            var a = o.$texts.find(":nth-child(" + ((r || 0) + 1) + ")"),
            f = e.extend(!0, {},
            o.options, a.length ? i(a[0]) : {}),
            l;
            a.addClass("current"),
            o.triggerEvent("inAnimationBegin"),
            o.$current.html(a.html()).lettering("words"),
            o.options.type == "char" && o.$current.find('[class^="word"]').css({
                display: "inline-block",
                "-webkit-transform": "translate3d(0,0,0)",
                "-moz-transform": "translate3d(0,0,0)",
                "-o-transform": "translate3d(0,0,0)",
                transform: "translate3d(0,0,0)"
            }).each(function() {
                e(this).lettering()
            }),
            l = o.$current.find('[class^="' + o.options.type + '"]').css("display", "inline-block"),
            t(f. in .effect) ? l.css("visibility", "hidden") : n(f. in .effect) && l.css("visibility", "visible"),
            o.currentIndex = r,
            u(l, f. in ,
            function() {
                o.triggerEvent("inAnimationEnd"),
                f. in .callback && f. in .callback(),
                s && s(o)
            })
        },
        o.out = function(t) {
            var n = o.$texts.find(":nth-child(" + ((o.currentIndex || 0) + 1) + ")"),
            r = o.$current.find('[class^="' + o.options.type + '"]'),
            s = e.extend(!0, {},
            o.options, n.length ? i(n[0]) : {});
            o.triggerEvent("outAnimationBegin"),
            u(r, s.out,
            function() {
                n.removeClass("current"),
                o.triggerEvent("outAnimationEnd"),
                s.out.callback && s.out.callback(),
                t && t(o)
            })
        },
        o.start = function(e) {
            setTimeout(function() {
                o.triggerEvent("start"),
                function t(e) {
                    o. in (e,
                    function() {
                        var n = o.$texts.children().length;
                        e += 1,
                        !o.options.loop && e >= n ? (o.options.callback && o.options.callback(), o.triggerEvent("end")) : (e %= n, o.timeoutRun = setTimeout(function() {
                            o.out(function() {
                                t(e)
                            })
                        },
                        o.options.minDisplayTime))
                    })
                } (e || 0)
            },
            o.options.initialDelay)
        },
        o.stop = function() {
            o.timeoutRun && (clearInterval(o.timeoutRun), o.timeoutRun = null)
        },
        o.init()
    };
    e.fn.textillate = function(t, n) {
        return this.each(function() {
            var r = e(this),
            s = r.data("textillate"),
            o = e.extend(!0, {},
            e.fn.textillate.defaults, i(this), typeof t == "object" && t);
            s ? typeof t == "string" ? s[t].apply(s, [].concat(n)) : s.setOptions.call(s, o) : r.data("textillate", s = new a(this, o))
        })
    },
    e.fn.textillate.defaults = {
        selector: ".texts",
        loop: !1,
        minDisplayTime: 2e3,
        initialDelay: 0,
        "in": {
            effect: "fadeInLeftBig",
            delayScale: 1.5,
            delay: 50,
            sync: !1,
            reverse: !1,
            shuffle: !1,
            callback: function() {}
        },
        out: {
            effect: "hinge",
            delayScale: 1.5,
            delay: 50,
            sync: !1,
            reverse: !1,
            shuffle: !1,
            callback: function() {}
        },
        autoStart: !0,
        inEffects: [],
        outEffects: ["hinge"],
        callback: function() {},
        type: "char"
    }
} (jQuery),
define("jquery.textillate", ["jquery", "jquery.lettering"],
function() {}),
require.config({
    paths: {
        jquery: "ext/jquery.min",
        underscore: "ext/underscore.min",
        backbone: "ext/backbone.min",
        TweenMax: "ext/gsap/TweenMax.min",
        scrollToPlugin: "ext/gsap/plugins/ScrollToPlugin.min",
        Modernizr: "ext/modernizr.custom.min",
        pxloader: "ext/pxloader/PxLoader",
        pxloaderImage: "ext/pxloader/PxLoaderImage",
        pxloaderAudio: "ext/pxloader/PxLoaderAudio",
        pxloaderVideo: "ext/pxloader/PxLoaderVideo",
        three: "ext/three/three.min",
        projector: "ext/three/Projector",
        canvasRenderer: "ext/three/CanvasRenderer",
        bird: "ext/three/Bird",
        Smooth: "ext/Smooth",
        fractal: "ext/canvas/fractal",
        color: "ext/canvas/color/color",
        animation: "ext/canvas/animation",
        pythagoras: "ext/canvas/pythagoras",
        koch: "ext/canvas/koch",
        oriDomi: "ext/oridomi.min",
        sketch: "ext/canvas/sketch",
        "jquery.inViewport": "ext/jquery.inViewport",
        "jquery.mousewheel": "ext/jquery.mousewheel.min",
        "jquery.lettering": "ext/jquery.lettering",
        "jquery.textillate": "ext/textillate/jquery.textillate"
    },
    shim: {
        underscore: {
            exports: "_"
        },
        backbone: {
            deps: ["underscore", "jquery"],
            exports: "Backbone"
        },
        scrollToPlugin: {
            deps: ["TweenMax"]
        },
        pxloaderImage: {
            deps: ["pxloader"]
        },
        pxloaderAudio: {
            deps: ["pxloader"]
        },
        pxloaderVideo: {
            deps: ["pxloader"]
        },
        three: {
            exports: "THREE"
        },
        projector: {
            deps: ["three"]
        },
        canvasRenderer: {
            deps: ["three"]
        },
        bird: {
            deps: ["three"]
        },
        fractal: {
            deps: ["color"]
        },
        animation: {
            deps: ["fractal"]
        },
        pythagoras: {
            deps: ["fractal"]
        },
        koch: {
            deps: ["fractal"]
        },
        oriDomi: {
            deps: ["jquery"],
            exports: "OriDomi"
        },
        sketch: {
            deps: ["jquery"],
            exports: "Sketch"
        },
        "jquery.inViewport": {
            deps: ["jquery"]
        },
        "jquery.mousewheel": {
            deps: ["jquery"]
        },
        "jquery.lettering": {
            deps: ["jquery"]
        },
        "jquery.textillate": {
            deps: ["jquery", "jquery.lettering"]
        }
    }
}),
require(["jquery", "underscore", "backbone", "TweenMax", "app/general/GeneralView", "app/jukebox/Jukebox", "app/detector/Detector", "app/birds/Birds", "app/routers/Router", "scrollToPlugin", "Modernizr", "pxloader", "pxloaderImage", "pxloaderAudio", "pxloaderVideo", "three", "projector", "canvasRenderer", "bird", "Smooth", "oriDomi", "sketch", "jquery.inViewport", "jquery.mousewheel", "jquery.lettering", "jquery.textillate"],
function(e, t, n, r, i, s, o, u, a) {
    function l() {
        h(),
        e(window).resize(h);
        var t = new o;
        App.BROWSER = t.detectBrowser(),
        App.DEVICETYPE = t.detectDeviceType(),
        e("body").addClass(App.BROWSER),
        e("body").addClass(App.DEVICETYPE),
        App.DEVICETYPE == "desktop" && (App.JUKEBOX = new s, App.JUKEBOX.init()),
        App.BIRDS = new u,
        App.BIRDS.init(),
        App.BIRDS.play(),
        r.to(e("#birds-canvas-holder"), 1, {
            opacity: 1,
            onStart: function() {
                App.JUKEBOX && App.JUKEBOX.playTrack(e(".birds-loop.loop"), "loop")
            }
        }),
        r.staggerTo(e(".grid-overlay .grid-line"), .7, {
            y: 0,
            ease: Circ.easeInOut
        },
        .12),
        r.to(e("#main-circle-intro"), 1.4, {
            delay: 1,
            opacity: 1,
            width: "79.5vh",
            height: "79.5vh",
            ease: Circ.easeInOut,
            onComplete: function() {
                e(".main-circle-title").css({
                    opacity: 1
                }),
                e(".main-circle-title").textillate({
                    "in": {
                        effect: "fadeInRight"
                    },
                    callback: function() {
                        c()
                    }
                }),
                e(".sub-circle-title").css({
                    opacity: 1
                }),
                e(".sub-circle-title").textillate({
                    "in": {
                        effect: "fadeInRight"
                    }
                })
            }
        })
    }
    function c() {
        a.init()
    }
    function h() {
        e(".section-intro").css({
            height: window.innerHeight
        })
    }
    $win = e(window);
    var f;
    l()
}),
define("app",
function() {});